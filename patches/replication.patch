diff --git a/src/hbm_subsystem/build.tcl b/src/hbm_subsystem/build.tcl
new file mode 100644
index 0000000..b50577f
--- /dev/null
+++ b/src/hbm_subsystem/build.tcl
@@ -0,0 +1,2 @@
+    read_verilog -quiet [glob -nocomplain -directory $module_dir/memory_controller "*.{v,vh}"]
+    read_verilog -quiet -sv [glob -nocomplain -directory $module_dir/memory_controller "*.sv"]
\ No newline at end of file
diff --git a/src/hbm_subsystem/hbm_bd.tcl b/src/hbm_subsystem/hbm_bd.tcl
index 97fedbc..2f54b9e 100644
--- a/src/hbm_subsystem/hbm_bd.tcl
+++ b/src/hbm_subsystem/hbm_bd.tcl
@@ -134,6 +134,7 @@ xilinx.com:ip:hbm:1.0\
 xilinx.com:ip:clk_wiz:6.0\
 xilinx.com:ip:proc_sys_reset:5.0\
 xilinx.com:ip:smartconnect:1.0\
+xilinx.com:ip:axi_datamover:5.1\
 "
 
    set list_ips_missing ""
@@ -229,15 +230,74 @@ proc create_root_design { parentCell } {
    CONFIG.WUSER_WIDTH {64} \
    ] $s_axi_hbm
 
+  set s_axis_dm_s2mm [ create_bd_intf_port -mode Slave -vlnv xilinx.com:interface:axis_rtl:1.0 s_axis_dm_s2mm ]
+  set_property -dict [ list \
+   CONFIG.FREQ_HZ {250000000} \
+   CONFIG.HAS_TKEEP {1} \
+   CONFIG.HAS_TLAST {1} \
+   CONFIG.HAS_TREADY {1} \
+   CONFIG.HAS_TSTRB {0} \
+   CONFIG.LAYERED_METADATA {undef} \
+   CONFIG.TDATA_NUM_BYTES {64} \
+   CONFIG.TDEST_WIDTH {0} \
+   CONFIG.TID_WIDTH {0} \
+   CONFIG.TUSER_WIDTH {0} \
+   ] $s_axis_dm_s2mm
+
+  set s_axis_dm_s2mm_cmd [ create_bd_intf_port -mode Slave -vlnv xilinx.com:interface:axis_rtl:1.0 s_axis_dm_s2mm_cmd ]
+  set_property -dict [ list \
+   CONFIG.FREQ_HZ {250000000} \
+   CONFIG.HAS_TKEEP {0} \
+   CONFIG.HAS_TLAST {0} \
+   CONFIG.HAS_TREADY {1} \
+   CONFIG.HAS_TSTRB {0} \
+   CONFIG.LAYERED_METADATA {undef} \
+   CONFIG.TDATA_NUM_BYTES {10} \
+   CONFIG.TDEST_WIDTH {0} \
+   CONFIG.TID_WIDTH {0} \
+   CONFIG.TUSER_WIDTH {0} \
+   ] $s_axis_dm_s2mm_cmd
+
+  set s_axis_dm_mm2s_cmd [ create_bd_intf_port -mode Slave -vlnv xilinx.com:interface:axis_rtl:1.0 s_axis_dm_mm2s_cmd ]
+  set_property -dict [ list \
+   CONFIG.FREQ_HZ {250000000} \
+   CONFIG.HAS_TKEEP {0} \
+   CONFIG.HAS_TLAST {0} \
+   CONFIG.HAS_TREADY {1} \
+   CONFIG.HAS_TSTRB {0} \
+   CONFIG.LAYERED_METADATA {undef} \
+   CONFIG.TDATA_NUM_BYTES {10} \
+   CONFIG.TDEST_WIDTH {0} \
+   CONFIG.TID_WIDTH {0} \
+   CONFIG.TUSER_WIDTH {0} \
+   ] $s_axis_dm_mm2s_cmd
+
+  set m_axis_dm_mm2s [ create_bd_intf_port -mode Master -vlnv xilinx.com:interface:axis_rtl:1.0 m_axis_dm_mm2s ]
+  set_property -dict [ list \
+   CONFIG.FREQ_HZ {250000000} \
+   ] $m_axis_dm_mm2s
+
+  set m_axis_dm_s2mm_status [ create_bd_intf_port -mode Master -vlnv xilinx.com:interface:axis_rtl:1.0 m_axis_dm_s2mm_status ]
+  set_property -dict [ list \
+   CONFIG.FREQ_HZ {250000000} \
+   ] $m_axis_dm_s2mm_status
+
+  set m_axis_dm_mm2s_status [ create_bd_intf_port -mode Master -vlnv xilinx.com:interface:axis_rtl:1.0 m_axis_dm_mm2s_status ]
+  set_property -dict [ list \
+   CONFIG.FREQ_HZ {250000000} \
+   ] $m_axis_dm_mm2s_status
+
 
   # Create ports
   set axi_resetn [ create_bd_port -dir I axi_resetn ]
   set hbm_ref_clk [ create_bd_port -dir I -type clk -freq_hz 100000000 hbm_ref_clk ]
   set axi_clk [ create_bd_port -dir I -type clk -freq_hz 250000000 axi_clk ]
   set_property -dict [ list \
-   CONFIG.ASSOCIATED_BUSIF {s_axi_hbm} \
+   CONFIG.ASSOCIATED_BUSIF {s_axi_hbm:s_axis_dm_s2mm:s_axis_dm_s2mm_cmd:s_axis_dm_mm2s_cmd:m_axis_dm_mm2s:m_axis_dm_s2mm_status:m_axis_dm_mm2s_status} \
    CONFIG.CLK_DOMAIN {hbm_bd_0_0_axi_aclk} \
  ] $axi_clk
+  set apb_complete_0 [ create_bd_port -dir O apb_complete_0 ]
+  set apb_complete_1 [ create_bd_port -dir O apb_complete_1 ]
 
   # Create instance: hbm_0, and set properties
   set hbm_0 [ create_bd_cell -type ip -vlnv xilinx.com:ip:hbm:1.0 hbm_0 ]
@@ -262,7 +322,7 @@ proc create_root_design { parentCell } {
     CONFIG.USER_SAXI_12 {false} \
     CONFIG.USER_SAXI_13 {false} \
     CONFIG.USER_SAXI_14 {false} \
-    CONFIG.USER_SAXI_16 {false} \
+    CONFIG.USER_SAXI_16 {true} \
     CONFIG.USER_SAXI_17 {false} \
     CONFIG.USER_SAXI_18 {false} \
     CONFIG.USER_SAXI_19 {false} \
@@ -309,14 +369,69 @@ proc create_root_design { parentCell } {
   ] $smartconnect_0
 
 
+  # Create instance: axi_datamover_0, and set properties
+  set axi_datamover_0 [ create_bd_cell -type ip -vlnv xilinx.com:ip:axi_datamover:5.1 axi_datamover_0 ]
+  set_property -dict [list \
+    CONFIG.c_addr_width {34} \
+    CONFIG.c_dummy {1} \
+    CONFIG.c_enable_cache_user {false} \
+    CONFIG.c_m_axi_mm2s_data_width {512} \
+    CONFIG.c_m_axi_mm2s_id_width {0} \
+    CONFIG.c_m_axi_s2mm_data_width {512} \
+    CONFIG.c_m_axi_s2mm_id_width {0} \
+    CONFIG.c_m_axis_mm2s_tdata_width {512} \
+    CONFIG.c_mm2s_btt_used {23} \
+    CONFIG.c_mm2s_burst_size {64} \
+    CONFIG.c_mm2s_include_sf {true} \
+    CONFIG.c_s2mm_btt_used {23} \
+    CONFIG.c_s2mm_burst_size {64} \
+    CONFIG.c_s2mm_support_indet_btt {false} \
+    CONFIG.c_s_axis_s2mm_tdata_width {512} \
+    CONFIG.c_single_interface {1} \
+  ] $axi_datamover_0
+
+
+  # Create instance: smartconnect_1, and set properties
+  set smartconnect_1 [ create_bd_cell -type ip -vlnv xilinx.com:ip:smartconnect:1.0 smartconnect_1 ]
+  set_property -dict [list \
+    CONFIG.NUM_MI {1} \
+    CONFIG.NUM_SI {1} \
+  ] $smartconnect_1
+
+
   # Create interface connections
   connect_bd_intf_net -intf_net S00_AXI_0_1 [get_bd_intf_ports s_axi_hbm] [get_bd_intf_pins smartconnect_0/S00_AXI]
+  connect_bd_intf_net -intf_net S_AXIS_MM2S_CMD_0_1 [get_bd_intf_ports s_axis_dm_mm2s_cmd] [get_bd_intf_pins axi_datamover_0/S_AXIS_MM2S_CMD]
+  connect_bd_intf_net -intf_net S_AXIS_S2MM_0_1 [get_bd_intf_ports s_axis_dm_s2mm] [get_bd_intf_pins axi_datamover_0/S_AXIS_S2MM]
+  connect_bd_intf_net -intf_net S_AXIS_S2MM_CMD_0_1 [get_bd_intf_ports s_axis_dm_s2mm_cmd] [get_bd_intf_pins axi_datamover_0/S_AXIS_S2MM_CMD]
+  connect_bd_intf_net -intf_net axi_datamover_0_M_AXI [get_bd_intf_pins axi_datamover_0/M_AXI] [get_bd_intf_pins smartconnect_1/S00_AXI]
+  connect_bd_intf_net -intf_net axi_datamover_0_M_AXIS_MM2S [get_bd_intf_ports m_axis_dm_mm2s] [get_bd_intf_pins axi_datamover_0/M_AXIS_MM2S]
+  connect_bd_intf_net -intf_net axi_datamover_0_M_AXIS_MM2S_STS [get_bd_intf_ports m_axis_dm_mm2s_status] [get_bd_intf_pins axi_datamover_0/M_AXIS_MM2S_STS]
+  connect_bd_intf_net -intf_net axi_datamover_0_M_AXIS_S2MM_STS [get_bd_intf_ports m_axis_dm_s2mm_status] [get_bd_intf_pins axi_datamover_0/M_AXIS_S2MM_STS]
   connect_bd_intf_net -intf_net smartconnect_0_M00_AXI [get_bd_intf_pins smartconnect_0/M00_AXI] [get_bd_intf_pins hbm_0/SAXI_15_8HI]
+  connect_bd_intf_net -intf_net smartconnect_1_M00_AXI [get_bd_intf_pins smartconnect_1/M00_AXI] [get_bd_intf_pins hbm_0/SAXI_16_8HI]
 
   # Create port connections
   connect_bd_net -net aclk_0_1  [get_bd_ports axi_clk] \
   [get_bd_pins smartconnect_0/aclk] \
-  [get_bd_pins hbm_0/AXI_15_ACLK]
+  [get_bd_pins hbm_0/AXI_15_ACLK] \
+  [get_bd_pins smartconnect_1/aclk] \
+  [get_bd_pins axi_datamover_0/m_axi_mm2s_aclk] \
+  [get_bd_pins axi_datamover_0/m_axis_mm2s_cmdsts_aclk] \
+  [get_bd_pins axi_datamover_0/m_axi_s2mm_aclk] \
+  [get_bd_pins axi_datamover_0/m_axis_s2mm_cmdsts_awclk] \
+  [get_bd_pins hbm_0/AXI_16_ACLK]
+  connect_bd_net -net axi_aresetn_0  [get_bd_ports axi_resetn] \
+  [get_bd_pins hbm_0/AXI_15_ARESET_N] \
+  [get_bd_pins smartconnect_0/aresetn] \
+  [get_bd_pins clk_wiz_0/resetn] \
+  [get_bd_pins proc_sys_reset_0/ext_reset_in] \
+  [get_bd_pins hbm_0/AXI_16_ARESET_N] \
+  [get_bd_pins smartconnect_1/aresetn] \
+  [get_bd_pins axi_datamover_0/m_axi_mm2s_aresetn] \
+  [get_bd_pins axi_datamover_0/m_axis_s2mm_cmdsts_aresetn] \
+  [get_bd_pins axi_datamover_0/m_axi_s2mm_aresetn] \
+  [get_bd_pins axi_datamover_0/m_axis_mm2s_cmdsts_aresetn]
   connect_bd_net -net clk_in1_0_1  [get_bd_ports hbm_ref_clk] \
   [get_bd_pins clk_wiz_0/clk_in1]
   connect_bd_net -net clk_wiz_0_clk_out1  [get_bd_pins clk_wiz_0/clk_out1] \
@@ -327,48 +442,79 @@ proc create_root_design { parentCell } {
   [get_bd_pins proc_sys_reset_0/slowest_sync_clk]
   connect_bd_net -net clk_wiz_0_locked  [get_bd_pins clk_wiz_0/locked] \
   [get_bd_pins proc_sys_reset_0/dcm_locked]
+  connect_bd_net -net hbm_0_apb_complete_0  [get_bd_pins hbm_0/apb_complete_0] \
+  [get_bd_ports apb_complete_0]
+  connect_bd_net -net hbm_0_apb_complete_1  [get_bd_pins hbm_0/apb_complete_1] \
+  [get_bd_ports apb_complete_1]
   connect_bd_net -net proc_sys_reset_0_peripheral_aresetn  [get_bd_pins proc_sys_reset_0/peripheral_aresetn] \
   [get_bd_pins hbm_0/APB_0_PRESET_N] \
   [get_bd_pins hbm_0/APB_1_PRESET_N]
-  connect_bd_net -net axi_aresetn_0  [get_bd_ports axi_resetn] \
-  [get_bd_pins hbm_0/AXI_15_ARESET_N] \
-  [get_bd_pins smartconnect_0/aresetn] \
-  [get_bd_pins clk_wiz_0/resetn] \
-  [get_bd_pins proc_sys_reset_0/ext_reset_in]
 
   # Create address segments
-  assign_bd_address -offset 0x00000000 -range 0x10000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM00] -force
+  assign_bd_address -offset 0x00000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces axi_datamover_0/Data] [get_bd_addr_segs hbm_0/SAXI_16_8HI/HBM_MEM00] -force
+  assign_bd_address -offset 0x20000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces axi_datamover_0/Data] [get_bd_addr_segs hbm_0/SAXI_16_8HI/HBM_MEM01] -force
+  assign_bd_address -offset 0x40000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces axi_datamover_0/Data] [get_bd_addr_segs hbm_0/SAXI_16_8HI/HBM_MEM02] -force
+  assign_bd_address -offset 0x60000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces axi_datamover_0/Data] [get_bd_addr_segs hbm_0/SAXI_16_8HI/HBM_MEM03] -force
+  assign_bd_address -offset 0x80000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces axi_datamover_0/Data] [get_bd_addr_segs hbm_0/SAXI_16_8HI/HBM_MEM04] -force
+  assign_bd_address -offset 0xA0000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces axi_datamover_0/Data] [get_bd_addr_segs hbm_0/SAXI_16_8HI/HBM_MEM05] -force
+  assign_bd_address -offset 0xC0000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces axi_datamover_0/Data] [get_bd_addr_segs hbm_0/SAXI_16_8HI/HBM_MEM06] -force
+  assign_bd_address -offset 0xE0000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces axi_datamover_0/Data] [get_bd_addr_segs hbm_0/SAXI_16_8HI/HBM_MEM07] -force
+  assign_bd_address -offset 0x000100000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces axi_datamover_0/Data] [get_bd_addr_segs hbm_0/SAXI_16_8HI/HBM_MEM08] -force
+  assign_bd_address -offset 0x000120000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces axi_datamover_0/Data] [get_bd_addr_segs hbm_0/SAXI_16_8HI/HBM_MEM09] -force
+  assign_bd_address -offset 0x000140000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces axi_datamover_0/Data] [get_bd_addr_segs hbm_0/SAXI_16_8HI/HBM_MEM10] -force
+  assign_bd_address -offset 0x000160000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces axi_datamover_0/Data] [get_bd_addr_segs hbm_0/SAXI_16_8HI/HBM_MEM11] -force
+  assign_bd_address -offset 0x000180000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces axi_datamover_0/Data] [get_bd_addr_segs hbm_0/SAXI_16_8HI/HBM_MEM12] -force
+  assign_bd_address -offset 0x0001A0000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces axi_datamover_0/Data] [get_bd_addr_segs hbm_0/SAXI_16_8HI/HBM_MEM13] -force
+  assign_bd_address -offset 0x0001C0000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces axi_datamover_0/Data] [get_bd_addr_segs hbm_0/SAXI_16_8HI/HBM_MEM14] -force
+  assign_bd_address -offset 0x0001E0000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces axi_datamover_0/Data] [get_bd_addr_segs hbm_0/SAXI_16_8HI/HBM_MEM15] -force
+  assign_bd_address -offset 0x000200000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces axi_datamover_0/Data] [get_bd_addr_segs hbm_0/SAXI_16_8HI/HBM_MEM16] -force
+  assign_bd_address -offset 0x000220000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces axi_datamover_0/Data] [get_bd_addr_segs hbm_0/SAXI_16_8HI/HBM_MEM17] -force
+  assign_bd_address -offset 0x000240000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces axi_datamover_0/Data] [get_bd_addr_segs hbm_0/SAXI_16_8HI/HBM_MEM18] -force
+  assign_bd_address -offset 0x000260000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces axi_datamover_0/Data] [get_bd_addr_segs hbm_0/SAXI_16_8HI/HBM_MEM19] -force
+  assign_bd_address -offset 0x000280000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces axi_datamover_0/Data] [get_bd_addr_segs hbm_0/SAXI_16_8HI/HBM_MEM20] -force
+  assign_bd_address -offset 0x0002A0000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces axi_datamover_0/Data] [get_bd_addr_segs hbm_0/SAXI_16_8HI/HBM_MEM21] -force
+  assign_bd_address -offset 0x0002C0000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces axi_datamover_0/Data] [get_bd_addr_segs hbm_0/SAXI_16_8HI/HBM_MEM22] -force
+  assign_bd_address -offset 0x0002E0000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces axi_datamover_0/Data] [get_bd_addr_segs hbm_0/SAXI_16_8HI/HBM_MEM23] -force
+  assign_bd_address -offset 0x000300000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces axi_datamover_0/Data] [get_bd_addr_segs hbm_0/SAXI_16_8HI/HBM_MEM24] -force
+  assign_bd_address -offset 0x000320000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces axi_datamover_0/Data] [get_bd_addr_segs hbm_0/SAXI_16_8HI/HBM_MEM25] -force
+  assign_bd_address -offset 0x000340000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces axi_datamover_0/Data] [get_bd_addr_segs hbm_0/SAXI_16_8HI/HBM_MEM26] -force
+  assign_bd_address -offset 0x000360000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces axi_datamover_0/Data] [get_bd_addr_segs hbm_0/SAXI_16_8HI/HBM_MEM27] -force
+  assign_bd_address -offset 0x000380000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces axi_datamover_0/Data] [get_bd_addr_segs hbm_0/SAXI_16_8HI/HBM_MEM28] -force
+  assign_bd_address -offset 0x0003A0000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces axi_datamover_0/Data] [get_bd_addr_segs hbm_0/SAXI_16_8HI/HBM_MEM29] -force
+  assign_bd_address -offset 0x0003C0000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces axi_datamover_0/Data] [get_bd_addr_segs hbm_0/SAXI_16_8HI/HBM_MEM30] -force
+  assign_bd_address -offset 0x0003E0000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces axi_datamover_0/Data] [get_bd_addr_segs hbm_0/SAXI_16_8HI/HBM_MEM31] -force
+  assign_bd_address -offset 0x00000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM00] -force
   assign_bd_address -offset 0x20000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM01] -force
-  assign_bd_address -offset 0x40000000 -range 0x10000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM02] -force
-  assign_bd_address -offset 0x60000000 -range 0x10000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM03] -force
-  assign_bd_address -offset 0x80000000 -range 0x10000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM04] -force
-  assign_bd_address -offset 0xA0000000 -range 0x10000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM05] -force
-  assign_bd_address -offset 0xC0000000 -range 0x10000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM06] -force
-  assign_bd_address -offset 0xE0000000 -range 0x10000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM07] -force
-  assign_bd_address -offset 0x000100000000 -range 0x10000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM08] -force
-  assign_bd_address -offset 0x000120000000 -range 0x10000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM09] -force
-  assign_bd_address -offset 0x000140000000 -range 0x10000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM10] -force
-  assign_bd_address -offset 0x000160000000 -range 0x10000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM11] -force
-  assign_bd_address -offset 0x000180000000 -range 0x10000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM12] -force
-  assign_bd_address -offset 0x0001A0000000 -range 0x10000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM13] -force
-  assign_bd_address -offset 0x0001C0000000 -range 0x10000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM14] -force
-  assign_bd_address -offset 0x0001E0000000 -range 0x10000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM15] -force
-  assign_bd_address -offset 0x000200000000 -range 0x10000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM16] -force
-  assign_bd_address -offset 0x000220000000 -range 0x10000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM17] -force
-  assign_bd_address -offset 0x000240000000 -range 0x10000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM18] -force
-  assign_bd_address -offset 0x000260000000 -range 0x10000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM19] -force
-  assign_bd_address -offset 0x000280000000 -range 0x10000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM20] -force
-  assign_bd_address -offset 0x0002A0000000 -range 0x10000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM21] -force
-  assign_bd_address -offset 0x0002C0000000 -range 0x10000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM22] -force
-  assign_bd_address -offset 0x0002E0000000 -range 0x10000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM23] -force
-  assign_bd_address -offset 0x000300000000 -range 0x10000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM24] -force
-  assign_bd_address -offset 0x000320000000 -range 0x10000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM25] -force
-  assign_bd_address -offset 0x000340000000 -range 0x10000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM26] -force
-  assign_bd_address -offset 0x000360000000 -range 0x10000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM27] -force
-  assign_bd_address -offset 0x000380000000 -range 0x10000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM28] -force
-  assign_bd_address -offset 0x0003A0000000 -range 0x10000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM29] -force
-  assign_bd_address -offset 0x0003C0000000 -range 0x10000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM30] -force
-  assign_bd_address -offset 0x0003E0000000 -range 0x10000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM31] -force
+  assign_bd_address -offset 0x40000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM02] -force
+  assign_bd_address -offset 0x60000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM03] -force
+  assign_bd_address -offset 0x80000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM04] -force
+  assign_bd_address -offset 0xA0000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM05] -force
+  assign_bd_address -offset 0xC0000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM06] -force
+  assign_bd_address -offset 0xE0000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM07] -force
+  assign_bd_address -offset 0x000100000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM08] -force
+  assign_bd_address -offset 0x000120000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM09] -force
+  assign_bd_address -offset 0x000140000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM10] -force
+  assign_bd_address -offset 0x000160000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM11] -force
+  assign_bd_address -offset 0x000180000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM12] -force
+  assign_bd_address -offset 0x0001A0000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM13] -force
+  assign_bd_address -offset 0x0001C0000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM14] -force
+  assign_bd_address -offset 0x0001E0000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM15] -force
+  assign_bd_address -offset 0x000200000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM16] -force
+  assign_bd_address -offset 0x000220000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM17] -force
+  assign_bd_address -offset 0x000240000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM18] -force
+  assign_bd_address -offset 0x000260000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM19] -force
+  assign_bd_address -offset 0x000280000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM20] -force
+  assign_bd_address -offset 0x0002A0000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM21] -force
+  assign_bd_address -offset 0x0002C0000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM22] -force
+  assign_bd_address -offset 0x0002E0000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM23] -force
+  assign_bd_address -offset 0x000300000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM24] -force
+  assign_bd_address -offset 0x000320000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM25] -force
+  assign_bd_address -offset 0x000340000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM26] -force
+  assign_bd_address -offset 0x000360000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM27] -force
+  assign_bd_address -offset 0x000380000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM28] -force
+  assign_bd_address -offset 0x0003A0000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM29] -force
+  assign_bd_address -offset 0x0003C0000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM30] -force
+  assign_bd_address -offset 0x0003E0000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM31] -force
 
 
   # Restore current instance
diff --git a/src/hbm_subsystem/hbm_subsystem.sv b/src/hbm_subsystem/hbm_subsystem.sv
index 4571b97..fdcf31b 100644
--- a/src/hbm_subsystem/hbm_subsystem.sv
+++ b/src/hbm_subsystem/hbm_subsystem.sv
@@ -1,4 +1,8 @@
-module hbm_subsystem (
+module hbm_subsystem #(
+  parameter logic [31:0] IP_ADDRESS     = 32'hC0643301,
+  parameter logic [47:0] MAC_ADDRESS    = 48'h020A35070000,
+  parameter              METADATA_WIDTH = 161
+) (
   input   [63:0] s_axi_araddr,
   input    [1:0] s_axi_arburst,
   input    [3:0] s_axi_arcache,
@@ -40,11 +44,84 @@ module hbm_subsystem (
   input   [63:0] s_axi_wuser,
   input          s_axi_wvalid,
 
+  input          s_axis_qdma_h2c_tvalid,
+  input  [511:0] s_axis_qdma_h2c_tdata,
+  input   [63:0] s_axis_qdma_h2c_tkeep,
+  input          s_axis_qdma_h2c_tlast,
+  input   [15:0] s_axis_qdma_h2c_tuser_size,
+  input   [15:0] s_axis_qdma_h2c_tuser_src,
+  input   [15:0] s_axis_qdma_h2c_tuser_dst,
+  output         s_axis_qdma_h2c_tready,
+
+  output         m_axis_qdma_c2h_tvalid,
+  output [511:0] m_axis_qdma_c2h_tdata,
+  output  [63:0] m_axis_qdma_c2h_tkeep,
+  output         m_axis_qdma_c2h_tlast,
+  output  [15:0] m_axis_qdma_c2h_tuser_size,
+  output  [15:0] m_axis_qdma_c2h_tuser_src,
+  output  [15:0] m_axis_qdma_c2h_tuser_dst,
+  input          m_axis_qdma_c2h_tready,
+
+  output         m_axis_cmac_h2c_tvalid,
+  output [511:0] m_axis_cmac_h2c_tdata,
+  output  [63:0] m_axis_cmac_h2c_tkeep,
+  output         m_axis_cmac_h2c_tlast,
+  output  [15:0] m_axis_cmac_h2c_tuser_size,
+  output  [15:0] m_axis_cmac_h2c_tuser_src,
+  output  [15:0] m_axis_cmac_h2c_tuser_dst,
+  input          m_axis_cmac_h2c_tready,
+
+  input          s_axis_cmac_c2h_tvalid,
+  input  [511:0] s_axis_cmac_c2h_tdata,
+  input   [63:0] s_axis_cmac_c2h_tkeep,
+  input          s_axis_cmac_c2h_tlast,
+  input   [15:0] s_axis_cmac_c2h_tuser_size,
+  input   [15:0] s_axis_cmac_c2h_tuser_src,
+  input   [15:0] s_axis_cmac_c2h_tuser_dst,
+  output         s_axis_cmac_c2h_tready,
+
   input          axi_clk,
-  input          axi_resetn,
+  input          axi_rstn,
   input          hbm_ref_clk
 );
-  
+
+  localparam FIFO_DEPTH = 64;
+
+  logic         axis_dm_write_tvalid;
+  logic [511:0] axis_dm_write_tdata;
+  logic  [63:0] axis_dm_write_tkeep;
+  logic         axis_dm_write_tlast;
+  logic         axis_dm_write_tready;
+
+  logic         axis_dm_read_tvalid;
+  logic [511:0] axis_dm_read_tdata;
+  logic  [63:0] axis_dm_read_tkeep;
+  logic         axis_dm_read_tlast;
+  logic         axis_dm_read_tready;
+
+  logic         axis_dm_write_cmd_tvalid;
+  logic  [79:0] axis_dm_write_cmd_tdata;
+  logic         axis_dm_write_cmd_tready;
+
+  logic         axis_dm_read_cmd_tvalid;
+  logic  [79:0] axis_dm_read_cmd_tdata;
+  logic         axis_dm_read_cmd_tready;
+
+  logic   [7:0] axis_write_sts_tdata;
+  logic         axis_write_sts_tkeep;
+  logic         axis_write_sts_tlast;
+  logic         axis_write_sts_tvalid;
+  logic         axis_write_sts_tready;
+
+  logic   [7:0] axis_read_sts_tdata;
+  logic         axis_read_sts_tkeep;
+  logic         axis_read_sts_tlast;
+  logic         axis_read_sts_tvalid;
+  logic         axis_read_sts_tready;
+
+  logic apb_complete_0;
+  logic apb_complete_1;
+
   hbm_bd_wrapper hbm_inst (
     .s_axi_hbm_araddr                (s_axi_araddr),
     .s_axi_hbm_arburst               (s_axi_arburst),
@@ -87,8 +164,402 @@ module hbm_subsystem (
     .s_axi_hbm_wuser                 (s_axi_wuser),
     .s_axi_hbm_wvalid                (s_axi_wvalid),
 
+    .s_axis_dm_s2mm_tvalid           (axis_dm_write_tvalid),
+    .s_axis_dm_s2mm_tdata            (axis_dm_write_tdata),
+    .s_axis_dm_s2mm_tkeep            (axis_dm_write_tkeep),
+    .s_axis_dm_s2mm_tlast            (axis_dm_write_tlast),
+    .s_axis_dm_s2mm_tready           (axis_dm_write_tready),
+
+    .m_axis_dm_mm2s_tvalid           (axis_dm_read_tvalid),
+    .m_axis_dm_mm2s_tdata            (axis_dm_read_tdata),
+    .m_axis_dm_mm2s_tkeep            (axis_dm_read_tkeep),
+    .m_axis_dm_mm2s_tlast            (axis_dm_read_tlast),
+    .m_axis_dm_mm2s_tready           (axis_dm_read_tready),
+
+    .s_axis_dm_s2mm_cmd_tvalid       (axis_dm_write_cmd_tvalid),
+    .s_axis_dm_s2mm_cmd_tdata        (axis_dm_write_cmd_tdata),
+    .s_axis_dm_s2mm_cmd_tready       (axis_dm_write_cmd_tready),
+
+    .s_axis_dm_mm2s_cmd_tvalid       (axis_dm_read_cmd_tvalid),
+    .s_axis_dm_mm2s_cmd_tdata        (axis_dm_read_cmd_tdata),
+    .s_axis_dm_mm2s_cmd_tready       (axis_dm_read_cmd_tready),
+
+    .m_axis_dm_s2mm_status_tdata     (axis_write_sts_tdata),
+    .m_axis_dm_s2mm_status_tkeep     (axis_write_sts_tkeep),
+    .m_axis_dm_s2mm_status_tlast     (axis_write_sts_tlast),
+    .m_axis_dm_s2mm_status_tvalid    (axis_write_sts_tvalid),
+    .m_axis_dm_s2mm_status_tready    (axis_write_sts_tready),
+
+    .m_axis_dm_mm2s_status_tdata     (axis_read_sts_tdata),
+    .m_axis_dm_mm2s_status_tkeep     (axis_read_sts_tkeep),
+    .m_axis_dm_mm2s_status_tlast     (axis_read_sts_tlast),
+    .m_axis_dm_mm2s_status_tvalid    (axis_read_sts_tvalid),
+    .m_axis_dm_mm2s_status_tready    (axis_read_sts_tready),
+
+    .apb_complete_0                  (apb_complete_0),
+    .apb_complete_1                  (apb_complete_1),
     .axi_clk                         (axi_clk),
-    .axi_resetn                      (axi_resetn),
+    .axi_resetn                      (axi_rstn),
     .hbm_ref_clk                     (hbm_ref_clk)
   );
-  endmodule
\ No newline at end of file
+
+  logic                      axis_parser_to_filter_tvalid;
+  logic              [511:0] axis_parser_to_filter_tdata;
+  logic               [63:0] axis_parser_to_filter_tkeep;
+  logic                      axis_parser_to_filter_tlast;
+  logic                      axis_parser_to_filter_tready;
+
+  logic                      axis_filter_to_engine_tvalid;
+  logic              [511:0] axis_filter_to_engine_tdata;
+  logic               [63:0] axis_filter_to_engine_tkeep;
+  logic                      axis_filter_to_engine_tlast;
+  logic                      axis_filter_to_engine_tready;
+
+  logic                      axis_engine_to_deparser_tvalid;
+  logic              [511:0] axis_engine_to_deparser_tdata;
+  logic               [63:0] axis_engine_to_deparser_tkeep;
+  logic                      axis_engine_to_deparser_tlast;
+  logic                      axis_engine_to_deparser_tready;
+
+  logic                      axis_deparser_to_arbiter_tvalid;
+  logic              [511:0] axis_deparser_to_arbiter_tdata;
+  logic               [63:0] axis_deparser_to_arbiter_tkeep;
+  logic                      axis_deparser_to_arbiter_tlast;
+  logic                      axis_deparser_to_arbiter_tready;
+
+  logic                      axis_engine_to_memory_tvalid;
+  logic              [511:0] axis_engine_to_memory_tdata;
+  logic               [63:0] axis_engine_to_memory_tkeep;
+  logic                      axis_engine_to_memory_tlast;
+  logic                      axis_engine_to_memory_tready;
+
+  logic                      axis_memory_to_engine_tvalid;
+  logic              [511:0] axis_memory_to_engine_tdata;
+  logic               [63:0] axis_memory_to_engine_tkeep;
+  logic                      axis_memory_to_engine_tlast;
+  logic                      axis_memory_to_engine_tready;
+
+  logic                      cmac_tuser_write_en;
+  logic                      cmac_tuser_read_en;
+  logic               [47:0] cmac_tuser_out;
+  logic                      cmac_tuser_empty;
+  logic                      cmac_tuser_write_en_toggle;
+
+  logic [METADATA_WIDTH-2:0] mem_metadata_in;
+  logic                      mem_metadata_in_valid;
+
+  logic [METADATA_WIDTH-2:0] mem_metadata_out;
+  logic                      mem_metadata_out_valid;
+
+  logic [METADATA_WIDTH-2:0] engine_metadata_out;
+  logic                      engine_metadata_out_valid;
+
+  logic [METADATA_WIDTH-1:0] parser_metadata_in;
+  logic                      parser_metadata_in_valid;
+
+  logic [METADATA_WIDTH-1:0] parser_metadata_out;
+  logic                      parser_metadata_out_valid;
+
+  // Buffer the switch for the packet filter
+  logic is_replication;
+  logic is_replication_buf;
+
+  always @(posedge axi_clk) begin
+    if(~axi_rstn)
+    begin
+      is_replication_buf <= 1'b0;
+    end
+    else begin
+      if (parser_metadata_out_valid) 
+        is_replication_buf <= parser_metadata_out[0];
+      else
+        is_replication_buf <= is_replication_buf;
+    end
+  end
+
+  assign is_replication = parser_metadata_out_valid ? parser_metadata_out[0] : is_replication_buf;
+
+  replication_engine replication_engine_inst (
+    .s_axis_tvalid          (axis_filter_to_engine_tvalid),
+    .s_axis_tdata           (axis_filter_to_engine_tdata),
+    .s_axis_tkeep           (axis_filter_to_engine_tkeep),
+    .s_axis_tlast           (axis_filter_to_engine_tlast),
+    .s_axis_tready          (axis_filter_to_engine_tready),
+    .metadata_in            (parser_metadata_out[METADATA_WIDTH-1:1]),
+    .metadata_in_valid      (parser_metadata_out_valid && is_replication),
+
+    .m_axis_tvalid          (axis_engine_to_deparser_tvalid),
+    .m_axis_tdata           (axis_engine_to_deparser_tdata),
+    .m_axis_tkeep           (axis_engine_to_deparser_tkeep),
+    .m_axis_tlast           (axis_engine_to_deparser_tlast),
+    .m_axis_tready          (axis_engine_to_deparser_tready),
+    .metadata_out           (engine_metadata_out),
+    .metadata_out_valid     (engine_metadata_out_valid),
+
+    .s_axis_mem_tvalid      (axis_memory_to_engine_tvalid),
+    .s_axis_mem_tdata       (axis_memory_to_engine_tdata),
+    .s_axis_mem_tkeep       (axis_memory_to_engine_tkeep),
+    .s_axis_mem_tlast       (axis_memory_to_engine_tlast),
+    .s_axis_mem_tready      (axis_memory_to_engine_tready),
+    .metadata_mem_in        (mem_metadata_in),
+    .metadata_mem_in_valid  (mem_metadata_in_valid),
+
+    .m_axis_mem_tvalid      (axis_engine_to_memory_tvalid),
+    .m_axis_mem_tdata       (axis_engine_to_memory_tdata),
+    .m_axis_mem_tkeep       (axis_engine_to_memory_tkeep),
+    .m_axis_mem_tlast       (axis_engine_to_memory_tlast),
+    .m_axis_mem_tready      (axis_engine_to_memory_tready),
+    .metadata_mem_out       (mem_metadata_out),
+    .metadata_mem_out_valid (mem_metadata_out_valid),
+
+    .axis_clk               (axi_clk),
+    .axis_rstn              (axi_rstn)
+  );
+
+  memory_controller memory_controller_inst (
+    .s_axis_tready            (axis_engine_to_memory_tready),
+    .s_axis_tdata             (axis_engine_to_memory_tdata),
+    .s_axis_tkeep             (axis_engine_to_memory_tkeep),
+    .s_axis_tlast             (axis_engine_to_memory_tlast),
+    .s_axis_tvalid            (axis_engine_to_memory_tvalid),
+    .metadata_mem_in          (mem_metadata_out),
+    .metadata_mem_in_valid    (mem_metadata_out_valid),
+
+    .m_axis_tready            (axis_memory_to_engine_tready),
+    .m_axis_tdata             (axis_memory_to_engine_tdata),
+    .m_axis_tkeep             (axis_memory_to_engine_tkeep),
+    .m_axis_tlast             (axis_memory_to_engine_tlast),
+    .m_axis_tvalid            (axis_memory_to_engine_tvalid),
+    .metadata_mem_out         (mem_metadata_in),
+    .metadata_mem_out_valid   (mem_metadata_in_valid),
+
+    .s_dm_axis_tvalid         (axis_dm_read_tvalid),
+    .s_dm_axis_tdata          (axis_dm_read_tdata),
+    .s_dm_axis_tkeep          (axis_dm_read_tkeep),
+    .s_dm_axis_tlast          (axis_dm_read_tlast),
+    .s_dm_axis_tready         (axis_dm_read_tready),
+
+    .m_dm_axis_tvalid         (axis_dm_write_tvalid),
+    .m_dm_axis_tdata          (axis_dm_write_tdata),
+    .m_dm_axis_tkeep          (axis_dm_write_tkeep),
+    .m_dm_axis_tlast          (axis_dm_write_tlast),
+    .m_dm_axis_tready         (axis_dm_write_tready),
+
+    .mm2s_cmd_tvalid          (axis_dm_read_cmd_tvalid),
+    .mm2s_cmd_tdata           (axis_dm_read_cmd_tdata),
+    .mm2s_cmd_tready          (axis_dm_read_cmd_tready),
+
+    .s2mm_cmd_tvalid          (axis_dm_write_cmd_tvalid),
+    .s2mm_cmd_tdata           (axis_dm_write_cmd_tdata),
+    .s2mm_cmd_tready          (axis_dm_write_cmd_tready),
+
+    .s_axis_mm2s_sts_tdata    (axis_read_sts_tdata),
+    .s_axis_mm2s_sts_tkeep    (axis_read_sts_tkeep),
+    .s_axis_mm2s_sts_tlast    (axis_read_sts_tlast),
+    .s_axis_mm2s_sts_tvalid   (axis_read_sts_tvalid),
+    .s_axis_mm2s_sts_tready   (axis_read_sts_tready),
+
+    .s_axis_s2mm_sts_tdata    (axis_write_sts_tdata),
+    .s_axis_s2mm_sts_tkeep    (axis_write_sts_tkeep),
+    .s_axis_s2mm_sts_tlast    (axis_write_sts_tlast),
+    .s_axis_s2mm_sts_tvalid   (axis_write_sts_tvalid),
+    .s_axis_s2mm_sts_tready   (axis_write_sts_tready),
+
+    .abp_complete0            (apb_complete_0),
+    .aclk                     (axi_clk),
+    .aresetn                  (axi_rstn)
+  );
+
+  logic vitis_net_p4_resetn;
+  assign vitis_net_p4_resetn = axi_rstn && apb_complete_0;
+
+  packet_parser packet_parser_inst (
+    .s_axis_tvalid           (s_axis_cmac_c2h_tvalid), 
+    .s_axis_tdata            (s_axis_cmac_c2h_tdata), 
+    .s_axis_tkeep            (s_axis_cmac_c2h_tkeep), 
+    .s_axis_tlast            (s_axis_cmac_c2h_tlast), 
+    .s_axis_tready           (s_axis_cmac_c2h_tready), 
+    .user_metadata_in        (parser_metadata_in),
+    .user_metadata_in_valid  (parser_metadata_in_valid),
+
+    .m_axis_tvalid           (axis_parser_to_filter_tvalid), 
+    .m_axis_tdata            (axis_parser_to_filter_tdata), 
+    .m_axis_tkeep            (axis_parser_to_filter_tkeep), 
+    .m_axis_tlast            (axis_parser_to_filter_tlast), 
+    .m_axis_tready           (axis_parser_to_filter_tready), 
+    .user_metadata_out       (parser_metadata_out),
+    .user_metadata_out_valid (parser_metadata_out_valid),
+
+    .s_axis_aclk             (axi_clk),
+    .s_axis_aresetn          (vitis_net_p4_resetn)
+  );
+
+  logic metadata_valid_in_toggle;
+
+  // Control the parser's metadata valid in signal
+  always @(posedge axi_clk) begin
+    if(~axi_rstn)
+    begin
+      metadata_valid_in_toggle <= 1'b1;
+    end
+    else begin
+      if (s_axis_cmac_c2h_tvalid && s_axis_cmac_c2h_tready && !s_axis_cmac_c2h_tlast) 
+        metadata_valid_in_toggle <= 1'b0;  
+      if (s_axis_cmac_c2h_tvalid && s_axis_cmac_c2h_tready && s_axis_cmac_c2h_tlast)
+        metadata_valid_in_toggle <= 1'b1;
+    end
+  end
+
+  assign parser_metadata_in       = '0;
+  assign parser_metadata_in_valid = metadata_valid_in_toggle && s_axis_cmac_c2h_tvalid && s_axis_cmac_c2h_tready;
+
+  packet_deparser packet_deparser_inst (
+    .s_axis_tvalid           (axis_engine_to_deparser_tvalid), 
+    .s_axis_tdata            (axis_engine_to_deparser_tdata), 
+    .s_axis_tkeep            (axis_engine_to_deparser_tkeep), 
+    .s_axis_tlast            (axis_engine_to_deparser_tlast), 
+    .s_axis_tready           (axis_engine_to_deparser_tready), 
+    .user_metadata_in        ({engine_metadata_out, IP_ADDRESS, MAC_ADDRESS}),
+    .user_metadata_in_valid  (engine_metadata_out_valid),
+
+    .m_axis_tvalid           (axis_deparser_to_arbiter_tvalid), 
+    .m_axis_tdata            (axis_deparser_to_arbiter_tdata), 
+    .m_axis_tkeep            (axis_deparser_to_arbiter_tkeep), 
+    .m_axis_tlast            (axis_deparser_to_arbiter_tlast), 
+    .m_axis_tready           (axis_deparser_to_arbiter_tready), 
+    .user_metadata_out       (),
+    .user_metadata_out_valid (),
+
+    .s_axis_aclk             (axi_clk),
+    .s_axis_aresetn          (vitis_net_p4_resetn)
+  );
+
+  logic    [1:0] axis_filter_out_tvalid;
+  logic [1023:0] axis_filter_out_tdata;
+  logic  [127:0] axis_filter_out_tkeep;
+  logic    [1:0] axis_filter_out_tlast;
+  logic    [1:0] axis_filter_out_tdest;
+  logic   [95:0] axis_filter_out_tuser;
+  logic    [1:0] axis_filter_out_tready;
+
+  packet_filter packet_filter_inst (
+    .s_axis_tvalid           (axis_parser_to_filter_tvalid), 
+    .s_axis_tdata            (axis_parser_to_filter_tdata),
+    .s_axis_tkeep            (axis_parser_to_filter_tkeep),
+    .s_axis_tlast            (axis_parser_to_filter_tlast),
+    .s_axis_tuser            (cmac_tuser_out),
+    .s_axis_tdest            (is_replication),
+    .s_axis_tready           (axis_parser_to_filter_tready),
+
+    .m_axis_tvalid           (axis_filter_out_tvalid),
+    .m_axis_tdata            (axis_filter_out_tdata),
+    .m_axis_tkeep            (axis_filter_out_tkeep),
+    .m_axis_tlast            (axis_filter_out_tlast),
+    .m_axis_tuser            (axis_filter_out_tuser),
+    .m_axis_tdest            (),
+    .m_axis_tready           (axis_filter_out_tready),
+
+    .aclk                    (axi_clk),
+    .aresetn                 (axi_rstn)
+  );
+
+  // Split the filter output between the QDMA and replication engine
+  assign m_axis_qdma_c2h_tvalid       = axis_filter_out_tvalid[0];
+  assign m_axis_qdma_c2h_tdata        = axis_filter_out_tdata[511:0];
+  assign m_axis_qdma_c2h_tkeep        = axis_filter_out_tkeep[63:0];
+  assign m_axis_qdma_c2h_tlast        = axis_filter_out_tlast[0];
+  assign m_axis_qdma_c2h_tuser_size   = axis_filter_out_tuser[47-:16];
+  assign m_axis_qdma_c2h_tuser_src    = axis_filter_out_tuser[31-:16];
+  assign m_axis_qdma_c2h_tuser_dst    = axis_filter_out_tuser[15-:16];
+  assign axis_filter_out_tready[0]    = m_axis_qdma_c2h_tready;
+
+  assign axis_filter_to_engine_tvalid = axis_filter_out_tvalid[1];
+  assign axis_filter_to_engine_tdata  = axis_filter_out_tdata[1023-:512];
+  assign axis_filter_to_engine_tkeep  = axis_filter_out_tkeep[127-:64];
+  assign axis_filter_to_engine_tlast  = axis_filter_out_tlast[1];
+  assign axis_filter_out_tready[1]    = axis_filter_to_engine_tready;
+
+  logic [47:0] replication_tuser;
+  logic [47:0] cmac_tuser;
+  assign  replication_tuser          = {16'h0, 16'h0, 16'h0040};
+  assign  m_axis_cmac_h2c_tuser_size = cmac_tuser[47-:16];
+  assign  m_axis_cmac_h2c_tuser_src  = cmac_tuser[31-:16];
+  assign  m_axis_cmac_h2c_tuser_dst  = cmac_tuser[15-:16];
+
+  packet_arbiter packet_arbiter_inst (
+    .s_axis_tvalid           ({axis_deparser_to_arbiter_tvalid, s_axis_qdma_h2c_tvalid}), 
+    .s_axis_tdata            ({axis_deparser_to_arbiter_tdata, s_axis_qdma_h2c_tdata}),
+    .s_axis_tkeep            ({axis_deparser_to_arbiter_tkeep, s_axis_qdma_h2c_tkeep}),
+    .s_axis_tlast            ({axis_deparser_to_arbiter_tlast, s_axis_qdma_h2c_tlast}),
+    .s_axis_tuser            ({replication_tuser, {s_axis_qdma_h2c_tuser_size, s_axis_qdma_h2c_tuser_src, s_axis_qdma_h2c_tuser_dst}}),
+    .s_axis_tready           ({axis_deparser_to_arbiter_tready, s_axis_qdma_h2c_tready}),
+
+    .m_axis_tvalid           (m_axis_cmac_h2c_tvalid),
+    .m_axis_tdata            (m_axis_cmac_h2c_tdata),
+    .m_axis_tkeep            (m_axis_cmac_h2c_tkeep),
+    .m_axis_tlast            (m_axis_cmac_h2c_tlast),
+    .m_axis_tuser            (cmac_tuser),
+    .m_axis_tready           (m_axis_cmac_h2c_tready),
+
+    .s_req_suppress          (2'b0),
+    .aclk                    (axi_clk),
+    .aresetn                 (axi_rstn)
+  );
+
+  // FIFO to buffer input tuser data from CMAC
+  xpm_fifo_sync #(
+    .DOUT_RESET_VALUE    ("0"),
+    .ECC_MODE            ("no_ecc"),
+    .FIFO_MEMORY_TYPE    ("auto"),
+    .FIFO_READ_LATENCY   (1),
+    .FIFO_WRITE_DEPTH    (FIFO_DEPTH),
+    .PROG_FULL_THRESH    (FIFO_DEPTH-5),
+    .READ_DATA_WIDTH     (48),
+    .READ_MODE           ("fwft"),
+    .WRITE_DATA_WIDTH    (48)
+  ) metadata_fifo (
+    .wr_en               (cmac_tuser_write_en),
+    .din                 ({s_axis_cmac_c2h_tuser_size, s_axis_cmac_c2h_tuser_src, s_axis_cmac_c2h_tuser_dst}),
+    .wr_ack              (),
+    .rd_en               (cmac_tuser_read_en),
+    .data_valid          (),
+    .dout                (cmac_tuser_out),
+    .wr_data_count       (),
+    .rd_data_count       (),
+    .empty               (cmac_tuser_empty),
+    .full                (),
+    .almost_empty        (),
+    .almost_full         (),
+    .overflow            (),
+    .underflow           (),
+    .prog_empty          (),
+    .prog_full           (),
+    .sleep               (1'b0),
+    .sbiterr             (),
+    .dbiterr             (),
+    .injectsbiterr       (1'b0),
+    .injectdbiterr       (1'b0),
+    .wr_clk              (axi_clk),
+    .rst                 (~axi_rstn),
+    .rd_rst_busy         (),
+    .wr_rst_busy         ()
+  );
+
+  // Control the tuser FIFO signals
+  always @(posedge axi_clk) begin
+    if(~axi_rstn)
+    begin
+      cmac_tuser_write_en_toggle <= 1'b1;
+    end
+    else begin
+      if (cmac_tuser_write_en_toggle && s_axis_cmac_c2h_tvalid && s_axis_cmac_c2h_tready) 
+        cmac_tuser_write_en_toggle <= 1'b0;  
+      if (!cmac_tuser_write_en_toggle && s_axis_cmac_c2h_tvalid && s_axis_cmac_c2h_tready && s_axis_cmac_c2h_tlast)
+        cmac_tuser_write_en_toggle <= 1'b1;
+    end
+  end
+
+  assign cmac_tuser_write_en = cmac_tuser_write_en_toggle && s_axis_cmac_c2h_tvalid && s_axis_cmac_c2h_tready;
+  assign cmac_tuser_read_en  = axis_parser_to_filter_tlast && axis_parser_to_filter_tvalid && axis_parser_to_filter_tready;
+
+endmodule
\ No newline at end of file
diff --git a/src/hbm_subsystem/memory_controller/bvalid_buffer.sv b/src/hbm_subsystem/memory_controller/bvalid_buffer.sv
new file mode 100644
index 0000000..bfa4dc3
--- /dev/null
+++ b/src/hbm_subsystem/memory_controller/bvalid_buffer.sv
@@ -0,0 +1,69 @@
+// typedef struct packed {
+//   logic          [31:0] ip;      // IPv4 address of the sender
+//   logic          [47:0] mac;     // Mac address of the sender
+//   logic           [7:0] id;      // Operation identifier used to distinguish consecutive writes
+//   logic           [7:0] opcode;  // Operation code
+//   logic          [63:0] key;
+// } st_metadata;
+
+module bvalid_buffer #(
+  parameter DEPTH      = 64,
+  parameter PTR_WIDTH  = $clog2(DEPTH)
+)(
+  input  logic         aclk,
+  input  logic         aresetn,
+
+  // Slave side (no ready)
+  input  logic         s_bresp,
+  input  logic         s_bvalid,
+
+  // Master side (with ready)
+  output logic         m_bvalid,
+  output logic         m_bresp,
+  input  logic         m_bready
+
+);
+
+  // Memory Buffers
+  logic mem [DEPTH-1:0];
+
+  // Write & Read pointers
+  logic [PTR_WIDTH-1:0] write_ptr;
+  logic [PTR_WIDTH-1:0] read_ptr;
+
+  // Counter
+  logic [PTR_WIDTH-1:0] count;
+
+always_ff @(posedge aclk or negedge aresetn) begin
+  if (!aresetn) begin
+    write_ptr <= '0;
+    read_ptr  <= '0;
+    count     <= '0;
+  end 
+  else begin
+    // Write
+    if (s_bvalid) begin
+      mem[write_ptr] <= s_bresp;
+      write_ptr      <= write_ptr + 1;
+      if (count < (DEPTH-1))
+        count <= count + 1;
+    end
+
+    // Read
+    if (m_bvalid && m_bready) begin
+      read_ptr <= read_ptr + 1;
+      count    <= count - 1;
+    end
+  end
+end
+
+  logic m_resp;
+  always_comb begin
+  m_resp = 1'b0;
+  end
+
+  assign m_bvalid = (count != 0);
+  assign m_bresp  = m_bready? mem[read_ptr] :m_resp;
+  
+
+endmodule
\ No newline at end of file
diff --git a/src/hbm_subsystem/memory_controller/memory_controller.sv b/src/hbm_subsystem/memory_controller/memory_controller.sv
new file mode 100644
index 0000000..cd4b971
--- /dev/null
+++ b/src/hbm_subsystem/memory_controller/memory_controller.sv
@@ -0,0 +1,940 @@
+`timescale 1ns / 1ps
+//////////////////////////////////////////////////////////////////////////////////
+// Company: 
+// Engineer: 
+// 
+// Create Date: 09/01/2025 10:21:43 AM
+// Design Name: 
+// Module Name: Memory_Controller
+// Project Name: 
+// Target Devices: 
+// Tool Versions: 
+// Description: 
+// 
+// Dependencies: 
+// 
+// Revision: 
+// Revision 0.02 - File Created  
+// Additional Comments: 
+// 
+//////////////////////////////////////////////////////////////////////////////////
+
+
+module memory_controller #(
+    parameter  int BUCKET_SIZE       = 1024,
+    parameter  int CMD_WIDTH         = 80,
+    parameter  int CMD_STATUS_WIDTH  = 8,
+    parameter  int DATA_WIDTH        = 512,
+    parameter  int TKEEP_WIDTH       = DATA_WIDTH/8,
+    parameter  int TUSER_WIDTH       = 16,
+    parameter  int CMD_FIFO_DEPTH    = 32,
+    parameter  int STREAM_FIFO_DEPTH = 64,
+    parameter  int KEY_WIDTH         = 64,
+    localparam int HASH_WIDTH        = 34 - $clog2(BUCKET_SIZE)
+)(
+    
+    // 250Mhz Memory Controller Clock & Reset.
+    input logic                         aclk,
+    input logic                         aresetn,
+    
+    // HBM Stack Interface complete (FSM Starters)
+    input logic                         abp_complete0,
+
+    // Master AXI-Stream signals [To Replication Engine]
+    input  logic                        m_axis_tready,
+    output logic [DATA_WIDTH-1:0]       m_axis_tdata,
+    output logic [TKEEP_WIDTH-1:0]      m_axis_tkeep,
+    output logic                        m_axis_tlast,
+    output logic                        m_axis_tvalid,
+
+    // Master AXI-Stream signals [From DataMover]
+    output logic                        s_dm_axis_tready,
+    input  logic [DATA_WIDTH-1:0]       s_dm_axis_tdata,
+    input  logic [TKEEP_WIDTH-1:0]      s_dm_axis_tkeep,
+    input  logic                        s_dm_axis_tlast,
+    input  logic                        s_dm_axis_tvalid,
+
+    // Slave AXI-Stream signals [From Replication Engine]
+    output logic                        s_axis_tready,
+    input  logic [DATA_WIDTH-1:0]       s_axis_tdata,
+    input  logic [TKEEP_WIDTH-1:0]      s_axis_tkeep,
+    input  logic                        s_axis_tlast,
+    input  logic                        s_axis_tvalid,
+
+    // Slave AXI-Stream signals [To DataMover]
+    input  logic                        m_dm_axis_tready,
+    output logic [DATA_WIDTH-1:0]       m_dm_axis_tdata,
+    output logic [TKEEP_WIDTH-1:0]      m_dm_axis_tkeep,
+    output logic                        m_dm_axis_tlast,
+    output logic                        m_dm_axis_tvalid,
+    
+    // Metadata mem_in
+    input  st_metadata                  metadata_mem_in,
+    input  logic                        metadata_mem_in_valid,
+
+    // Metadata mem_out
+    output st_metadata                  metadata_mem_out,
+    output logic                        metadata_mem_out_valid,
+
+    // MM2S Commands
+    input  logic                        mm2s_cmd_tready,
+    output logic [CMD_WIDTH-1:0]        mm2s_cmd_tdata,
+    output logic                        mm2s_cmd_tvalid,
+
+    // S2MM Commands
+    input  logic                        s2mm_cmd_tready,
+    output logic [CMD_WIDTH-1:0]        s2mm_cmd_tdata,
+    output logic                        s2mm_cmd_tvalid,
+
+    // MM2S Status
+    input  logic [CMD_STATUS_WIDTH-1:0] s_axis_mm2s_sts_tdata,
+    input  logic                        s_axis_mm2s_sts_tkeep,
+    input  logic                        s_axis_mm2s_sts_tlast,
+    input  logic                        s_axis_mm2s_sts_tvalid,
+    output logic                        s_axis_mm2s_sts_tready,
+
+    // S2MM Status
+    input  logic [CMD_STATUS_WIDTH-1:0] s_axis_s2mm_sts_tdata,
+    input  logic                        s_axis_s2mm_sts_tkeep,
+    input  logic                        s_axis_s2mm_sts_tlast,
+    input  logic                        s_axis_s2mm_sts_tvalid,
+    output logic                        s_axis_s2mm_sts_tready
+
+    );
+
+
+    // BTT
+    localparam logic [22:0] BTT = 23'h400;
+
+
+    //////////////////////////////////////////////////////////////////
+    // Hash Mechanism
+    //////////////////////////////////////////////////////////////////
+
+    // Precomputed pseudo-random 34-bit constants
+    localparam logic [HASH_WIDTH-1:0] HASH_MATRIX [KEY_WIDTH-1:0] = '{
+        24'hA3C5D1, 24'hD4F921, 24'h98B337, 24'h345678,
+        24'hEAD00F, 24'hADC0DE, 24'h55AAAA, 24'hACE123,
+        24'hF23456, 24'hBEEF12, 24'h0FFEE0, 24'hBADB07,
+        24'hBCDEF0, 24'hBCDE12, 24'h4679BD, 24'h2468AC,
+        24'hAAAAAA, 24'hBBBBBB, 24'hCCCCCC, 24'h234567,
+        24'h654321, 24'hEDCBA9, 24'hACEACE, 24'hC001D0,
+        24'hEADC0D, 24'hADD00D, 24'h0DEC0D, 24'hDCAFE,
+        24'h3579BF, 24'h468ACE, 24'h579BDF, 24'h68ACED,
+        24'h55AAAA, 24'h66BBBB, 24'h77CCCC, 24'h88DDDD,
+        24'h99EEEE, 24'hAAFFFF, 24'hBBB111, 24'hCCC222,
+        24'hDDD333, 24'hEEE444, 24'hFFF555, 24'h111222,
+        24'h222333, 24'h333444, 24'h444555, 24'h555666,
+        24'h666777, 24'h777888, 24'h888999, 24'h999AAA,
+        24'hAAA111, 24'hBBB222, 24'hCCC333, 24'hDDD444,
+        24'hEEE555, 24'hFFF666, 24'h2345AB, 24'hDC123,
+        24'h4567CD, 24'h6789EF, 24'h89AB12, 24'hBCDEF3
+    };
+
+    //Hash function
+    function automatic logic [HASH_WIDTH-1:0] hash (
+        input logic  [KEY_WIDTH-1:0] key,
+        input logic [HASH_WIDTH-1:0] matrix [KEY_WIDTH-1:0]
+    );
+        logic [HASH_WIDTH-1:0] accumulator = '0;
+        for (int i = 0; i < KEY_WIDTH; i = i + 1)
+            if (key[i])
+                accumulator ^= matrix[i];
+        return accumulator;
+    endfunction
+
+    //////////////////////////////////////////////////////////////////
+    // B VALID Buffers
+    //////////////////////////////////////////////////////////////////
+
+    // Global Bvalid Buffer signals
+    logic         m_bvalid_buff;
+    logic         m_bresp_buff;
+    logic         m_bready_buff;
+
+    bvalid_buffer #(
+        .DEPTH(CMD_FIFO_DEPTH)
+    ) bvalid_in_buffer (
+        .aclk               (aclk),
+        .aresetn            (aresetn),
+
+        .s_bvalid           (s_axis_s2mm_sts_tvalid),
+        .s_bresp            (s_axis_s2mm_sts_tdata[7]),
+
+        .m_bvalid           (m_bvalid_buff),
+        .m_bresp            (m_bresp_buff),
+        .m_bready           (m_bready_buff)
+    );
+
+    //////////////////////////////////////////////////////////////////
+    // Metadata Buffers
+    //////////////////////////////////////////////////////////////////
+
+    // Global Metadata Buffer signals
+    st_metadata metadata_tdata_buff;
+    logic       metadata_tvalid_buff;
+    logic       metadata_tready_buff;
+
+    metadata_buffer #(
+        .DEPTH(CMD_FIFO_DEPTH)
+    ) metadata_in_buffer (
+        .aclk               (aclk),
+        .aresetn            (aresetn),
+
+        .s_valid            (metadata_mem_in_valid),
+        .s_data             (metadata_mem_in),
+
+        .m_valid            (metadata_tvalid_buff),
+        .m_data             (metadata_tdata_buff),
+        .m_ready            (metadata_tready_buff)
+    );
+
+    // Write Metadata Buffer signals
+    st_metadata s2mm_wr_meta_tdata;
+    logic       s2mm_wr_meta_tvalid;
+
+    st_metadata s2mm_rd_meta_tdata;
+    logic       s2mm_rd_meta_tvalid;
+    logic       s2mm_rd_meta_tready;
+
+    metadata_buffer #(
+        .DEPTH(CMD_FIFO_DEPTH/2)
+    ) wr_metadata_buffer (
+        .aclk               (aclk),
+        .aresetn            (aresetn),
+
+        .s_valid            (s2mm_wr_meta_tvalid),
+        .s_data             (s2mm_wr_meta_tdata),
+
+        .m_valid            (s2mm_rd_meta_tvalid),
+        .m_data             (s2mm_rd_meta_tdata),
+        .m_ready            (s2mm_rd_meta_tready)
+    );
+
+    // Read Metadata Buffer signals
+    st_metadata mm2s_wr_meta_tdata;
+    logic       mm2s_wr_meta_tvalid;
+
+    st_metadata mm2s_rd_meta_tdata;
+    logic       mm2s_rd_meta_tvalid;
+    logic       mm2s_rd_meta_tready;
+
+    metadata_buffer #(
+        .DEPTH(CMD_FIFO_DEPTH/2)
+    ) rd_metadata_buffer (
+        .aclk               (aclk),
+        .aresetn            (aresetn),
+
+        .s_valid            (mm2s_wr_meta_tvalid),
+        .s_data             (mm2s_wr_meta_tdata),
+
+        .m_valid            (mm2s_rd_meta_tvalid),
+        .m_data             (mm2s_rd_meta_tdata),
+        .m_ready            (mm2s_rd_meta_tready)
+    );
+
+    //////////////////////////////////////////////////////////////////
+    // AXI-Stream Buffer [Write]
+    //////////////////////////////////////////////////////////////////
+
+    // Stream Buffer signals
+    logic [DATA_WIDTH-1:0]  s_tdata_buff;
+    logic [TKEEP_WIDTH-1:0] s_tkeep_buff;
+    logic                   s_tvalid_buff;
+    logic                   s_tlast_buff;
+    logic                   s_tready_buff;
+
+    // stream_buffer #(
+    //     .DATA_WIDTH (DATA_WIDTH),
+    //     .KEEP_WIDTH (TKEEP_WIDTH),
+    //     .DEPTH      (STREAM_FIFO_DEPTH)
+    // ) s2mm_stream_buffer_inst (
+    //     .aclk               (aclk),
+    //     .aresetn            (aresetn),
+    //     //Slave
+    //     .s_axis_tdata       (s_axis_tdata),
+    //     .s_axis_tkeep       (s_axis_tkeep),
+    //     .s_axis_tvalid      (s_axis_tvalid),
+    //     .s_axis_tlast       (s_axis_tlast),
+    //     .s_axis_tready      (s_axis_tready),
+    //     //Master
+    //     .m_axis_tdata       (s_tdata_buff),
+    //     .m_axis_tkeep       (s_tkeep_buff),
+    //     .m_axis_tvalid      (s_tvalid_buff),
+    //     .m_axis_tlast       (s_tlast_buff),
+    //     .m_axis_tready      (s_tready_buff)
+    // );
+
+    logic s2mm_stream_buffer_full;
+    logic s2mm_stream_buffer_empty;
+
+    assign s_axis_tready = !s2mm_stream_buffer_full;
+    assign s_tvalid_buff = !s2mm_stream_buffer_empty;
+
+    xpm_fifo_sync #(
+        .DOUT_RESET_VALUE    ("0"),
+        .ECC_MODE            ("no_ecc"),
+        .FIFO_MEMORY_TYPE    ("auto"),
+        .FIFO_READ_LATENCY   (1),
+        .FIFO_WRITE_DEPTH    (STREAM_FIFO_DEPTH),
+        .PROG_FULL_THRESH    (STREAM_FIFO_DEPTH-5),
+        .READ_DATA_WIDTH     (DATA_WIDTH + TKEEP_WIDTH + 1),
+        .READ_MODE           ("fwft"),
+        .WRITE_DATA_WIDTH    (DATA_WIDTH + TKEEP_WIDTH + 1)
+    ) s2mm_stream_buffer_inst (
+        .wr_en               (s_axis_tvalid),
+        .din                 ({s_axis_tdata, s_axis_tkeep, s_axis_tlast}),
+        .wr_ack              (),
+        .rd_en               (s_tready_buff),
+        .data_valid          (),
+        .dout                ({s_tdata_buff, s_tkeep_buff, s_tlast_buff}),
+        .wr_data_count       (),
+        .rd_data_count       (),
+        .empty               (s2mm_stream_buffer_empty),
+        .full                (s2mm_stream_buffer_full),
+        .almost_empty        (),
+        .almost_full         (),
+        .overflow            (),
+        .underflow           (),
+        .prog_empty          (),
+        .prog_full           (),
+        .sleep               (1'b0),
+        .sbiterr             (),
+        .dbiterr             (),
+        .injectsbiterr       (1'b0),
+        .injectdbiterr       (1'b0),
+        .wr_clk              (aclk),
+        .rst                 (~aresetn),
+        .rd_rst_busy         (),
+        .wr_rst_busy         ()
+        );
+
+    //////////////////////////////////////////////////////////////////
+    // Synchronization [Write]
+    //////////////////////////////////////////////////////////////////
+
+    // Synchronizer signals
+    logic command_sent;
+    logic stream_sent;
+    logic stream_enable;
+
+    synchronizer #(
+        .N(16)
+    ) synchronizer_inst (
+        .aclk               (aclk),
+        .aresetn            (aresetn),
+
+        .s2mm_cmd_start     (abp_complete0),
+
+        .command_sent       (command_sent),
+        .stream_sent        (stream_sent),
+        .stream_enable      (stream_enable)
+    );
+
+    //////////////////////////////////////////////////////////////////
+    // AXI-Stream Buffer [Write Ack]
+    //////////////////////////////////////////////////////////////////
+
+    // Ack Stream Buffer signals
+    logic [DATA_WIDTH-1:0]  s_ack_tdata_buff;
+    logic [TKEEP_WIDTH-1:0] s_ack_tkeep_buff;
+    logic                   s_ack_tvalid_buff;
+    logic                   s_ack_tlast_buff;
+    logic                   s_ack_tready_buff;
+
+    logic [DATA_WIDTH-1:0]  m_ack_tdata_buff;
+    logic [TKEEP_WIDTH-1:0] m_ack_tkeep_buff;
+    logic                   m_ack_tvalid_buff;
+    logic                   m_ack_tlast_buff;
+    logic                   m_ack_tready_buff;
+
+    // stream_buffer #(
+    //     .DATA_WIDTH (DATA_WIDTH),
+    //     .KEEP_WIDTH (TKEEP_WIDTH),
+    //     .DEPTH      (STREAM_FIFO_DEPTH/2)
+    // ) writeack_stream_buffer_inst (
+    //     .aclk               (aclk),
+    //     .aresetn            (aresetn),
+    //     //Slave
+    //     .s_axis_tdata       (s_ack_tdata_buff),
+    //     .s_axis_tkeep       (s_ack_tkeep_buff),
+    //     .s_axis_tvalid      (s_ack_tvalid_buff),
+    //     .s_axis_tlast       (s_ack_tlast_buff),
+    //     .s_axis_tready      (s_ack_tready_buff),
+    //     //Master
+    //     .m_axis_tdata       (m_ack_tdata_buff),
+    //     .m_axis_tkeep       (m_ack_tkeep_buff),
+    //     .m_axis_tvalid      (m_ack_tvalid_buff),
+    //     .m_axis_tlast       (m_ack_tlast_buff),
+    //     .m_axis_tready      (m_ack_tready_buff)
+    // );
+
+    logic wa_stream_buffer_full;
+    logic wa_stream_buffer_empty;
+
+    assign s_ack_tready_buff = !wa_stream_buffer_full;
+    assign m_ack_tvalid_buff = !wa_stream_buffer_empty;
+
+    xpm_fifo_sync #(
+        .DOUT_RESET_VALUE    ("0"),
+        .ECC_MODE            ("no_ecc"),
+        .FIFO_MEMORY_TYPE    ("auto"),
+        .FIFO_READ_LATENCY   (1),
+        .FIFO_WRITE_DEPTH    (STREAM_FIFO_DEPTH),
+        .PROG_FULL_THRESH    (STREAM_FIFO_DEPTH-5),
+        .READ_DATA_WIDTH     (DATA_WIDTH + TKEEP_WIDTH + 1),
+        .READ_MODE           ("fwft"),
+        .WRITE_DATA_WIDTH    (DATA_WIDTH + TKEEP_WIDTH + 1)
+    ) wa_stream_buffer_inst (
+        .wr_en               (s_ack_tvalid_buff),
+        .din                 ({s_ack_tdata_buff, s_ack_tkeep_buff, s_ack_tlast_buff}),
+        .wr_ack              (),
+        .rd_en               (m_ack_tready_buff),
+        .data_valid          (),
+        .dout                ({m_ack_tdata_buff, m_ack_tkeep_buff, m_ack_tlast_buff}),
+        .wr_data_count       (),
+        .rd_data_count       (),
+        .empty               (wa_stream_buffer_empty),
+        .full                (wa_stream_buffer_full),
+        .almost_empty        (),
+        .almost_full         (),
+        .overflow            (),
+        .underflow           (),
+        .prog_empty          (),
+        .prog_full           (),
+        .sleep               (1'b0),
+        .sbiterr             (),
+        .dbiterr             (),
+        .injectsbiterr       (1'b0),
+        .injectdbiterr       (1'b0),
+        .wr_clk              (aclk),
+        .rst                 (~aresetn),
+        .rd_rst_busy         (),
+        .wr_rst_busy         ()
+    );
+
+    //////////////////////////////////////////////////////////////////
+    // AXI-Stream Buffer [Read]
+    //////////////////////////////////////////////////////////////////
+
+    // Stream Buffer signals
+    logic [DATA_WIDTH-1:0]  m_tdata_buff;
+    logic [TKEEP_WIDTH-1:0] m_tkeep_buff;
+    logic                   m_tvalid_buff;
+    logic                   m_tlast_buff;
+    logic                   m_tready_buff;
+
+    // stream_buffer #(
+    //     .DATA_WIDTH (DATA_WIDTH),
+    //     .KEEP_WIDTH (TKEEP_WIDTH),
+    //     .DEPTH      (STREAM_FIFO_DEPTH*2)
+    // ) mm2s_stream_buffer_inst (
+    //     .aclk             (aclk),
+    //     .aresetn          (aresetn),
+    //     //Slave
+    //     .s_axis_tdata     (s_dm_axis_tdata),
+    //     .s_axis_tkeep     (s_dm_axis_tkeep),
+    //     .s_axis_tvalid    (s_dm_axis_tvalid),
+    //     .s_axis_tlast     (s_dm_axis_tlast),
+    //     .s_axis_tready    (s_dm_axis_tready),
+    //     //Master
+    //     .m_axis_tdata     (m_tdata_buff),
+    //     .m_axis_tkeep     (m_tkeep_buff),
+    //     .m_axis_tvalid    (m_tvalid_buff),
+    //     .m_axis_tlast     (m_tlast_buff),
+    //     .m_axis_tready    (m_tready_buff)
+    // );
+
+    logic mm2s_stream_buffer_full;
+    logic mm2s_stream_buffer_empty;
+
+    assign s_dm_axis_tready = !mm2s_stream_buffer_full;
+    assign m_tvalid_buff    = !mm2s_stream_buffer_empty;
+
+    xpm_fifo_sync #(
+        .DOUT_RESET_VALUE    ("0"),
+        .ECC_MODE            ("no_ecc"),
+        .FIFO_MEMORY_TYPE    ("auto"),
+        .FIFO_READ_LATENCY   (1),
+        .FIFO_WRITE_DEPTH    (STREAM_FIFO_DEPTH),
+        .PROG_FULL_THRESH    (STREAM_FIFO_DEPTH-5),
+        .READ_DATA_WIDTH     (DATA_WIDTH + TKEEP_WIDTH + 1),
+        .READ_MODE           ("fwft"),
+        .WRITE_DATA_WIDTH    (DATA_WIDTH + TKEEP_WIDTH + 1)
+    ) mm2s_stream_buffer_inst (
+        .wr_en               (s_dm_axis_tvalid),
+        .din                 ({s_dm_axis_tdata, s_dm_axis_tkeep, s_dm_axis_tlast}),
+        .wr_ack              (),
+        .rd_en               (m_tready_buff),
+        .data_valid          (),
+        .dout                ({m_tdata_buff, m_tkeep_buff, m_tlast_buff}),
+        .wr_data_count       (),
+        .rd_data_count       (),
+        .empty               (mm2s_stream_buffer_empty),
+        .full                (mm2s_stream_buffer_full),
+        .almost_empty        (),
+        .almost_full         (),
+        .overflow            (),
+        .underflow           (),
+        .prog_empty          (),
+        .prog_full           (),
+        .sleep               (1'b0),
+        .sbiterr             (),
+        .dbiterr             (),
+        .injectsbiterr       (1'b0),
+        .injectdbiterr       (1'b0),
+        .wr_clk              (aclk),
+        .rst                 (~aresetn),
+        .rd_rst_busy         (),
+        .wr_rst_busy         ()
+    );
+
+
+    //////////////////////////////////////////////////////////////////
+    // Controller state machine S2MM & MM2S
+    //////////////////////////////////////////////////////////////////
+
+    //******************************************
+    //        Memory Mapped Command FSM
+    //******************************************
+
+    typedef enum logic [1:0] {
+        READ,
+        WRITE,
+        READ_RESULT,
+        WRITE_ACK
+    } opcode_t;
+
+    // Command FSM states
+    typedef enum {C_IDLE,C_START,C_VALID,C_READY} state_c;
+    
+    state_c cmd_reg, cmd_next;
+    
+    logic [HASH_WIDTH-1:0] cmd_address;
+
+    always_ff @(posedge aclk or negedge aresetn) begin
+    if (!aresetn) begin // Boot up the FSM.
+        cmd_reg         <= C_IDLE;
+    end else begin
+        cmd_reg         <= cmd_next;
+    end
+    end
+
+    // Memory Mapped Command FSM
+    always_comb begin
+        cmd_next = cmd_reg;
+
+        metadata_tready_buff = 1'b0;
+        
+        command_sent = 1'b0;
+        cmd_address = '0;
+
+        // MM2S
+        mm2s_cmd_tdata = '0;
+        mm2s_cmd_tvalid = 1'b0;
+
+        mm2s_wr_meta_tdata = '0;
+        mm2s_wr_meta_tvalid = 1'b0;
+
+        // S2MM
+        s2mm_cmd_tdata = '0;
+        s2mm_cmd_tvalid = 1'b0;
+
+        s2mm_wr_meta_tdata = '0;
+        s2mm_wr_meta_tvalid = 1'b0;
+
+        // Ack Stream signals
+        s_ack_tdata_buff = '0;
+        s_ack_tkeep_buff = '0;
+        s_ack_tvalid_buff = 1'b0;
+        s_ack_tlast_buff = 1'b0;
+
+        case(cmd_reg)
+
+        //CMD IDLE state
+        C_IDLE: begin 
+            if(abp_complete0)
+                cmd_next = C_START;
+            else
+                cmd_next = C_IDLE;
+        end
+
+        //CMD START state
+        C_START: begin 
+            cmd_next = C_VALID;
+        end
+
+        //CMD VALID state
+        C_VALID: begin
+            if(metadata_tvalid_buff) //**SLAVE-SIDE.
+                cmd_next = C_READY;
+            else
+                cmd_next = C_VALID;
+        end
+
+        //CMD READY state
+        C_READY: begin
+            metadata_tready_buff = 1'b1;
+            cmd_address = hash(metadata_tdata_buff.key, HASH_MATRIX);
+
+            case (metadata_tdata_buff.opcode)
+                8'h00: begin
+                    if(mm2s_cmd_tready) begin  //**MASTER-SIDE.
+                        mm2s_wr_meta_tvalid = 1'b1;
+                        mm2s_wr_meta_tdata = metadata_tdata_buff;
+                        mm2s_cmd_tvalid = 1'b1;
+                        mm2s_cmd_tdata = {8'h00, 6'b0,cmd_address,10'b0 ,1'b0,1'b1,6'b000000,1'b1,BTT};
+                        cmd_next = C_VALID;                    
+                    end
+                end 
+                8'h01: begin
+                    if(s2mm_cmd_tready && s_ack_tready_buff)begin  //**MASTER-SIDE. 
+                        s2mm_wr_meta_tvalid = 1'b1;
+                        s2mm_wr_meta_tdata = metadata_tdata_buff; 
+                        s2mm_cmd_tvalid = 1'b1;    
+                        s2mm_cmd_tdata = {8'h00, 6'b0,cmd_address,10'b0 ,1'b0,1'b1,6'b000000,1'b1,BTT};  
+                        command_sent = 1'b1;
+                        s_ack_tdata_buff = '0;
+                        s_ack_tkeep_buff = '0;
+                        s_ack_tvalid_buff = 1'b1;
+                        s_ack_tlast_buff = 1'b1;
+                        cmd_next = C_VALID;
+                    end
+                end
+                default:;
+            endcase
+
+
+        end
+        default:;
+        endcase
+    end
+
+    //************************************************
+    //             AXI-Stream FSM [Write]
+    //************************************************
+
+    // S2MM FSM states
+    typedef enum {S2MM_IDLE,S2MM_START,S2MM_VALID,S2MM_READY} state_t;
+    
+    state_t s2mm_reg, s2mm_next; 
+
+    always_ff@(posedge aclk, negedge aresetn) begin
+        if(!aresetn) // Boot up the FSM.
+            s2mm_reg <= S2MM_IDLE;
+        else 
+            s2mm_reg <= s2mm_next; 
+    end
+
+    // Axi Stream FSM [Write]
+    always_comb begin
+        
+        s2mm_next = s2mm_reg;
+
+        s_tready_buff = 1'b0;
+
+        m_dm_axis_tvalid = 1'b0;
+        m_dm_axis_tdata = '0;
+        m_dm_axis_tkeep = '0;
+        m_dm_axis_tlast = 1'b0;
+
+        stream_sent = 1'b0;
+        
+        case(s2mm_reg)
+
+        //AXI IDLE state
+        S2MM_IDLE: begin 
+            if(abp_complete0)
+                s2mm_next = S2MM_START;
+            else
+                s2mm_next = S2MM_IDLE;
+        end
+
+        //AXI START state
+        S2MM_START: begin 
+            if(stream_enable) begin
+                s2mm_next = S2MM_VALID;
+            end
+            else
+                s2mm_next = S2MM_START;
+        end
+
+        //AXI VALID state
+        S2MM_VALID: begin
+            if(s_tvalid_buff && stream_enable) //**SLAVE-SIDE.
+                s2mm_next = S2MM_READY;
+            else
+                s2mm_next = S2MM_VALID;
+        end
+
+        //AXI READY state
+        S2MM_READY: begin
+            if(s_tvalid_buff && m_dm_axis_tready) begin //**MASTER-SIDE.
+                s_tready_buff = 1'b1;
+                m_dm_axis_tvalid = 1'b1;
+                m_dm_axis_tdata = s_tlast_buff ? {4'hF, s_tdata_buff[507:0]} : s_tdata_buff;
+                m_dm_axis_tkeep = s_tlast_buff ? {4'hF, s_tkeep_buff[59:0]}   : s_tkeep_buff;
+                m_dm_axis_tlast = s_tlast_buff;
+                if(s_tlast_buff) begin
+                    s2mm_next = S2MM_VALID;
+                    stream_sent = 1'b1;
+                end
+            end
+            else
+                s2mm_next = S2MM_READY;
+        end
+        default:;
+        endcase
+    end
+
+    //************************************************
+    //             AXI-Stream FSM [Read]
+    //************************************************
+/*
+    // mm2s axi
+    logic [DATA_WIDTH-1:0]  mm2s_axis_tdata;
+    logic [TKEEP_WIDTH-1:0] mm2s_axis_tkeep;
+    logic                   mm2s_axis_tlast;
+    logic                   mm2s_axis_tvalid;
+
+
+    // MM2S FSM states
+    typedef enum {MM2S_IDLE,MM2S_START,MM2S_VALID,MM2S_READY} state_f;
+    
+    state_f state_reg, state_next; 
+
+    always_ff@(posedge aclk, negedge aresetn) begin
+        if(!aresetn) // Boot up the FSM.
+            state_reg <= MM2S_IDLE;
+        else 
+            state_reg <= state_next; 
+    end
+
+    // Axi Stream FSM
+    always_comb begin
+
+        state_next = state_reg;
+
+        m_tready_buff = 1'b0;
+
+        mm2s_axis_tvalid = 1'b0;
+        mm2s_axis_tdata = '0;
+        mm2s_axis_tkeep = '0;
+        mm2s_axis_tlast = '0;
+
+        case(state_reg)
+
+        //AXI IDLE state
+        MM2S_IDLE: begin 
+            if(abp_complete0)
+                state_next = MM2S_START;
+            else
+                state_next = MM2S_IDLE;
+        end
+
+        //AXI START state
+        MM2S_START: begin
+            state_next = MM2S_VALID;
+        end
+
+        //AXI VALID state
+        MM2S_VALID: begin
+            if(m_tvalid_buff) //**SLAVE-SIDE.
+                state_next = MM2S_READY;
+            else
+                state_next = MM2S_VALID;
+        end
+
+        //AXI READY state
+        MM2S_READY: begin 
+            if(m_tvalid_buff && m_axis_tready) begin
+                m_tready_buff = 1'b1;
+
+                mm2s_axis_tvalid = 1'b1;
+                mm2s_axis_tdata = m_tdata_buff;
+                mm2s_axis_tkeep = m_tkeep_buff;
+                mm2s_axis_tlast = m_tlast_buff;
+
+                if(m_tlast_buff) begin
+                    state_next = MM2S_VALID;
+                end
+            end    
+            else
+                state_next = MM2S_READY;
+        end
+
+        endcase
+    end
+*/
+
+
+    //************************************************
+    //         Write-ack/Read Arbitrer FSM
+    //************************************************
+ 
+    // Arbitrer FSM states
+    typedef enum logic [1:0] {RET_IDLE, RET_TYPE, RET_ACK, RET_READ} sel_t;
+    sel_t sel, sel_n;
+
+    logic sent_first_read;
+
+    always_comb begin
+        sel_n = sel;
+
+        // m_axi
+        m_axis_tvalid = 1'b0;
+        m_axis_tdata  = '0;
+        m_axis_tkeep  = '0;
+        m_axis_tlast  = 1'b0;
+
+        //MM2S Buffer tready
+        m_tready_buff = 1'b0;
+        //Write Ack Buffer tready
+        m_ack_tready_buff = 1'b0;
+        //Bvalid Buffer tready
+        m_bready_buff = 1'b0;
+
+        metadata_mem_out = '0;
+        metadata_mem_out_valid = 1'b0;
+
+        //S2MM metadata buffer
+        s2mm_rd_meta_tready = 0;
+        //MM2S metadata buffer
+        mm2s_rd_meta_tready= 0;
+
+        case (sel)
+    
+        //Arbitrer IDLE state
+        RET_IDLE: begin 
+            if(abp_complete0)
+                sel_n = RET_TYPE;
+            else
+                sel_n= RET_IDLE;
+        end
+        
+
+        //Arbitrer TYPE state
+        RET_TYPE: begin
+        if (m_ack_tvalid_buff && s2mm_rd_meta_tvalid && m_bvalid_buff) 
+            sel_n = RET_ACK;
+        else if (m_tvalid_buff && mm2s_rd_meta_tvalid) 
+            sel_n = RET_READ;
+        else
+            sel_n = RET_TYPE;
+        end
+
+        // RET_ACK: begin
+        //     if (s2mm_rd_meta_tvalid && m_bvalid_buff) begin
+        //         m_axis_tvalid = 1'b1;
+        //         m_axis_tdata = '0;
+        //         m_axis_tkeep = '0;
+        //         m_axis_tlast = 1'b1;
+
+        //         metadata_mem_out_valid = 1'b1;
+        //         metadata_mem_out = s2mm_rd_meta_tdata;
+
+        //         if (m_axis_tready) begin
+        //             m_bready_buff = 1'b1;
+        //             s2mm_rd_meta_tready = 1'b1;
+        //             sel_n = RET_TYPE;
+        //         end
+        //     end
+        // end
+
+        //Arbitrer ACK state
+        RET_ACK: begin
+            if (m_ack_tvalid_buff && m_axis_tready && s2mm_rd_meta_tvalid && m_bvalid_buff) begin
+                m_bready_buff = 1'b1;
+                m_axis_tvalid = 1'b1;
+                m_ack_tready_buff = 1'b1;
+                m_axis_tdata = m_ack_tdata_buff;
+                m_axis_tkeep = m_ack_tkeep_buff;
+                m_axis_tlast = m_ack_tlast_buff;
+
+                s2mm_rd_meta_tready = 1'b1;
+                metadata_mem_out_valid = 1'b1;
+                metadata_mem_out = s2mm_rd_meta_tdata;
+
+                sel_n = RET_TYPE;
+            end
+        end
+
+        //Arbitrer READ state
+        RET_READ: begin
+            if (m_tvalid_buff && m_axis_tready) begin            
+                m_axis_tvalid = 1'b1;
+                m_tready_buff = 1'b1;
+                m_axis_tdata  = m_tlast_buff ? {4'h0, m_tdata_buff[507:0]} : m_tdata_buff;
+                m_axis_tkeep  = m_tlast_buff ? {4'h0, m_tkeep_buff[59:0]}  : m_tkeep_buff;
+                m_axis_tlast  = m_tlast_buff;
+
+
+            
+                if (!sent_first_read) begin
+                    mm2s_rd_meta_tready = 1'b1;
+                    metadata_mem_out_valid = 1'b1;
+                    metadata_mem_out = mm2s_rd_meta_tdata;
+                end
+
+                if(m_tlast_buff) begin
+                    sel_n = RET_TYPE;
+                end
+
+            end
+            else begin
+                sel_n = RET_READ;
+            end
+        end
+        default:;
+        endcase
+    end
+
+    always_ff @(posedge aclk or negedge aresetn) begin
+        if (!aresetn) begin
+        sel             <= RET_IDLE;
+        sent_first_read <= 0;
+        end 
+        else begin
+        sel <= sel_n;
+
+            if (sel == RET_READ) begin
+                if (!sent_first_read && m_tvalid_buff && m_axis_tready)
+                    sent_first_read <= 1;
+                if (m_tvalid_buff && m_axis_tready && m_tlast_buff)
+                    sent_first_read <= 0;
+                end 
+            else begin
+                sent_first_read <= 0;
+            end
+        end
+    end
+
+    
+
+    //******************************************
+    //         AXI-Stream Status Hardware 
+    //******************************************
+    /*Clearing the status signals (needed for datamover stable functionality)*/
+
+    // MM2S
+    always_ff@(posedge aclk, negedge aresetn) begin
+        if(!aresetn || !abp_complete0) // Boot up the STS Hardware.
+            s_axis_mm2s_sts_tready <= 1'b0;
+        else if (s_axis_mm2s_sts_tvalid)
+            s_axis_mm2s_sts_tready <= 1'b1; 
+        else
+            s_axis_mm2s_sts_tready <= 1'b0;
+    end
+
+
+    // S2MM
+    always_ff@(posedge aclk, negedge aresetn) begin
+        if(!aresetn || !abp_complete0) // Boot up the STS Hardware.
+            s_axis_s2mm_sts_tready <= 1'b0;
+        else if (s_axis_s2mm_sts_tvalid)
+            s_axis_s2mm_sts_tready <= 1'b1; 
+        else
+            s_axis_s2mm_sts_tready <= 1'b0;
+    end
+
+endmodule
\ No newline at end of file
diff --git a/src/hbm_subsystem/memory_controller/metadata_buffer.sv b/src/hbm_subsystem/memory_controller/metadata_buffer.sv
new file mode 100644
index 0000000..ca0873a
--- /dev/null
+++ b/src/hbm_subsystem/memory_controller/metadata_buffer.sv
@@ -0,0 +1,72 @@
+// typedef struct packed {
+//   logic          [31:0] ip;      // IPv4 address of the sender
+//   logic          [47:0] mac;     // Mac address of the sender
+//   logic           [7:0] id;      // Operation identifier used to distinguish consecutive writes
+//   logic           [7:0] opcode;  // Operation code
+//   logic          [63:0] key;
+// } st_metadata;
+
+module metadata_buffer #(
+  parameter DEPTH      = 64,
+  parameter PTR_WIDTH  = $clog2(DEPTH)
+)(
+  input  logic         aclk,
+  input  logic         aresetn,
+
+  // Slave side (no ready)
+  input  logic         s_valid,
+  input  st_metadata   s_data,
+
+  // Master side (with ready)
+  output logic         m_valid,
+  output st_metadata   m_data,
+  input  logic         m_ready
+);
+
+  // Memory Buffers
+  st_metadata mem [DEPTH-1:0];
+
+  // Write & Read pointers
+  logic [PTR_WIDTH-1:0] write_ptr;
+  logic [PTR_WIDTH-1:0] read_ptr;
+
+  // Counter
+  logic [PTR_WIDTH-1:0] count;
+
+always_ff @(posedge aclk or negedge aresetn) begin
+  if (!aresetn) begin
+    write_ptr <= '0;
+    read_ptr  <= '0;
+    count     <= '0;
+  end 
+  else begin
+    // Write
+    if (s_valid) begin
+      mem[write_ptr] <= s_data;
+      write_ptr      <= write_ptr + 1;
+      if (count < (DEPTH-1))
+        count <= count + 1;
+    end
+
+    // Read
+    if (m_valid && m_ready) begin
+      read_ptr <= read_ptr + 1;
+      count    <= count - 1;
+    end
+  end
+end
+
+  st_metadata m_rand;
+  always_comb begin
+  m_rand.ip = '0;
+  m_rand.id ='0;
+  m_rand.opcode ='0;
+  m_rand.key  = '0;
+  m_rand.mac = '0;
+  end
+
+  assign m_valid = (count != 0);
+  assign m_data  = m_ready? mem[read_ptr] :m_rand;
+  
+
+endmodule
\ No newline at end of file
diff --git a/src/hbm_subsystem/memory_controller/synchronizer.sv b/src/hbm_subsystem/memory_controller/synchronizer.sv
new file mode 100644
index 0000000..291d34f
--- /dev/null
+++ b/src/hbm_subsystem/memory_controller/synchronizer.sv
@@ -0,0 +1,98 @@
+`timescale 1ns / 1ps
+//////////////////////////////////////////////////////////////////////////////////
+// Company: 
+// Engineer: 
+// 
+// Create Date: 05/17/2025 08:44:13 PM
+// Design Name: 
+// Module Name: Controller_Arbitrer
+// Project Name: 
+// Target Devices: 
+// Tool Versions: 
+// Description: 
+// 
+// Dependencies: 
+// 
+// Revision:
+// Revision 0.01 - File Created
+// Additional Comments:
+// 
+//////////////////////////////////////////////////////////////////////////////////
+module synchronizer #(
+    parameter N = 8
+)(
+    input logic  aclk,
+    input logic  aresetn,
+
+    input logic  s2mm_cmd_start,
+
+    input logic  command_sent,
+    input logic  stream_sent,
+
+    output logic stream_enable
+);
+
+    // Arbitrer FSM states
+    typedef enum {A_IDLE,A_WAIT_COMMAND,A_INCR_COMMAND,A_DECR_COMMAND} state_a;
+
+    logic [N-1:0] cmd_count_reg;
+    logic [N-1:0] cmd_count_next;
+
+    state_a state_reg, state_next; 
+
+    always_ff @(posedge aclk, negedge aresetn) begin
+        if(!aresetn) begin // Boot up the FSM.
+            state_reg <= A_IDLE;
+            cmd_count_reg <= '0;
+        end
+        else begin
+            state_reg <= state_next;
+            cmd_count_reg <= cmd_count_next; 
+        end
+    end
+
+    // Arbitrer FSM
+    always_comb begin
+        state_next = state_reg;
+        cmd_count_next = cmd_count_reg;
+
+        case(state_reg)
+
+        //Arbitrer IDLE state
+        A_IDLE: begin 
+            if(s2mm_cmd_start)
+                state_next = A_WAIT_COMMAND;
+            else
+                state_next = A_IDLE;
+        end
+        
+        //CMD START state
+        A_WAIT_COMMAND: begin
+            if(command_sent && stream_sent)
+                state_next = A_WAIT_COMMAND; // no change
+            else if (command_sent)
+                state_next = A_INCR_COMMAND;
+            else if (stream_sent)
+                state_next = A_DECR_COMMAND;
+            else
+                state_next = A_WAIT_COMMAND;
+        end
+
+        A_INCR_COMMAND: begin
+            cmd_count_next = cmd_count_reg +1;
+            state_next = A_WAIT_COMMAND;
+        end 
+
+        A_DECR_COMMAND: begin
+        if(cmd_count_reg > 0)
+                cmd_count_next = cmd_count_reg -1;
+            state_next = A_WAIT_COMMAND;
+        end
+
+        endcase
+
+    end
+
+    assign stream_enable = (cmd_count_reg !=0);
+
+endmodule
\ No newline at end of file
diff --git a/src/hbm_subsystem/packet_deparser.p4 b/src/hbm_subsystem/packet_deparser.p4
new file mode 100644
index 0000000..351f4ec
--- /dev/null
+++ b/src/hbm_subsystem/packet_deparser.p4
@@ -0,0 +1,245 @@
+#include <core.p4>
+#include <xsa.p4>
+
+typedef bit<48>  MacAddr;
+typedef bit<32>  IPv4Addr;
+
+const bit<16> QINQ_TYPE = 0x88A8;
+const bit<16> VLAN_TYPE = 0x8100;
+const bit<16> IPV4_TYPE = 0x0800;
+
+const bit<8>  TCP_PROT  = 0x06;
+const bit<8>  UDP_PROT  = 0x11;
+
+const bit<16> REPLICATION_PORT = 0x7777;
+
+const bit<16> IP_HEADER_SIZE   = 20;
+const bit<16> UDP_HEADER_SIZE  = 8; 
+const bit<16> REP_HEADER_SIZE  = 2;
+const bit<16> KEY_SIZE         = 8;
+const bit<16> PAYLOAD_SIZE     = 1024 - 4 - 8;
+
+// Operations in rep header
+const bit<8> READ        = 0x00;
+const bit<8> WRITE       = 0x01;
+const bit<8> READ_RESULT = 0x02;
+const bit<8> WRITE_ACK   = 0x03;
+
+// ********************************************************************** //
+// *************************** H E A D E R S  *************************** //
+// ********************************************************************** //
+
+header eth_mac_t {
+  MacAddr dmac; // Destination MAC address
+  MacAddr smac; // Source MAC address
+  bit<16> type; // Tag Protocol Identifier
+}
+
+header vlan_t {
+  bit<3>  pcp;  // Priority code point
+  bit<1>  cfi;  // Drop eligible indicator
+  bit<12> vid;  // VLAN identifier
+  bit<16> tpid; // Tag protocol identifier
+}
+
+header ipv4_t {
+  bit<4>   version;  // Version (4 for IPv4)
+  bit<4>   hdr_len;  // Header length in 32b words
+  bit<8>   tos;      // Type of Service
+  bit<16>  length;   // Packet length in 32b words
+  bit<16>  id;       // Identification
+  bit<3>   flags;    // Flags
+  bit<13>  offset;   // Fragment offset
+  bit<8>   ttl;      // Time to live
+  bit<8>   protocol; // Next protocol
+  bit<16>  hdr_chk;  // Header checksum
+  IPv4Addr src;      // Source address
+  IPv4Addr dst;      // Destination address
+}
+
+header ipv4_opt_t {
+  varbit<320> options; // IPv4 options - length = (ipv4.hdr_len - 5) * 32
+}
+
+header tcp_t {
+  bit<16> src_port;   // Source port
+  bit<16> dst_port;   // Destination port
+  bit<32> seqNum;     // Sequence number
+  bit<32> ackNum;     // Acknowledgment number
+  bit<4>  dataOffset; // Data offset
+  bit<6>  resv;       // Offset
+  bit<6>  flags;      // Flags
+  bit<16> window;     // Window
+  bit<16> checksum;   // TCP checksum
+  bit<16> urgPtr;     // Urgent pointer
+}
+
+header tcp_opt_t {
+  varbit<320> options; // TCP options - length = (tcp.dataOffset - 5) * 32
+}
+
+header udp_t {
+  bit<16> src_port;  // Source port
+  bit<16> dst_port;  // Destination port
+  bit<16> length;    // UDP length
+  bit<16> checksum;  // UDP checksum
+}
+
+/* Replication header */
+header rep_h {
+  bit<8>  opcode;
+  bit<8>  id;
+}
+
+header key_h {
+  bit<64> key;
+}
+
+// ********************************************************************** //
+// ************************* S T R U C T U R E S  *********************** //
+// ********************************************************************** //
+
+// header structure
+struct headers {
+  eth_mac_t  eth;
+  vlan_t     new_vlan;
+  vlan_t     vlan;
+  ipv4_t     ipv4;
+  ipv4_opt_t ipv4opt;
+  tcp_t      tcp;
+  tcp_opt_t  tcpopt;
+  udp_t      udp;
+  rep_h      rep;
+  key_h      key;
+}
+
+struct metadata_t {
+  bit<32> ip_src;
+  bit<48> mac_src;
+  bit<8>  opcode;
+  bit<8>  index;
+  bit<64> key;
+
+  // Fixed values
+  bit<32> ip_own;
+  bit<48> mac_own;
+}
+
+// User-defined errors
+error {
+  InvalidIPpacket,
+  InvalidTCPpacket
+}
+
+// ********************************************************************** //
+// *************************** P A R S E R  ***************************** //
+// ********************************************************************** //
+
+parser MyParser(packet_in packet,
+                out headers hdr,
+                inout metadata_t meta,
+                inout standard_metadata_t smeta) {
+
+  state start {
+    transition accept;
+  }
+}
+
+// ********************************************************************** //
+// **************************  P R O C E S S I N G   ******************** //
+// ********************************************************************** //
+
+control MyProcessing(inout headers hdr,
+                     inout metadata_t meta,
+                     inout standard_metadata_t smeta) {
+  InternetChecksum() ck;
+  bit<16> ip_length;
+  bit<16> udp_length;
+  bit<16> csum;
+
+  apply {
+    if (meta.opcode == WRITE) {
+      udp_length = UDP_HEADER_SIZE + REP_HEADER_SIZE + KEY_SIZE + PAYLOAD_SIZE;
+      ip_length = IP_HEADER_SIZE + udp_length;
+      hdr.key.setInvalid();
+    } else if (meta.opcode == READ_RESULT) {
+      udp_length = UDP_HEADER_SIZE + REP_HEADER_SIZE + KEY_SIZE + PAYLOAD_SIZE;
+      ip_length = IP_HEADER_SIZE + udp_length;
+      hdr.key.setInvalid();
+    } else if (meta.opcode == WRITE_ACK) {
+      // 64 byte padding to reach minimum size
+      udp_length = UDP_HEADER_SIZE + REP_HEADER_SIZE + KEY_SIZE + 64;  
+      ip_length = IP_HEADER_SIZE + udp_length;
+      hdr.key.setValid();
+    } else {
+      udp_length = UDP_HEADER_SIZE + REP_HEADER_SIZE + KEY_SIZE;
+      ip_length = IP_HEADER_SIZE + udp_length;
+      hdr.key.setValid();
+    }
+
+    hdr.eth.setValid();
+    hdr.ipv4.setValid();
+    hdr.udp.setValid();
+    hdr.rep.setValid();
+
+    hdr.eth.dmac            = meta.mac_src;
+    hdr.eth.smac            = meta.mac_own;
+    hdr.eth.type            = IPV4_TYPE;
+
+    hdr.ipv4.version        = 4;
+    hdr.ipv4.hdr_len        = 5;
+    hdr.ipv4.tos            = 0;
+    hdr.ipv4.length         = ip_length;
+    hdr.ipv4.id             = 0;
+    hdr.ipv4.flags          = 0;
+    hdr.ipv4.offset         = 0;
+    hdr.ipv4.ttl            = 64;
+    hdr.ipv4.protocol       = UDP_PROT;
+    hdr.ipv4.hdr_chk        = 0;  // Calculated below
+    hdr.ipv4.src            = meta.ip_own;
+    hdr.ipv4.dst            = meta.ip_src;
+
+    hdr.udp.src_port        = REPLICATION_PORT;
+    hdr.udp.dst_port        = REPLICATION_PORT;
+    hdr.udp.length          = udp_length;
+    hdr.udp.checksum        = 0;
+
+    hdr.rep.opcode          = meta.opcode;
+    hdr.rep.id              = meta.index;
+    hdr.key.key             = meta.key;
+
+    ck.clear();
+    ck.add({hdr.ipv4.version, hdr.ipv4.hdr_len, hdr.ipv4.tos, hdr.ipv4.length, hdr.ipv4.id, hdr.ipv4.flags, hdr.ipv4.offset});
+    ck.add({hdr.ipv4.ttl, hdr.ipv4.protocol, hdr.ipv4.src, hdr.ipv4.dst});
+    ck.get(csum);
+    hdr.ipv4.hdr_chk = csum;
+  }
+}
+
+
+// ********************************************************************** //
+// ***************************  D E P A R S E R  ************************ //
+// ********************************************************************** //
+
+control MyDeparser(packet_out packet,
+                   in headers hdr,
+                   inout metadata_t meta,
+                   inout standard_metadata_t smeta) {
+  apply {
+    packet.emit(hdr.eth);
+    packet.emit(hdr.ipv4);
+    packet.emit(hdr.udp);
+    packet.emit(hdr.rep);
+    packet.emit(hdr.key);
+  }
+}
+
+// ********************************************************************** //
+// *******************************  M A I N  **************************** //
+// ********************************************************************** //
+
+XilinxPipeline(
+  MyParser(),
+  MyProcessing(),
+  MyDeparser()
+) main;
diff --git a/src/hbm_subsystem/packet_parser.p4 b/src/hbm_subsystem/packet_parser.p4
new file mode 100644
index 0000000..d99a087
--- /dev/null
+++ b/src/hbm_subsystem/packet_parser.p4
@@ -0,0 +1,274 @@
+#include <core.p4>
+#include <xsa.p4>
+
+typedef bit<48>  MacAddr;
+typedef bit<32>  IPv4Addr;
+
+const bit<16> QINQ_TYPE = 0x88A8;
+const bit<16> VLAN_TYPE = 0x8100;
+const bit<16> IPV4_TYPE = 0x0800;
+
+const bit<8>  TCP_PROT  = 0x06;
+const bit<8>  UDP_PROT  = 0x11;
+
+const bit<16> REPLICATION_PORT = 0x7777;
+
+// Operations in rep header
+const bit<8> READ        = 0x00;
+const bit<8> WRITE       = 0x01;
+const bit<8> READ_RESULT = 0x02;
+const bit<8> WRITE_ACK   = 0x03;
+
+// ********************************************************************** //
+// *************************** H E A D E R S  *************************** //
+// ********************************************************************** //
+
+header eth_mac_t {
+  MacAddr dmac; // Destination MAC address
+  MacAddr smac; // Source MAC address
+  bit<16> type; // Tag Protocol Identifier
+}
+
+header vlan_t {
+  bit<3>  pcp;  // Priority code point
+  bit<1>  cfi;  // Drop eligible indicator
+  bit<12> vid;  // VLAN identifier
+  bit<16> tpid; // Tag protocol identifier
+}
+
+header ipv4_t {
+  bit<4>   version;  // Version (4 for IPv4)
+  bit<4>   hdr_len;  // Header length in 32b words
+  bit<8>   tos;      // Type of Service
+  bit<16>  length;   // Packet length in 32b words
+  bit<16>  id;       // Identification
+  bit<3>   flags;    // Flags
+  bit<13>  offset;   // Fragment offset
+  bit<8>   ttl;      // Time to live
+  bit<8>   protocol; // Next protocol
+  bit<16>  hdr_chk;  // Header checksum
+  IPv4Addr src;      // Source address
+  IPv4Addr dst;      // Destination address
+}
+
+header ipv4_opt_t {
+  varbit<320> options; // IPv4 options - length = (ipv4.hdr_len - 5) * 32
+}
+
+header tcp_t {
+  bit<16> src_port;   // Source port
+  bit<16> dst_port;   // Destination port
+  bit<32> seqNum;     // Sequence number
+  bit<32> ackNum;     // Acknowledgment number
+  bit<4>  dataOffset; // Data offset
+  bit<6>  resv;       // Offset
+  bit<6>  flags;      // Flags
+  bit<16> window;     // Window
+  bit<16> checksum;   // TCP checksum
+  bit<16> urgPtr;     // Urgent pointer
+}
+
+header tcp_opt_t {
+  varbit<320> options; // TCP options - length = (tcp.dataOffset - 5) * 32
+}
+
+header udp_t {
+  bit<16> src_port;  // Source port
+  bit<16> dst_port;  // Destination port
+  bit<16> length;    // UDP length
+  bit<16> checksum;  // UDP checksum
+}
+
+/* Replication header */
+header rep_h {
+  bit<8>  opcode;
+  bit<8>  id;
+}
+
+header key_h {
+  bit<64> key;
+}
+
+// ********************************************************************** //
+// ************************* S T R U C T U R E S  *********************** //
+// ********************************************************************** //
+
+// header structure
+struct headers {
+  eth_mac_t  eth;
+  vlan_t     new_vlan;
+  vlan_t     vlan;
+  ipv4_t     ipv4;
+  ipv4_opt_t ipv4opt;
+  tcp_t      tcp;
+  tcp_opt_t  tcpopt;
+  udp_t      udp;
+  rep_h      rep;
+  key_h      key;
+}
+
+struct metadata_t {
+  bit<32> ip_src;
+  bit<48> mac_src;
+  bit<8>  opcode;
+  bit<8>  index;
+  bit<64> key;
+  bit<1>  is_rep;
+}
+
+// User-defined errors
+error {
+  InvalidIPpacket,
+  InvalidTCPpacket
+}
+
+// ********************************************************************** //
+// *************************** P A R S E R  ***************************** //
+// ********************************************************************** //
+
+parser MyParser(packet_in packet,
+                out headers hdr,
+                inout metadata_t meta,
+                inout standard_metadata_t smeta) {
+
+  state start {
+    transition parse_eth;
+  }
+
+  state parse_eth {
+    packet.extract(hdr.eth);
+    transition select(hdr.eth.type) {
+      VLAN_TYPE : parse_vlan;
+      IPV4_TYPE : parse_ipv4;
+      default   : accept;
+    }
+  }
+
+  state parse_vlan {
+    packet.extract(hdr.vlan);
+    transition select(hdr.vlan.tpid) {
+      IPV4_TYPE : parse_ipv4;
+      default   : accept;
+    }
+  }
+
+  state parse_ipv4 {
+    packet.extract(hdr.ipv4);
+    verify(hdr.ipv4.version == 4 && hdr.ipv4.hdr_len >= 5, error.InvalidIPpacket);
+    packet.extract(hdr.ipv4opt, (((bit<32>)hdr.ipv4.hdr_len - 5) * 32));
+    transition select(hdr.ipv4.protocol) {
+      TCP_PROT  : parse_tcp;
+      UDP_PROT  : parse_udp;
+      default   : accept;
+    }
+  }
+
+  state parse_tcp {
+    packet.extract(hdr.tcp);
+    verify(hdr.tcp.dataOffset >= 5, error.InvalidTCPpacket);
+    packet.extract(hdr.tcpopt,(((bit<32>)hdr.tcp.dataOffset - 5) * 32));
+    transition accept;
+  }
+
+  state parse_udp {
+    packet.extract(hdr.udp);
+    transition select(hdr.udp.dst_port) {
+      REPLICATION_PORT : parse_rep;
+      default          : accept;
+    }
+  }
+
+  state parse_rep {
+    packet.extract(hdr.rep);
+    transition parse_key;
+  }
+
+  state parse_key {
+    packet.extract(hdr.key);
+    transition accept;
+  }
+}
+
+// ********************************************************************** //
+// **************************  P R O C E S S I N G   ******************** //
+// ********************************************************************** //
+
+control MyProcessing(inout headers hdr,
+                     inout metadata_t meta,
+                     inout standard_metadata_t smeta) {
+
+  bit<32> ip_src;
+  bit<48> mac_src;
+  bit<8>  opcode;
+  bit<8>  index;
+  bit<64> key;
+  bit<1>  is_rep;
+
+  apply {
+    ip_src  = (bit<32>) 0;
+    mac_src = (bit<48>) 0;
+    opcode  = (bit<8>) 0;
+    index   = (bit<8>) 0;
+    key     = (bit<64>) 0;
+    is_rep  = (bit<1>) 0;
+
+    if (hdr.eth.isValid() && hdr.ipv4.isValid() && hdr.udp.isValid() && hdr.rep.isValid() && hdr.key.isValid()) {
+      if (hdr.udp.dst_port == 0x7777 && hdr.rep.opcode != READ_RESULT) {
+        ip_src  = hdr.ipv4.src;
+        mac_src = hdr.eth.smac;
+        opcode  = hdr.rep.opcode;
+        index   = hdr.rep.id;
+        key     = hdr.key.key;
+        is_rep  = (bit<1>) 1;
+
+        if (hdr.rep.opcode == WRITE) {
+          hdr.eth.setInvalid();
+          hdr.ipv4.setInvalid();
+          hdr.udp.setInvalid();
+          hdr.rep.setInvalid();
+        } else {
+          smeta.drop = 1;
+        }
+      }
+    }
+
+    meta.mac_src  = mac_src;
+    meta.ip_src   = ip_src;
+    meta.opcode   = opcode;
+    meta.index    = index;
+    meta.key      = key;
+    meta.is_rep   = is_rep;
+  }
+}
+
+// ********************************************************************** //
+// ***************************  D E P A R S E R  ************************ //
+// ********************************************************************** //
+
+control MyDeparser(packet_out packet,
+                   in headers hdr,
+                   inout metadata_t meta,
+                   inout standard_metadata_t smeta) {
+  apply {
+    packet.emit(hdr.eth);
+    packet.emit(hdr.new_vlan);
+    packet.emit(hdr.vlan);
+    packet.emit(hdr.ipv4);
+    packet.emit(hdr.ipv4opt);
+    packet.emit(hdr.tcp);
+    packet.emit(hdr.tcpopt);
+    packet.emit(hdr.udp);
+    packet.emit(hdr.rep);
+    packet.emit(hdr.key);
+  }
+}
+
+// ********************************************************************** //
+// *******************************  M A I N  **************************** //
+// ********************************************************************** //
+
+XilinxPipeline(
+  MyParser(),
+  MyProcessing(),
+  MyDeparser()
+) main;
diff --git a/src/hbm_subsystem/replication_engine.sv b/src/hbm_subsystem/replication_engine.sv
new file mode 100644
index 0000000..71131d4
--- /dev/null
+++ b/src/hbm_subsystem/replication_engine.sv
@@ -0,0 +1,620 @@
+`timescale 1ns/1ps
+
+typedef struct packed {
+  logic          [31:0] ip;      // IPv4 address of the sender
+  logic          [47:0] mac;     // Mac address of the sender
+  logic           [7:0] opcode;  // Operation identifier used to distinguish consecutive writes
+  logic           [7:0] id;      // Operation code
+  logic          [63:0] key;
+} st_metadata;
+
+module replication_engine #(
+  parameter DATA_WIDTH = 512,
+  parameter KEEP_WIDTH = DATA_WIDTH / 8,
+  parameter KEY_WIDTH  = 64,
+  parameter NUM_NODES  = 2,
+  parameter logic [31:0] NODES_IPS [NUM_NODES] = '{ 32'hC0643301, 32'hC0643401}
+) (
+  input  logic axis_clk,
+  input  logic axis_rstn,
+
+  // Replication packet input
+  input  logic                  s_axis_tvalid,
+  input  logic [DATA_WIDTH-1:0] s_axis_tdata,
+  input  logic [KEEP_WIDTH-1:0] s_axis_tkeep,
+  input  logic                  s_axis_tlast,
+  output logic                  s_axis_tready,
+
+  input  st_metadata            metadata_in,
+  input  logic                  metadata_in_valid,
+
+  // Replication packet output
+  output logic                  m_axis_tvalid,
+  output logic [DATA_WIDTH-1:0] m_axis_tdata,
+  output logic [KEEP_WIDTH-1:0] m_axis_tkeep,
+  output logic                  m_axis_tlast,
+  input  logic                  m_axis_tready,
+
+  output st_metadata            metadata_out,
+  output logic                  metadata_out_valid,
+
+  // Memory controller read
+  input  logic                  s_axis_mem_tvalid,
+  input  logic [DATA_WIDTH-1:0] s_axis_mem_tdata,
+  input  logic [KEEP_WIDTH-1:0] s_axis_mem_tkeep,
+  input  logic                  s_axis_mem_tlast,
+  output logic                  s_axis_mem_tready,
+
+  input  st_metadata            metadata_mem_in,
+  input  logic                  metadata_mem_in_valid,
+
+  // Memory controller write
+  output logic                  m_axis_mem_tvalid,
+  output logic [DATA_WIDTH-1:0] m_axis_mem_tdata,
+  output logic [KEEP_WIDTH-1:0] m_axis_mem_tkeep,
+  output logic                  m_axis_mem_tlast,
+  input  logic                  m_axis_mem_tready,
+
+  output st_metadata            metadata_mem_out,
+  output logic                  metadata_mem_out_valid
+);
+
+localparam FIFO_DEPTH     = 128;
+localparam FIFO_PTR_WIDTH = $clog2(FIFO_DEPTH);
+localparam NODE_PTR_WIDTH = $clog2(NUM_NODES);
+localparam METADATA_WIDTH = $bits(st_metadata);
+
+typedef enum logic [1:0] {
+  READ,
+  WRITE,
+  READ_RESULT,
+  WRITE_ACK
+} opcode_t;
+
+typedef enum logic [1:0] {
+  ACCEPT_NET,
+  WRITE_MEM,
+  WRITE_REP
+} net_state_t;
+
+typedef enum logic {
+  ACCEPT_MEM,
+  READ_MEM
+} mem_state_t;
+
+net_state_t net_state, net_state_next;
+mem_state_t mem_state, mem_state_next;
+
+// Signals for metadata FIFOs
+logic       net_meta_rd_en;
+logic       net_meta_empty;
+st_metadata net_meta_out;
+
+logic       mem_meta_rd_en;
+logic       mem_meta_empty;
+st_metadata mem_meta_out;
+
+// Signals for packet FIFOs
+logic                  net_fifo_rd_en;
+logic                  net_fifo_empty;
+logic                  net_fifo_prog_full;
+logic [DATA_WIDTH-1:0] net_fifo_out_tdata;
+logic [KEEP_WIDTH-1:0] net_fifo_out_tkeep;
+logic                  net_fifo_out_tlast;
+
+logic                  mem_fifo_rd_en;
+logic                  mem_fifo_empty;
+logic                  mem_fifo_prog_full;
+logic [DATA_WIDTH-1:0] mem_fifo_out_tdata;
+logic [KEEP_WIDTH-1:0] mem_fifo_out_tkeep;
+logic                  mem_fifo_out_tlast;
+
+assign s_axis_tready     = !net_fifo_prog_full;
+assign s_axis_mem_tready = !mem_fifo_prog_full;
+
+// Signals for replicating writes to backup nodes
+typedef struct packed {
+  logic [DATA_WIDTH-1:0] tdata;
+  logic [KEEP_WIDTH-1:0] tkeep;
+  logic                  tlast;
+} st_beat;
+
+(* ram_style="block" *) st_beat replica_mem [FIFO_DEPTH];
+st_beat replica_mem_read, replica_mem_write;
+logic [FIFO_PTR_WIDTH-1:0] rep_write_ptr, rep_write_ptr_next;
+logic [FIFO_PTR_WIDTH-1:0] rep_read_cnt, rep_read_cnt_next, rep_read_ptr;
+logic [NODE_PTR_WIDTH-1:0] nodes_count, nodes_count_next;
+logic                      rep_wr_en;
+logic                      metadata_sent, metadata_sent_next;
+logic                [1:0] memory_delay, memory_delay_next;
+
+// Signals for keeping track of replicas' write acks
+typedef struct packed {
+  st_metadata                meta;
+  logic [FIFO_PTR_WIDTH-1:0] id;
+  logic               [31:0] count;
+  logic                      is_running;
+} st_ack;
+
+(* ram_style="block" *) st_ack ack_table [FIFO_DEPTH];
+st_ack ack_table_read, ack_table_write;
+logic [FIFO_PTR_WIDTH-1:0] ack_read_ptr, ack_write_ptr;
+logic [FIFO_PTR_WIDTH-1:0] ack_id, ack_id_next;
+logic                      ack_wr_en;
+
+// Infers BRAM for replica_mem and ack_table
+always_ff @(posedge axis_clk) begin
+  if (rep_wr_en)
+    replica_mem[rep_write_ptr] <= replica_mem_write;
+  replica_mem_read <= replica_mem[rep_read_ptr];
+
+  if (ack_wr_en)
+    ack_table[ack_write_ptr] <= ack_table_write;
+  ack_table_read <= ack_table[ack_read_ptr];
+end
+
+// Keeps track of which side is using the output interface: 10 incoming packets, 01 memory controller
+logic [1:0] out_busy, out_busy_next;
+
+// Checks whether the node is the leader for given key
+function logic is_leader (input logic [KEY_WIDTH-1:0] key);
+  logic [NODE_PTR_WIDTH-1:0] leader_id;
+  leader_id = key[NODE_PTR_WIDTH-1:0];
+  if (NODES_IPS[leader_id] == NODES_IPS[0])
+    return 1'b1;
+  return 1'b0;
+endfunction
+
+always_ff @(posedge axis_clk) begin
+  if (!axis_rstn) begin
+    net_state      <= ACCEPT_NET;
+    mem_state      <= ACCEPT_MEM;
+    ack_id         <= 1;
+    rep_read_cnt   <= '0;
+    rep_write_ptr  <= '0;
+    nodes_count    <= '0;
+    metadata_sent  <= '0;
+    out_busy       <= 1'b0;
+    memory_delay   <= '0;
+  end 
+  else begin
+    net_state      <= net_state_next;
+    mem_state      <= mem_state_next;
+    ack_id         <= ack_id_next;
+    rep_read_cnt   <= rep_read_cnt_next;
+    rep_write_ptr  <= rep_write_ptr_next;
+    nodes_count    <= nodes_count_next;
+    metadata_sent  <= metadata_sent_next;
+    out_busy       <= out_busy_next;
+    memory_delay   <= memory_delay_next;
+  end
+end
+
+always_comb begin
+  net_state_next = net_state;
+  mem_state_next = mem_state;
+  net_meta_rd_en = 1'b0;
+  net_fifo_rd_en = 1'b0;
+  mem_meta_rd_en = 1'b0;
+  mem_fifo_rd_en = 1'b0;
+
+  ack_id_next        = ack_id;
+  out_busy_next      = out_busy;
+  nodes_count_next   = nodes_count;
+  metadata_sent_next = metadata_sent;
+  memory_delay_next  = memory_delay;
+  rep_read_cnt_next  = rep_read_cnt;
+  rep_write_ptr_next = rep_write_ptr;
+  replica_mem_write  = 0;
+  ack_table_write    = 0;
+  rep_read_ptr       = 0;
+  ack_read_ptr       = 0;
+  ack_write_ptr      = 0;
+  rep_wr_en          = 1'b0;
+  ack_wr_en          = 1'b0;
+
+  m_axis_tvalid = 0;
+  m_axis_tdata  = 0;
+  m_axis_tkeep  = 0;
+  m_axis_tlast  = 0;
+
+  metadata_out_valid = 0;
+  metadata_out       = 0;
+
+  m_axis_mem_tvalid = 0;
+  m_axis_mem_tdata  = 0;
+  m_axis_mem_tkeep  = 0;
+  m_axis_mem_tlast  = 0;
+
+  metadata_mem_out_valid = 0;
+  metadata_mem_out       = 0;
+
+  // Process incoming packets
+  case (net_state)
+    ACCEPT_NET: begin
+      if (!net_meta_empty) begin
+        case (net_meta_out.opcode)
+          READ: begin
+            metadata_mem_out_valid = 1'b1;
+            metadata_mem_out       = net_meta_out;
+            if (m_axis_mem_tready)
+              net_meta_rd_en = 1'b1;
+          end
+          WRITE: begin
+            m_axis_mem_tvalid = !net_fifo_empty;
+            m_axis_mem_tdata  = net_fifo_out_tdata;
+            m_axis_mem_tkeep  = net_fifo_out_tkeep;
+            m_axis_mem_tlast  = net_fifo_out_tlast;
+            net_fifo_rd_en = m_axis_mem_tready;
+
+            metadata_mem_out_valid = 1'b1;
+            metadata_mem_out       = net_meta_out;
+            if (m_axis_mem_tready) begin
+              if (is_leader(net_meta_out.key)) begin
+                net_state_next      = WRITE_REP;
+                rep_read_cnt_next   = 0;
+                rep_write_ptr_next  = 0;
+                nodes_count_next    = 0;
+
+                // Save the first beat for replicas
+                if (m_axis_mem_tvalid) begin
+                  replica_mem_write.tdata = net_fifo_out_tdata;
+                  replica_mem_write.tkeep = net_fifo_out_tkeep;
+                  replica_mem_write.tlast = net_fifo_out_tlast;
+                  rep_write_ptr_next = 1;
+                end
+
+                // Start keeping track of acks for this write
+                ack_table_write.meta       = net_meta_out;
+                ack_table_write.id         = ack_id;
+                ack_table_write.count      = 0;
+                ack_table_write.is_running = 1'b1;
+                ack_write_ptr = ack_id;
+                ack_wr_en     = 1'b1;
+                ack_id_next   = ack_id + 1;
+              end
+              else begin
+                net_state_next = WRITE_MEM;
+                net_meta_rd_en = 1'b1;
+              end
+            end
+          end
+          WRITE_ACK: begin
+            memory_delay_next = 1;
+            ack_read_ptr      = net_meta_out.id;
+            ack_write_ptr     = net_meta_out.id;
+            if (memory_delay) begin
+              if (is_leader(net_meta_out.key) && ack_table_read.is_running) begin
+                if (!out_busy[1] && ack_table_read.count + 1 == NUM_NODES - 1) begin
+                  out_busy_next[0] = 1'b1;
+
+                  metadata_out_valid  = 1'b1;
+                  metadata_out        = ack_table_read.meta;
+                  metadata_out.opcode = WRITE_ACK;
+
+                  m_axis_tvalid = 1'b1;
+                  m_axis_tdata  = '1;
+                  m_axis_tkeep  = '1;
+                  m_axis_tlast  = 1'b1;
+
+                  if (m_axis_tready) begin
+                    ack_table_write.is_running = 1'b0;
+                    ack_wr_en        = 1'b1;
+                    out_busy_next[0] = 1'b0;
+                    net_meta_rd_en   = 1'b1;
+                    net_fifo_rd_en   = 1'b1; 
+                  end
+                end
+                else begin
+                  ack_table_write.count = ack_table_read.count + 1;
+                  ack_wr_en      = 1'b1;
+                  net_meta_rd_en = 1'b1;
+                  net_fifo_rd_en = 1'b1; 
+                end
+              end
+              else begin
+                net_meta_rd_en = 1'b1;
+                net_fifo_rd_en = 1'b1; 
+              end
+            end
+          end
+          default:;
+        endcase
+      end
+    end
+    WRITE_MEM: begin
+      m_axis_mem_tvalid = !net_fifo_empty;
+      m_axis_mem_tdata  = net_fifo_out_tdata;
+      m_axis_mem_tkeep  = net_fifo_out_tkeep;
+      m_axis_mem_tlast  = net_fifo_out_tlast;
+      net_fifo_rd_en = m_axis_mem_tready;
+      if (m_axis_mem_tvalid && m_axis_mem_tready && m_axis_mem_tlast)
+        net_state_next = ACCEPT_NET;
+    end
+    WRITE_REP: begin
+      //FIXME: write pointer should always be at least one higher than read pointer
+      rep_read_ptr = rep_read_cnt;
+
+      // While writing to the first node, also move the write to the memory controller
+      if (nodes_count == 0) begin
+        m_axis_mem_tvalid = !net_fifo_empty;
+        m_axis_mem_tdata  = net_fifo_out_tdata;
+        m_axis_mem_tkeep  = net_fifo_out_tkeep;
+        m_axis_mem_tlast  = net_fifo_out_tlast;
+        net_fifo_rd_en = m_axis_mem_tready;
+
+        if (m_axis_mem_tvalid && m_axis_mem_tready) begin
+          replica_mem_write.tdata = net_fifo_out_tdata;
+          replica_mem_write.tkeep = net_fifo_out_tkeep;
+          replica_mem_write.tlast = net_fifo_out_tlast;
+          rep_write_ptr_next = rep_write_ptr + 1;
+          rep_wr_en = 1'b1;
+        end
+      end
+
+      // Wait for the replica memory to output first value
+      if (memory_delay != 2)
+        memory_delay_next = memory_delay + 1;
+      else begin
+        if (!out_busy[1]) begin
+          out_busy_next[0] = 1'b1;
+          m_axis_tvalid = 1'b1;
+          m_axis_tdata  = replica_mem_read.tdata;
+          m_axis_tkeep  = replica_mem_read.tkeep;
+          m_axis_tlast  = replica_mem_read.tlast;
+
+          if (rep_read_cnt == 0) begin
+            metadata_out_valid = 1'b1;
+            metadata_out       = net_meta_out;
+            //FIXME: Change mac address
+            metadata_out.id    = ack_id - 1;
+            metadata_out.ip    = NODES_IPS[nodes_count + 1];
+          end
+
+          if (m_axis_tready) begin
+            rep_read_ptr      = rep_read_cnt + 1;
+            rep_read_cnt_next = rep_read_cnt + 1;
+            if (m_axis_tlast) begin
+              if (nodes_count + 1 == NUM_NODES - 1) begin
+                net_state_next    = ACCEPT_NET;
+                net_meta_rd_en    = 1'b1;
+                out_busy_next[0]  = 1'b0;
+                memory_delay_next = 1'b0;
+              end
+              rep_read_cnt_next  = 0;
+              rep_read_ptr       = 0;
+              metadata_sent_next = 1'b0;
+              nodes_count_next   = nodes_count + 1;
+            end
+          end
+        end
+      end
+    end
+    default:;
+  endcase
+
+  // Process incoming memory controller data
+  if (!out_busy[0] && !out_busy_next[0]) begin
+    case (mem_state)
+      ACCEPT_MEM: begin
+        if (!mem_meta_empty) begin
+          out_busy_next[1] = 1'b1;
+          case (mem_meta_out.opcode)
+            READ: begin
+              m_axis_tvalid = !mem_fifo_empty;
+              m_axis_tdata  = mem_fifo_out_tdata;
+              m_axis_tkeep  = mem_fifo_out_tkeep;
+              m_axis_tlast  = mem_fifo_out_tlast;
+              mem_fifo_rd_en = m_axis_tready;
+
+              metadata_out_valid  = 1'b1;
+              metadata_out        = mem_meta_out;
+              metadata_out.opcode = READ_RESULT;
+
+              if (m_axis_tready) begin
+                mem_state_next = READ_MEM;
+                mem_meta_rd_en = 1'b1;
+              end
+            end
+            WRITE: begin
+              metadata_out_valid  = 1'b1;
+              metadata_out        = mem_meta_out;
+              metadata_out.opcode = WRITE_ACK;
+
+              m_axis_tvalid = 1'b1;
+              m_axis_tdata  = '1;
+              m_axis_tkeep  = '1;
+              m_axis_tlast  = 1'b1;
+
+              // TODO: If node is leader, than one ack is mistakenly sent immediately back
+              if (m_axis_tready) begin
+                out_busy_next[1] = 1'b0;
+                // This works because memory controller outputs data and metadata together
+                mem_meta_rd_en   = 1'b1;
+                mem_fifo_rd_en   = 1'b1;
+              end
+            end
+            default:;
+          endcase
+        end
+      end
+      READ_MEM: begin
+        m_axis_tvalid = !mem_fifo_empty;
+        m_axis_tdata  = mem_fifo_out_tdata;
+        m_axis_tkeep  = mem_fifo_out_tkeep;
+        m_axis_tlast  = mem_fifo_out_tlast;
+        mem_fifo_rd_en = m_axis_tready;
+
+        if (m_axis_tvalid && m_axis_tready && m_axis_tlast) begin
+          out_busy_next[1] = 1'b0;
+          mem_state_next = ACCEPT_MEM;
+        end
+      end
+      default:;
+    endcase
+  end
+end
+
+logic net_fifo_wr_en;
+assign net_fifo_wr_en = s_axis_tvalid && |s_axis_tkeep;
+
+// FIFO to store input replication packets
+xpm_fifo_sync #(
+  .DOUT_RESET_VALUE    ("0"),
+  .ECC_MODE            ("no_ecc"),
+  .FIFO_MEMORY_TYPE    ("auto"),
+  .FIFO_READ_LATENCY   (1),
+  .FIFO_WRITE_DEPTH    (FIFO_DEPTH),
+  .PROG_FULL_THRESH    (FIFO_DEPTH-5),
+  .READ_DATA_WIDTH     (DATA_WIDTH + KEEP_WIDTH + 1),
+  .READ_MODE           ("fwft"),
+  .WRITE_DATA_WIDTH    (DATA_WIDTH + KEEP_WIDTH + 1)
+) net_fifo (
+  .wr_en               (net_fifo_wr_en),
+  .din                 ({s_axis_tdata, s_axis_tkeep, s_axis_tlast}),
+  .wr_ack              (),
+  .rd_en               (net_fifo_rd_en),
+  .data_valid          (),
+  .dout                ({net_fifo_out_tdata, net_fifo_out_tkeep, net_fifo_out_tlast}),
+  .wr_data_count       (),
+  .rd_data_count       (),
+  .empty               (net_fifo_empty),
+  .full                (),
+  .almost_empty        (),
+  .almost_full         (),
+  .overflow            (),
+  .underflow           (),
+  .prog_empty          (),
+  .prog_full           (net_fifo_prog_full),
+  .sleep               (1'b0),
+  .sbiterr             (),
+  .dbiterr             (),
+  .injectsbiterr       (1'b0),
+  .injectdbiterr       (1'b0),
+  .wr_clk              (axis_clk),
+  .rst                 (~axis_rstn),
+  .rd_rst_busy         (),
+  .wr_rst_busy         ()
+);
+
+// FIFO to store input replication metadata
+xpm_fifo_sync #(
+  .DOUT_RESET_VALUE    ("0"),
+  .ECC_MODE            ("no_ecc"),
+  .FIFO_MEMORY_TYPE    ("auto"),
+  .FIFO_READ_LATENCY   (1),
+  .FIFO_WRITE_DEPTH    (FIFO_DEPTH),
+  .PROG_FULL_THRESH    (FIFO_DEPTH-5),
+  .READ_DATA_WIDTH     (METADATA_WIDTH),
+  .READ_MODE           ("fwft"),
+  .WRITE_DATA_WIDTH    (METADATA_WIDTH)
+) net_metadata_fifo (
+  .wr_en               (metadata_in_valid),
+  .din                 (metadata_in),
+  .wr_ack              (),
+  .rd_en               (net_meta_rd_en),
+  .data_valid          (),
+  .dout                (net_meta_out),
+  .wr_data_count       (),
+  .rd_data_count       (),
+  .empty               (net_meta_empty),
+  .full                (),
+  .almost_empty        (),
+  .almost_full         (),
+  .overflow            (),
+  .underflow           (),
+  .prog_empty          (),
+  .prog_full           (),
+  .sleep               (1'b0),
+  .sbiterr             (),
+  .dbiterr             (),
+  .injectsbiterr       (1'b0),
+  .injectdbiterr       (1'b0),
+  .wr_clk              (axis_clk),
+  .rst                 (~axis_rstn),
+  .rd_rst_busy         (),
+  .wr_rst_busy         ()
+);
+
+logic mem_fifo_wr_en;
+assign mem_fifo_wr_en = s_axis_mem_tvalid && |s_axis_mem_tkeep;
+
+// FIFO to store input memory controller packets
+xpm_fifo_sync #(
+  .DOUT_RESET_VALUE    ("0"),
+  .ECC_MODE            ("no_ecc"),
+  .FIFO_MEMORY_TYPE    ("auto"),
+  .FIFO_READ_LATENCY   (1),
+  .FIFO_WRITE_DEPTH    (FIFO_DEPTH),
+  .PROG_FULL_THRESH    (FIFO_DEPTH-5),
+  .READ_DATA_WIDTH     (DATA_WIDTH + KEEP_WIDTH + 1),
+  .READ_MODE           ("fwft"),
+  .WRITE_DATA_WIDTH    (DATA_WIDTH + KEEP_WIDTH + 1)
+) mem_fifo (
+  .wr_en               (s_axis_mem_tvalid),
+  .din                 ({s_axis_mem_tdata, s_axis_mem_tkeep, s_axis_mem_tlast}),
+  .wr_ack              (),
+  .rd_en               (mem_fifo_rd_en),
+  .data_valid          (),
+  .dout                ({mem_fifo_out_tdata, mem_fifo_out_tkeep, mem_fifo_out_tlast}),
+  .wr_data_count       (),
+  .rd_data_count       (),
+  .empty               (mem_fifo_empty),
+  .full                (),
+  .almost_empty        (),
+  .almost_full         (),
+  .overflow            (),
+  .underflow           (),
+  .prog_empty          (),
+  .prog_full           (mem_fifo_prog_full),
+  .sleep               (1'b0),
+  .sbiterr             (),
+  .dbiterr             (),
+  .injectsbiterr       (1'b0),
+  .injectdbiterr       (1'b0),
+  .wr_clk              (axis_clk),
+  .rst                 (~axis_rstn),
+  .rd_rst_busy         (),
+  .wr_rst_busy         ()
+);
+
+// FIFO to store input memory controller metadata
+xpm_fifo_sync #(
+  .DOUT_RESET_VALUE    ("0"),
+  .ECC_MODE            ("no_ecc"),
+  .FIFO_MEMORY_TYPE    ("auto"),
+  .FIFO_READ_LATENCY   (1),
+  .FIFO_WRITE_DEPTH    (FIFO_DEPTH),
+  .PROG_FULL_THRESH    (FIFO_DEPTH-5),
+  .READ_DATA_WIDTH     (METADATA_WIDTH),
+  .READ_MODE           ("fwft"),
+  .WRITE_DATA_WIDTH    (METADATA_WIDTH)
+) mem_metadata_fifo (
+  .wr_en               (metadata_mem_in_valid),
+  .din                 (metadata_mem_in),
+  .wr_ack              (),
+  .rd_en               (mem_meta_rd_en),
+  .data_valid          (),
+  .dout                (mem_meta_out),
+  .wr_data_count       (),
+  .rd_data_count       (),
+  .empty               (mem_meta_empty),
+  .full                (),
+  .almost_empty        (),
+  .almost_full         (),
+  .overflow            (),
+  .underflow           (),
+  .prog_empty          (),
+  .prog_full           (),
+  .sleep               (1'b0),
+  .sbiterr             (),
+  .dbiterr             (),
+  .injectsbiterr       (1'b0),
+  .injectdbiterr       (1'b0),
+  .wr_clk              (axis_clk),
+  .rst                 (~axis_rstn),
+  .rd_rst_busy         (),
+  .wr_rst_busy         ()
+);
+
+endmodule
diff --git a/src/hbm_subsystem/vivado_ip/packet_arbiter.tcl b/src/hbm_subsystem/vivado_ip/packet_arbiter.tcl
new file mode 100644
index 0000000..227b301
--- /dev/null
+++ b/src/hbm_subsystem/vivado_ip/packet_arbiter.tcl
@@ -0,0 +1,12 @@
+create_ip -name axis_switch -vendor xilinx.com -library ip -module_name packet_arbiter -dir ${ip_build_dir}
+set_property -dict { 
+  CONFIG.ARB_ON_MAX_XFERS {0} \
+  CONFIG.ARB_ON_TLAST {1} \
+  CONFIG.HAS_TKEEP {1} \
+  CONFIG.HAS_TLAST {1} \
+  CONFIG.HAS_TSTRB {0} \
+  CONFIG.TDATA_NUM_BYTES {64} \
+  CONFIG.TDEST_WIDTH {0} \
+  CONFIG.TID_WIDTH {0} \
+  CONFIG.TUSER_WIDTH {48} \
+} [get_ips packet_arbiter]
\ No newline at end of file
diff --git a/src/hbm_subsystem/vivado_ip/packet_deparser.tcl b/src/hbm_subsystem/vivado_ip/packet_deparser.tcl
new file mode 100644
index 0000000..c5cd03b
--- /dev/null
+++ b/src/hbm_subsystem/vivado_ip/packet_deparser.tcl
@@ -0,0 +1,19 @@
+set prj_root [file normalize ..]
+set p4_filepath ${prj_root}/src/hbm_subsystem
+
+if {[info exists p4_dir]} {
+  set p4file [glob -directory ${p4_dir} packet_deparser.p4]
+} else {
+  set p4file [glob -directory ${p4_filepath} packet_deparser.p4]
+}
+
+puts "p4file = ${p4file}"
+
+create_ip -name vitis_net_p4 -vendor xilinx.com -library ip -module_name packet_deparser -dir ${ip_build_dir}
+set_property CONFIG.P4_FILE "${p4file}" [get_ips packet_deparser]
+set_property -dict { 
+  CONFIG.AXIS_CLK_FREQ_MHZ {250} \
+  CONFIG.CAM_MEM_CLK_FREQ_MHZ {250} \
+  CONFIG.PKT_RATE {250} \
+  CONFIG.TOTAL_LATENCY {22} \
+} [get_ips packet_deparser]
\ No newline at end of file
diff --git a/src/hbm_subsystem/vivado_ip/packet_filter.tcl b/src/hbm_subsystem/vivado_ip/packet_filter.tcl
new file mode 100644
index 0000000..f7ded3c
--- /dev/null
+++ b/src/hbm_subsystem/vivado_ip/packet_filter.tcl
@@ -0,0 +1,11 @@
+create_ip -name axis_switch -vendor xilinx.com -library ip -module_name packet_filter -dir ${ip_build_dir}
+set_property -dict { 
+  CONFIG.HAS_TKEEP {1} \
+  CONFIG.HAS_TLAST {1} \
+  CONFIG.HAS_TSTRB {0} \
+  CONFIG.NUM_SI {1} \
+  CONFIG.TDATA_NUM_BYTES {64} \
+  CONFIG.TDEST_WIDTH {1} \
+  CONFIG.TID_WIDTH {0} \
+  CONFIG.TUSER_WIDTH {48} \
+} [get_ips packet_filter]
\ No newline at end of file
diff --git a/src/hbm_subsystem/vivado_ip/packet_parser.tcl b/src/hbm_subsystem/vivado_ip/packet_parser.tcl
new file mode 100644
index 0000000..0d44fb4
--- /dev/null
+++ b/src/hbm_subsystem/vivado_ip/packet_parser.tcl
@@ -0,0 +1,21 @@
+set prj_root [file normalize ..]
+set p4_filepath ${prj_root}/src/hbm_subsystem
+
+if {[info exists p4_dir]} {
+  set p4file [glob -directory ${p4_dir} packet_parser.p4]
+} else {
+  set p4file [glob -directory ${p4_filepath} packet_parser.p4]
+}
+
+puts "p4file = ${p4file}"
+
+create_ip -name vitis_net_p4 -vendor xilinx.com -library ip -module_name packet_parser -dir ${ip_build_dir}
+set_property CONFIG.P4_FILE "${p4file}" [get_ips packet_parser]
+set_property -dict { 
+  CONFIG.AXIS_CLK_FREQ_MHZ {250} \
+  CONFIG.CAM_MEM_CLK_FREQ_MHZ {250} \
+  CONFIG.JSON_TIMESTAMP {1756741124} \
+  CONFIG.OUTPUT_METADATA_FOR_DROPPED_PKTS {true} \
+  CONFIG.PKT_RATE {250} \
+  CONFIG.TOTAL_LATENCY {32} \
+} [get_ips packet_parser]
diff --git a/src/hbm_subsystem/vivado_ip/vivado_ip.tcl b/src/hbm_subsystem/vivado_ip/vivado_ip.tcl
new file mode 100644
index 0000000..8d93e4e
--- /dev/null
+++ b/src/hbm_subsystem/vivado_ip/vivado_ip.tcl
@@ -0,0 +1,6 @@
+set ips {
+  packet_arbiter
+  packet_filter
+  packet_parser
+  packet_deparser
+}
\ No newline at end of file
diff --git a/src/open_nic_shell.sv b/src/open_nic_shell.sv
index 572e191..3e57fe2 100644
--- a/src/open_nic_shell.sv
+++ b/src/open_nic_shell.sv
@@ -278,7 +278,7 @@ module open_nic_shell #(
   wire                   [1:0] axil_box1_rresp;
   wire                         axil_box1_rready;
 
-  // QDMA subsystem interfaces to the box running at 250MHz
+  // QDMA subsystem interfaces to the HBM subsystem
   wire     [NUM_PHYS_FUNC*NUM_QDMA-1:0] axis_qdma_h2c_tvalid;
   wire [512*NUM_PHYS_FUNC*NUM_QDMA-1:0] axis_qdma_h2c_tdata;
   wire  [64*NUM_PHYS_FUNC*NUM_QDMA-1:0] axis_qdma_h2c_tkeep;
@@ -297,6 +297,25 @@ module open_nic_shell #(
   wire  [16*NUM_PHYS_FUNC*NUM_QDMA-1:0] axis_qdma_c2h_tuser_dst;
   wire     [NUM_PHYS_FUNC*NUM_QDMA-1:0] axis_qdma_c2h_tready;
 
+  // HBM subsystem interfaces to the box running at 250Mhz
+  wire         axis_hbm_h2c_tvalid;
+  wire [511:0] axis_hbm_h2c_tdata;
+  wire  [63:0] axis_hbm_h2c_tkeep;
+  wire         axis_hbm_h2c_tlast;
+  wire  [15:0] axis_hbm_h2c_tuser_size;
+  wire  [15:0] axis_hbm_h2c_tuser_src;
+  wire  [15:0] axis_hbm_h2c_tuser_dst;
+  wire         axis_hbm_h2c_tready;
+
+  wire         axis_hbm_c2h_tvalid;
+  wire [511:0] axis_hbm_c2h_tdata;
+  wire  [63:0] axis_hbm_c2h_tkeep;
+  wire         axis_hbm_c2h_tlast;
+  wire  [15:0] axis_hbm_c2h_tuser_size;
+  wire  [15:0] axis_hbm_c2h_tuser_src;
+  wire  [15:0] axis_hbm_c2h_tuser_dst;
+  wire         axis_hbm_c2h_tready;
+
   // Packet adapter interfaces to the box running at 250MHz
   wire     [NUM_CMAC_PORT-1:0] axis_adap_tx_250mhz_tvalid;
   wire [512*NUM_CMAC_PORT-1:0] axis_adap_tx_250mhz_tdata;
@@ -807,10 +826,46 @@ module open_nic_shell #(
     .s_axi_wstrb          (axi_wstrb),
     .s_axi_wuser          (axi_wuser),
     .s_axi_wvalid         (axi_wvalid),
+
+    .s_axis_qdma_h2c_tvalid           (axis_qdma_h2c_tvalid),
+    .s_axis_qdma_h2c_tdata            (axis_qdma_h2c_tdata),
+    .s_axis_qdma_h2c_tkeep            (axis_qdma_h2c_tkeep),
+    .s_axis_qdma_h2c_tlast            (axis_qdma_h2c_tlast),
+    .s_axis_qdma_h2c_tuser_size       (axis_qdma_h2c_tuser_size),
+    .s_axis_qdma_h2c_tuser_src        (axis_qdma_h2c_tuser_src),
+    .s_axis_qdma_h2c_tuser_dst        (axis_qdma_h2c_tuser_dst),
+    .s_axis_qdma_h2c_tready           (axis_qdma_h2c_tready),
+
+    .m_axis_qdma_c2h_tvalid           (axis_qdma_c2h_tvalid),
+    .m_axis_qdma_c2h_tdata            (axis_qdma_c2h_tdata),
+    .m_axis_qdma_c2h_tkeep            (axis_qdma_c2h_tkeep),
+    .m_axis_qdma_c2h_tlast            (axis_qdma_c2h_tlast),
+    .m_axis_qdma_c2h_tuser_size       (axis_qdma_c2h_tuser_size),
+    .m_axis_qdma_c2h_tuser_src        (axis_qdma_c2h_tuser_src),
+    .m_axis_qdma_c2h_tuser_dst        (axis_qdma_c2h_tuser_dst),
+    .m_axis_qdma_c2h_tready           (axis_qdma_c2h_tready),
+
+    .m_axis_cmac_h2c_tvalid           (axis_hbm_h2c_tvalid),
+    .m_axis_cmac_h2c_tdata            (axis_hbm_h2c_tdata),
+    .m_axis_cmac_h2c_tkeep            (axis_hbm_h2c_tkeep),
+    .m_axis_cmac_h2c_tlast            (axis_hbm_h2c_tlast),
+    .m_axis_cmac_h2c_tuser_size       (axis_hbm_h2c_tuser_size),
+    .m_axis_cmac_h2c_tuser_src        (axis_hbm_h2c_tuser_src),
+    .m_axis_cmac_h2c_tuser_dst        (axis_hbm_h2c_tuser_dst),
+    .m_axis_cmac_h2c_tready           (axis_hbm_h2c_tready),
+
+    .s_axis_cmac_c2h_tvalid           (axis_hbm_c2h_tvalid),
+    .s_axis_cmac_c2h_tdata            (axis_hbm_c2h_tdata),
+    .s_axis_cmac_c2h_tkeep            (axis_hbm_c2h_tkeep),
+    .s_axis_cmac_c2h_tlast            (axis_hbm_c2h_tlast),
+    .s_axis_cmac_c2h_tuser_size       (axis_hbm_c2h_tuser_size),
+    .s_axis_cmac_c2h_tuser_src        (axis_hbm_c2h_tuser_src),
+    .s_axis_cmac_c2h_tuser_dst        (axis_hbm_c2h_tuser_dst),
+    .s_axis_cmac_c2h_tready           (axis_hbm_c2h_tready),
     
-    .axi_clk              (axis_aclk),
-    .axi_resetn           (sys_cfg_powerup_rstn),
-    .hbm_ref_clk          (ref_clk_100mhz)
+    .axi_clk                          (axis_aclk),
+    .axi_rstn                         (sys_cfg_powerup_rstn),
+    .hbm_ref_clk                      (ref_clk_100mhz)
   );
 
   generate for (genvar i = 0; i < NUM_CMAC_PORT; i++) begin: cmac_port
@@ -975,23 +1030,23 @@ module open_nic_shell #(
     .s_axil_rresp                     (axil_box0_rresp),
     .s_axil_rready                    (axil_box0_rready),
 
-    .s_axis_qdma_h2c_tvalid           (axis_qdma_h2c_tvalid),
-    .s_axis_qdma_h2c_tdata            (axis_qdma_h2c_tdata),
-    .s_axis_qdma_h2c_tkeep            (axis_qdma_h2c_tkeep),
-    .s_axis_qdma_h2c_tlast            (axis_qdma_h2c_tlast),
-    .s_axis_qdma_h2c_tuser_size       (axis_qdma_h2c_tuser_size),
-    .s_axis_qdma_h2c_tuser_src        (axis_qdma_h2c_tuser_src),
-    .s_axis_qdma_h2c_tuser_dst        (axis_qdma_h2c_tuser_dst),
-    .s_axis_qdma_h2c_tready           (axis_qdma_h2c_tready),
-
-    .m_axis_qdma_c2h_tvalid           (axis_qdma_c2h_tvalid),
-    .m_axis_qdma_c2h_tdata            (axis_qdma_c2h_tdata),
-    .m_axis_qdma_c2h_tkeep            (axis_qdma_c2h_tkeep),
-    .m_axis_qdma_c2h_tlast            (axis_qdma_c2h_tlast),
-    .m_axis_qdma_c2h_tuser_size       (axis_qdma_c2h_tuser_size),
-    .m_axis_qdma_c2h_tuser_src        (axis_qdma_c2h_tuser_src),
-    .m_axis_qdma_c2h_tuser_dst        (axis_qdma_c2h_tuser_dst),
-    .m_axis_qdma_c2h_tready           (axis_qdma_c2h_tready),
+    .s_axis_qdma_h2c_tvalid           (axis_hbm_h2c_tvalid),
+    .s_axis_qdma_h2c_tdata            (axis_hbm_h2c_tdata),
+    .s_axis_qdma_h2c_tkeep            (axis_hbm_h2c_tkeep),
+    .s_axis_qdma_h2c_tlast            (axis_hbm_h2c_tlast),
+    .s_axis_qdma_h2c_tuser_size       (axis_hbm_h2c_tuser_size),
+    .s_axis_qdma_h2c_tuser_src        (axis_hbm_h2c_tuser_src),
+    .s_axis_qdma_h2c_tuser_dst        (axis_hbm_h2c_tuser_dst),
+    .s_axis_qdma_h2c_tready           (axis_hbm_h2c_tready),
+
+    .m_axis_qdma_c2h_tvalid           (axis_hbm_c2h_tvalid),
+    .m_axis_qdma_c2h_tdata            (axis_hbm_c2h_tdata),
+    .m_axis_qdma_c2h_tkeep            (axis_hbm_c2h_tkeep),
+    .m_axis_qdma_c2h_tlast            (axis_hbm_c2h_tlast),
+    .m_axis_qdma_c2h_tuser_size       (axis_hbm_c2h_tuser_size),
+    .m_axis_qdma_c2h_tuser_src        (axis_hbm_c2h_tuser_src),
+    .m_axis_qdma_c2h_tuser_dst        (axis_hbm_c2h_tuser_dst),
+    .m_axis_qdma_c2h_tready           (axis_hbm_c2h_tready),
 
     .m_axis_adap_tx_250mhz_tvalid     (axis_adap_tx_250mhz_tvalid),
     .m_axis_adap_tx_250mhz_tdata      (axis_adap_tx_250mhz_tdata),
