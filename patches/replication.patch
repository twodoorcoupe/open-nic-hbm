diff --git a/script/build.tcl b/script/build.tcl
index a24c70a..9235c01 100644
--- a/script/build.tcl
+++ b/script/build.tcl
@@ -119,6 +119,8 @@ array set design_params {
     -num_qdma         1
     -num_queue        512
     -num_cmac_port    1
+    -num_nodes        2
+    -bucket_size      1024
 }
 set design_params(-build_timestamp) [clock format [clock seconds] -format %m%d%H%M]
 
diff --git a/src/hbm_subsystem/build.tcl b/src/hbm_subsystem/build.tcl
new file mode 100644
index 0000000..b50577f
--- /dev/null
+++ b/src/hbm_subsystem/build.tcl
@@ -0,0 +1,2 @@
+    read_verilog -quiet [glob -nocomplain -directory $module_dir/memory_controller "*.{v,vh}"]
+    read_verilog -quiet -sv [glob -nocomplain -directory $module_dir/memory_controller "*.sv"]
\ No newline at end of file
diff --git a/src/hbm_subsystem/cuckoo_hash.sv b/src/hbm_subsystem/cuckoo_hash.sv
new file mode 100644
index 0000000..fa260e4
--- /dev/null
+++ b/src/hbm_subsystem/cuckoo_hash.sv
@@ -0,0 +1,622 @@
+import metadata_pkg::*;
+
+module cuckoo_hash # (
+  parameter int NUM_FUNCTIONS  = 4,
+  parameter int MAX_KICKS      = 4,
+  parameter int BUCKET_SIZE    = 1024,
+  parameter int DATA_WIDTH     = 512,
+  parameter int KEEP_WIDTH     = DATA_WIDTH / 8,
+  parameter int HASH_WIDTH     = 34 - $clog2(BUCKET_SIZE),
+  parameter int CMD_WIDTH      = 80,
+  parameter logic [HASH_WIDTH-1:0] HASH_MATRIX [NUM_FUNCTIONS][KEY_WIDTH-1:0] = '{default: '0}
+) (
+  input  logic clk,
+  input  logic rstn,
+
+  input  logic                  s_axis_tvalid,
+  input  logic [DATA_WIDTH-1:0] s_axis_tdata,
+  input  logic [KEEP_WIDTH-1:0] s_axis_tkeep,
+  input  logic                  s_axis_tuser,
+  input  logic                  s_axis_tlast,
+  output logic                  s_axis_tready,
+
+  input  st_metadata            metadata_in,
+  input  logic                  metadata_in_valid,
+
+  output logic                  m_axis_tvalid,
+  output logic [DATA_WIDTH-1:0] m_axis_tdata,
+  output logic [KEEP_WIDTH-1:0] m_axis_tkeep,
+  output logic                  m_axis_tuser,
+  output logic                  m_axis_tlast,
+  input  logic                  m_axis_tready,
+
+  output st_metadata            metadata_out,
+  output logic                  metadata_out_valid,
+
+  input  logic                  s_axis_dm_tvalid,
+  input  logic [DATA_WIDTH-1:0] s_axis_dm_tdata,
+  input  logic [KEEP_WIDTH-1:0] s_axis_dm_tkeep,
+  input  logic                  s_axis_dm_tlast,
+  output logic                  s_axis_dm_tready,
+
+  output logic                  m_axis_dm_tvalid,
+  output logic [DATA_WIDTH-1:0] m_axis_dm_tdata,
+  output logic [KEEP_WIDTH-1:0] m_axis_dm_tkeep,
+  output logic                  m_axis_dm_tlast,
+  input  logic                  m_axis_dm_tready,
+
+  output logic                  m_axis_dm_mm2s_cmd_tvalid,
+  output logic  [CMD_WIDTH-1:0] m_axis_dm_mm2s_cmd_tdata,
+  input  logic                  m_axis_dm_mm2s_cmd_tready,
+
+  output logic                  m_axis_dm_s2mm_cmd_tvalid,
+  output logic  [CMD_WIDTH-1:0] m_axis_dm_s2mm_cmd_tdata,
+  input  logic                  m_axis_dm_s2mm_cmd_tready,
+
+  output logic           [33:0] m_axi_araddr   [NUM_FUNCTIONS],
+  output logic            [1:0] m_axi_arburst  [NUM_FUNCTIONS],
+  output logic            [3:0] m_axi_arcache  [NUM_FUNCTIONS],
+  output logic            [3:0] m_axi_arid     [NUM_FUNCTIONS],
+  output logic            [3:0] m_axi_arlen    [NUM_FUNCTIONS],
+  output logic            [1:0] m_axi_arlock   [NUM_FUNCTIONS],
+  output logic            [2:0] m_axi_arprot   [NUM_FUNCTIONS],
+  input  logic                  m_axi_arready  [NUM_FUNCTIONS],
+  output logic            [2:0] m_axi_arsize   [NUM_FUNCTIONS],
+  output logic                  m_axi_arvalid  [NUM_FUNCTIONS],
+  output logic           [33:0] m_axi_awaddr   [NUM_FUNCTIONS],
+  output logic            [1:0] m_axi_awburst  [NUM_FUNCTIONS],
+  output logic            [3:0] m_axi_awcache  [NUM_FUNCTIONS],
+  output logic            [3:0] m_axi_awid     [NUM_FUNCTIONS],
+  output logic            [3:0] m_axi_awlen    [NUM_FUNCTIONS],
+  output logic            [1:0] m_axi_awlock   [NUM_FUNCTIONS],
+  output logic            [2:0] m_axi_awprot   [NUM_FUNCTIONS],
+  input  logic                  m_axi_awready  [NUM_FUNCTIONS],
+  output logic            [2:0] m_axi_awsize   [NUM_FUNCTIONS],
+  output logic                  m_axi_awvalid  [NUM_FUNCTIONS],
+  input  logic            [3:0] m_axi_bid      [NUM_FUNCTIONS],
+  output logic                  m_axi_bready   [NUM_FUNCTIONS],
+  input  logic            [1:0] m_axi_bresp    [NUM_FUNCTIONS],
+  input  logic                  m_axi_bvalid   [NUM_FUNCTIONS],
+  input  logic          [255:0] m_axi_rdata    [NUM_FUNCTIONS],
+  input  logic            [3:0] m_axi_rid      [NUM_FUNCTIONS],
+  input  logic                  m_axi_rlast    [NUM_FUNCTIONS],
+  output logic                  m_axi_rready   [NUM_FUNCTIONS],
+  input  logic            [1:0] m_axi_rresp    [NUM_FUNCTIONS],
+  input  logic                  m_axi_rvalid   [NUM_FUNCTIONS],
+  output logic          [255:0] m_axi_wdata    [NUM_FUNCTIONS],
+  output logic                  m_axi_wlast    [NUM_FUNCTIONS],
+  input  logic                  m_axi_wready   [NUM_FUNCTIONS],
+  output logic           [31:0] m_axi_wstrb    [NUM_FUNCTIONS],
+  output logic                  m_axi_wvalid   [NUM_FUNCTIONS]
+);
+  localparam int FIFO_DEPTH       = 2 * BUCKET_SIZE * 8 / DATA_WIDTH;
+  localparam int ADDRESS_SHIFT    = $clog2(BUCKET_SIZE);
+  localparam int HASH_COUNT_WIDTH = $clog2(NUM_FUNCTIONS);
+  localparam int KICK_COUNT_WIDTH = $clog2(MAX_KICKS);
+  localparam logic [22:0] DM_BTT  = BUCKET_SIZE;
+
+  logic                  axis_buffer_in_tvalid;
+  logic [DATA_WIDTH-1:0] axis_buffer_in_tdata;
+  logic [KEEP_WIDTH-1:0] axis_buffer_in_tkeep;
+  logic                  axis_buffer_in_tlast;
+  logic                  axis_buffer_in_tready;
+
+  logic                  axis_buffer_out_tvalid;
+  logic [DATA_WIDTH-1:0] axis_buffer_out_tdata;
+  logic [KEEP_WIDTH-1:0] axis_buffer_out_tkeep;
+  logic                  axis_buffer_out_tlast;
+  logic                  axis_buffer_out_tready;
+
+  xpm_fifo_axis #(
+    .FIFO_DEPTH               (FIFO_DEPTH),
+    .TDATA_WIDTH              (DATA_WIDTH)
+  ) xpm_fifo_axis_inst (
+    .m_axis_tvalid            (axis_buffer_out_tvalid),
+    .m_axis_tready            (axis_buffer_out_tready),
+    .m_axis_tdata             (axis_buffer_out_tdata),
+    .m_axis_tkeep             (axis_buffer_out_tkeep),
+    .m_axis_tdest             (),
+    .m_axis_tid               (),
+    .m_axis_tstrb             (),
+    .m_axis_tuser             (),
+    .m_axis_tlast             (axis_buffer_out_tlast),
+
+    .s_axis_tvalid            (axis_buffer_in_tvalid),
+    .s_axis_tready            (axis_buffer_in_tready),
+    .s_axis_tdata             (axis_buffer_in_tdata),
+    .s_axis_tkeep             (axis_buffer_in_tkeep),
+    .s_axis_tdest             (1'b0),
+    .s_axis_tid               (1'b0),
+    .s_axis_tstrb             ('0),
+    .s_axis_tuser             (1'b0),
+    .s_axis_tlast             (axis_buffer_in_tlast),
+
+    .injectsbiterr_axis       (1'b0),
+    .injectdbiterr_axis       (1'b0),
+    .m_aclk                   (clk),
+    .s_aclk                   (clk),
+    .s_aresetn                (rstn)
+  );
+
+  typedef enum logic [2:0] {IDLE, CHECK_READ, CHECK_WRITE, READ, WRITE, SWAP, RECHECK, ERROR} state_e;
+  typedef enum logic [2:0] {BUF_IN_IDLE, BUF_IN_FILL, BUF_IN_FILL_FROM_DM, BUF_IN_DONE} buf_in_state_e;
+  typedef enum logic [2:0] {BUF_OUT_IDLE, BUF_OUT_EMPTY, BUF_OUT_EMPTY_READ_CMD, BUF_OUT_EMPTY_TO_DM, BUF_OUT_DONE} buf_out_state_e;
+  typedef enum logic [2:0] {DM_IDLE, DM_CMD_READ, DM_READ, DM_CMD_WRITE, DM_WRITE, DM_DONE} dm_state_e;
+  typedef enum logic [2:0] {HBM_READ_IDLE, HBM_READ_ADDRESS, HBM_READ, HBM_READ_DONE} hbm_read_state_e;
+  typedef enum logic [2:0] {HBM_WRITE_IDLE, HBM_WRITE_ADDRESS, HBM_WRITE, HBM_WRITE_DONE} hbm_write_state_e;
+
+  state_e                       state,                              state_next;
+  buf_in_state_e                buf_in_state,                       buf_in_state_next;
+  buf_out_state_e               buf_out_state,                      buf_out_state_next;
+  dm_state_e                    dm_state,                           dm_state_next;
+  hbm_read_state_e              hbm_read_state [NUM_FUNCTIONS],     hbm_read_state_next [NUM_FUNCTIONS];
+  hbm_write_state_e             hbm_write_state [NUM_FUNCTIONS],    hbm_write_state_next [NUM_FUNCTIONS];
+  logic                  [31:0] stored_dirty [NUM_FUNCTIONS],       stored_dirty_next [NUM_FUNCTIONS];
+  logic         [KEY_WIDTH-1:0] stored_keys [NUM_FUNCTIONS],        stored_keys_next [NUM_FUNCTIONS];
+  logic        [HASH_WIDTH-1:0] current_addresses [NUM_FUNCTIONS],  current_addresses_next [NUM_FUNCTIONS];
+  logic         [KEY_WIDTH-1:0] current_key,                        current_key_next;
+  logic        [HASH_WIDTH-1:0] address,                            address_next;
+  logic  [KICK_COUNT_WIDTH-1:0] kick_count,                         kick_count_next;
+
+  logic start_hbm_read;
+  logic start_hbm_write;
+  logic start_dm_read;
+  logic start_dm_write;
+  logic start_dm_swap;
+  logic start_buf_in;
+  logic start_buf_in_from_dm;
+  logic start_buf_out;
+  logic start_buf_out_read_cmd;
+  logic start_buf_out_to_dm;
+  logic stop_hbm_read;
+  logic stop_hbm_write;
+  logic stop_dm;
+  logic stop_buf_in;
+  logic stop_buf_out;
+
+  st_metadata metadata_buf, metadata_buf_next;
+
+  function automatic logic [HASH_WIDTH-1:0] hash (
+    input logic  [KEY_WIDTH-1:0] key,
+    input logic [HASH_WIDTH-1:0] matrix [KEY_WIDTH-1:0]
+  );
+    logic [HASH_WIDTH-1:0] accumulator = '0;
+    for (int i = 0; i < KEY_WIDTH; i = i + 1)
+        if (key[i])
+            accumulator ^= matrix[i];
+    return accumulator;
+  endfunction
+
+  function automatic logic hbm_read_done (
+    input hbm_read_state_e state [NUM_FUNCTIONS]
+  );
+    for (int i = 0; i < NUM_FUNCTIONS; i++)
+      if (state[i] != HBM_READ_DONE)
+        return 1'b0;
+    return 1'b1;
+  endfunction
+
+  function automatic logic hbm_write_done (
+    input hbm_write_state_e state [NUM_FUNCTIONS]
+  );
+    for (int i = 0; i < NUM_FUNCTIONS; i++)
+      if (state[i] != HBM_WRITE_DONE)
+        return 1'b0;
+    return 1'b1;
+  endfunction
+
+  function automatic logic no_collisions (
+    input  logic                  read,
+    input  logic           [31:0] stored_dirty [NUM_FUNCTIONS],
+    input  logic  [KEY_WIDTH-1:0] stored_keys [NUM_FUNCTIONS],
+    input  logic [HASH_WIDTH-1:0] current_addresses [NUM_FUNCTIONS],
+    input  logic  [KEY_WIDTH-1:0] current_key,
+    output logic [HASH_WIDTH-1:0] address
+  );
+    logic read_possible;
+    logic write_possible;
+    for (int i = 0; i < NUM_FUNCTIONS; i++) begin
+      read_possible = stored_dirty[i] == DIRTY_TAG && stored_keys[i] == current_key;
+      write_possible = stored_dirty[i] != DIRTY_TAG || stored_keys[i] == current_key;
+      if (read && read_possible || !read && write_possible) begin
+        address = current_addresses[i];
+        return 1'b1;
+      end
+    end
+    address = '0;
+    return 1'b0;
+  endfunction
+
+  always_ff @(posedge clk) begin
+    if (!rstn) begin
+      state         <= IDLE;
+      buf_in_state  <= BUF_IN_IDLE;
+      buf_out_state <= BUF_OUT_IDLE;
+      dm_state      <= DM_IDLE;
+      current_key   <= '0;
+      address       <= '0;
+      kick_count    <= '0;
+      metadata_buf  <= '0;
+      for (int i = 0; i < NUM_FUNCTIONS; i++) begin
+        hbm_read_state[i]     <= HBM_READ_IDLE;
+        hbm_write_state[i]    <= HBM_WRITE_IDLE;
+        stored_dirty[i]       <= '0;
+        stored_keys[i]        <= '0;
+        current_addresses[i]  <= '0;
+      end
+    end
+    else begin
+      state         <= state_next;
+      buf_in_state  <= buf_in_state_next;
+      buf_out_state <= buf_out_state_next;
+      dm_state      <= dm_state_next;
+      current_key   <= current_key_next;
+      address       <= address_next;
+      kick_count    <= kick_count_next;
+      metadata_buf  <= metadata_buf_next;
+      for (int i = 0; i < NUM_FUNCTIONS; i++) begin
+        hbm_read_state[i]     <= hbm_read_state_next[i];
+        hbm_write_state[i]    <= hbm_write_state_next[i];
+        stored_dirty[i]       <= stored_dirty_next[i];
+        stored_keys[i]        <= stored_keys_next[i];
+        current_addresses[i]  <= current_addresses_next[i];
+      end
+    end
+  end
+
+  // Main state machine
+  always_comb begin
+    start_hbm_read          = 1'b0;
+    start_hbm_write         = 1'b0;
+    start_dm_read           = 1'b0;
+    start_dm_write          = 1'b0;
+    start_dm_swap           = 1'b0;
+    start_buf_in            = 1'b0;
+    start_buf_out           = 1'b0;
+    start_buf_out_read_cmd  = 1'b0;
+    stop_hbm_read           = 1'b0;
+    stop_hbm_write          = 1'b0;
+    stop_dm                 = 1'b0;
+    stop_buf_in             = 1'b0;
+    stop_buf_out            = 1'b0;
+    state_next              = state;
+    current_key_next        = current_key;
+    current_addresses_next  = current_addresses;
+    address_next            = address;
+    kick_count_next         = kick_count;
+    metadata_buf_next       = metadata_buf;
+    metadata_out_valid      = 1'b0;
+    metadata_out            = '0;
+    for (int i = 0; i < NUM_FUNCTIONS; i++)
+      current_addresses_next[i] = current_addresses_next[i];
+    case (state)
+      IDLE: begin
+        start_buf_in   = 1'b1;
+        stop_buf_out   = 1'b1;
+        stop_hbm_read  = 1'b1;
+        stop_hbm_write = 1'b1;
+        stop_dm        = 1'b1;
+        if (metadata_in_valid) begin
+          metadata_buf_next = metadata_in;
+          if (metadata_in.opcode == metadata_pkg::READ)
+            state_next = CHECK_READ;
+          else
+            state_next = CHECK_WRITE;
+          current_key_next = metadata_in.key;
+          for (int i = 0; i < NUM_FUNCTIONS; i++)
+            current_addresses_next[i] = hash(current_key_next, HASH_MATRIX[i]);
+        end
+      end
+      CHECK_READ: begin
+        stop_buf_in            = 1'b1;
+        start_buf_out_read_cmd = 1'b1;
+        start_hbm_read         = 1'b1;
+        if (hbm_read_done(hbm_read_state)) begin
+          stop_buf_out = 1'b1;
+          if (no_collisions(1'b1, stored_dirty, stored_keys, current_addresses, current_key, address_next))
+            state_next = READ;
+          else
+            state_next = ERROR;
+        end
+      end
+      CHECK_WRITE: begin
+        start_hbm_read = 1'b1;
+        if (hbm_read_done(hbm_read_state) && buf_in_state == BUF_IN_DONE)
+          if (no_collisions(1'b0, stored_dirty, stored_keys, current_addresses, current_key, address_next))
+            state_next = WRITE;
+          else
+            state_next = SWAP;
+      end
+      READ: begin
+        stop_hbm_read         = 1'b1;
+        stop_buf_in           = 1'b1;
+        start_buf_out         = 1'b1;
+        start_dm_read         = 1'b1;
+        if (dm_state == DM_DONE) begin
+          state_next = IDLE;
+          // Assume meta fifo is not full
+          metadata_out_valid = 1'b1;
+          metadata_out       = metadata_buf;
+        end
+      end
+      WRITE: begin
+        stop_hbm_read         = 1'b1;
+        stop_buf_in           = 1'b1;
+        start_dm_write        = 1'b1;
+        //start_hbm_write       = 1'b1;
+        if (dm_state == DM_DONE/* && hbm_write_done(hbm_write_state)*/) begin
+          state_next = IDLE;
+          // Assume meta fifo is not full
+          metadata_out_valid = 1'b1;
+          metadata_out       = metadata_buf;
+        end
+      end
+      SWAP: begin
+        stop_hbm_read         = 1'b1;
+        stop_buf_in           = 1'b1;
+        start_dm_swap         = 1'b1;
+        if (dm_state == DM_DONE) begin
+          state_next       = RECHECK;
+          kick_count_next  = kick_count + 1;
+          current_key_next = stored_keys[kick_count[HASH_COUNT_WIDTH-1:0]];
+          for (int i = 0; i < NUM_FUNCTIONS; i++)
+            current_addresses_next[i] = hash(current_key_next, HASH_MATRIX[i]);
+        end
+      end
+      RECHECK: begin
+        stop_dm        = 1'b1;
+        stop_buf_in    = 1'b1;
+        stop_buf_out   = 1'b1;
+        start_hbm_read = 1'b1;
+        if (hbm_read_done(hbm_read_state))
+          if (no_collisions(1'b0, stored_dirty, stored_keys, current_addresses, current_key, address_next))
+            state_next = WRITE;
+          else
+            if (kick_count == MAX_KICKS - 1)
+              state_next = ERROR;
+            else
+              state_next = SWAP;
+      end
+      ERROR: begin
+        state_next = IDLE;
+        // Assume meta fifo is not full
+        metadata_out_valid = 1'b1;
+        metadata_out       = metadata_buf;
+        // FIXME: Read errors will block everything
+      end
+    endcase
+  end
+
+  // Buffer state machine
+  always_comb begin
+    buf_in_state_next      = buf_in_state;
+    buf_out_state_next     = buf_out_state;
+    axis_buffer_in_tvalid  = 1'b0;
+    axis_buffer_in_tdata   =   '0;
+    axis_buffer_in_tkeep   =   '0;
+    axis_buffer_in_tlast   = 1'b0;
+    axis_buffer_out_tready = 1'b0;
+    m_axis_tvalid          = 1'b0;
+    m_axis_tdata           =   '0;
+    m_axis_tkeep           =   '0;
+    m_axis_tuser           = 1'b0;
+    m_axis_tlast           = 1'b0;
+    s_axis_tready          = 1'b0;
+    m_axis_dm_tvalid       = 1'b0;
+    m_axis_dm_tdata        =   '0;
+    m_axis_dm_tkeep        =   '0;
+    m_axis_dm_tlast        = 1'b0;
+    s_axis_dm_tready       = 1'b0;
+    case (buf_in_state)
+      BUF_IN_IDLE: begin
+        if (start_buf_in)
+          buf_in_state_next = BUF_IN_FILL;
+        if (start_buf_in_from_dm)
+          buf_in_state_next = BUF_IN_FILL_FROM_DM;
+      end
+      BUF_IN_FILL: begin
+        axis_buffer_in_tvalid = s_axis_tvalid;
+        axis_buffer_in_tdata  = s_axis_tdata;
+        axis_buffer_in_tkeep  = s_axis_tkeep;
+        axis_buffer_in_tlast  = s_axis_tlast;
+        s_axis_tready         = axis_buffer_in_tready;
+        if (s_axis_tlast && s_axis_tvalid && s_axis_tready)
+          buf_in_state_next = BUF_IN_DONE;
+      end
+      BUF_IN_FILL_FROM_DM: begin
+        axis_buffer_in_tvalid = s_axis_dm_tvalid;
+        axis_buffer_in_tdata  = s_axis_dm_tdata;
+        axis_buffer_in_tkeep  = s_axis_dm_tkeep;
+        axis_buffer_in_tlast  = s_axis_dm_tlast;
+        s_axis_dm_tready      = axis_buffer_in_tready;
+        if (s_axis_dm_tlast && s_axis_dm_tvalid && s_axis_dm_tready)
+          buf_in_state_next = BUF_IN_DONE;
+      end
+      BUF_IN_DONE: begin
+        if (stop_buf_in)
+          buf_in_state_next = BUF_IN_IDLE;
+      end
+    endcase
+    case (buf_out_state)
+      BUF_OUT_IDLE: begin
+        if (start_buf_out)
+          buf_out_state_next = BUF_OUT_EMPTY;
+        if (start_buf_out_read_cmd)
+          buf_out_state_next = BUF_OUT_EMPTY_READ_CMD;
+        if (start_buf_out_to_dm)
+          buf_out_state_next = BUF_OUT_EMPTY_TO_DM;
+      end
+      BUF_OUT_EMPTY: begin
+        m_axis_tvalid           = axis_buffer_out_tvalid;
+        m_axis_tdata            = axis_buffer_out_tdata;
+        m_axis_tkeep            = axis_buffer_out_tkeep;
+        m_axis_tlast            = axis_buffer_out_tlast;
+        axis_buffer_out_tready  = m_axis_tready;
+        if (axis_buffer_out_tlast && axis_buffer_out_tvalid && axis_buffer_out_tready)
+          buf_out_state_next = BUF_OUT_DONE;
+      end
+      // Used to remove the read request packet from the buffer
+      BUF_OUT_EMPTY_READ_CMD: begin
+        axis_buffer_out_tready  = 1'b1;
+        if (axis_buffer_out_tlast && axis_buffer_out_tvalid && axis_buffer_out_tready)
+          buf_out_state_next = BUF_OUT_DONE;
+      end
+      BUF_OUT_EMPTY_TO_DM: begin
+        m_axis_dm_tvalid        = axis_buffer_out_tvalid;
+        m_axis_dm_tdata         = axis_buffer_out_tdata;
+        m_axis_dm_tkeep         = axis_buffer_out_tkeep;
+        m_axis_dm_tlast         = axis_buffer_out_tlast;
+        axis_buffer_out_tready  = m_axis_dm_tready;
+        if (axis_buffer_out_tlast && axis_buffer_out_tvalid && axis_buffer_out_tready)
+          buf_out_state_next = BUF_OUT_DONE;
+      end
+      BUF_OUT_DONE: begin
+        if (stop_buf_out)
+          buf_out_state_next = BUF_OUT_IDLE;
+      end
+    endcase
+  end
+
+  // Datamover state machine
+  always_comb begin
+    dm_state_next             = dm_state;
+    start_buf_in_from_dm      = 1'b0;
+    start_buf_out_to_dm       = 1'b0;
+    m_axis_dm_s2mm_cmd_tvalid = 1'b0;
+    m_axis_dm_s2mm_cmd_tdata  =   '0;
+    m_axis_dm_mm2s_cmd_tvalid = 1'b0;
+    m_axis_dm_mm2s_cmd_tdata  =   '0;
+    case (dm_state)
+      DM_IDLE: begin
+        if (start_dm_read || start_dm_swap)
+          dm_state_next = DM_CMD_READ;
+        else if (start_dm_write)
+          dm_state_next = DM_CMD_WRITE;
+      end
+      DM_CMD_READ: begin
+        start_buf_in_from_dm = 1'b1;
+        m_axis_dm_mm2s_cmd_tdata  = {8'b0, 6'b0, address, 10'h0, 1'b0, 1'b1, 6'b0, 1'b1, DM_BTT};
+        m_axis_dm_mm2s_cmd_tvalid = 1'b1;
+        if (m_axis_dm_mm2s_cmd_tready)
+          if (start_dm_swap)
+            dm_state_next = DM_CMD_WRITE;
+          else
+            dm_state_next = DM_READ;
+      end
+      DM_READ: begin
+        if (buf_out_state == BUF_OUT_DONE)
+          dm_state_next = DM_DONE;
+      end
+      DM_CMD_WRITE: begin
+        start_buf_out_to_dm = 1'b1;
+        m_axis_dm_s2mm_cmd_tdata  = {8'b0, 6'b0, address, 10'h0, 1'b0, 1'b1, 6'b0, 1'b1, DM_BTT};
+        m_axis_dm_s2mm_cmd_tvalid = 1'b1;
+        if (m_axis_dm_s2mm_cmd_tready)
+          dm_state_next = DM_WRITE;
+      end
+      DM_WRITE: begin
+        if (buf_out_state == BUF_OUT_DONE)
+          if (start_dm_swap)
+            dm_state_next = DM_READ;
+          else
+            dm_state_next = DM_DONE;
+      end
+      DM_DONE: begin
+        if (stop_dm)
+          dm_state_next = DM_IDLE;
+      end
+    endcase
+  end
+
+  // HBM state machine
+  genvar i;
+  generate
+    for (i = 0; i < NUM_FUNCTIONS; i++) begin
+      always_comb begin
+        hbm_read_state_next[i]  = hbm_read_state[i];
+        hbm_write_state_next[i] = hbm_write_state[i];
+        stored_dirty_next[i]    = stored_dirty[i];
+        stored_keys_next[i]     = stored_keys[i];
+        m_axi_araddr[i]         =  64'b0;
+        m_axi_arburst[i]        =   2'b1;    // Incrementing burst
+        m_axi_arcache[i]        =   4'b0;    // Non-bufferable non-cacheable
+        m_axi_arprot[i]         =   3'b0;    // Unpriviliged secure data
+        m_axi_arid[i]           =   4'b0;
+        m_axi_arlen[i]          =   4'b0;    // 1 beat transfer
+        m_axi_arlock[i]         =   2'b0;    // Normal accesses
+        m_axi_arsize[i]         =   3'b100;  // 16 bytes transfer
+        m_axi_arvalid[i]        =   1'b0;
+        m_axi_awaddr[i]         =  64'b0;
+        m_axi_awburst[i]        =   2'b1;    // Incrementing burst
+        m_axi_awcache[i]        =   4'b0;    // Non-bufferable non-cacheable
+        m_axi_awprot[i]         =   3'b0;    // Unpriviliged secure data
+        m_axi_awid[i]           =   4'b0;
+        m_axi_awlen[i]          =   4'b0;    // 1 beat transfer
+        m_axi_awlock[i]         =   2'b0;    // Normal accesses
+        m_axi_awsize[i]         =   3'b010;  // 4 bytes transfer
+        m_axi_awvalid[i]        =   1'b0;
+        m_axi_bready[i]         =   1'b1;
+        m_axi_rready[i]         =   1'b0;
+        m_axi_wdata[i]          = 256'b0;
+        m_axi_wlast[i]          =   1'b1;
+        m_axi_wstrb[i]          =  32'b1;
+        m_axi_wvalid[i]         =   1'b0;
+        case (hbm_read_state[i])
+          HBM_READ_IDLE: begin
+            if (start_hbm_read)
+              hbm_read_state_next[i] = HBM_READ_ADDRESS;
+          end
+          HBM_READ_ADDRESS: begin
+            m_axi_araddr[i]   = current_addresses[i] << ADDRESS_SHIFT;
+            m_axi_arvalid[i]  = 1'b1;
+            if (m_axi_arready[i])
+              hbm_read_state_next[i] = HBM_READ;
+          end
+          HBM_READ: begin
+            m_axi_rready[i]   = 1'b1;
+            if (m_axi_rvalid[i]) begin
+              hbm_read_state_next[i]  = HBM_READ_DONE;
+              stored_dirty_next[i]    = m_axi_rdata[i][31:0];
+              stored_keys_next[i]     = {<< 8 {m_axi_rdata[i][32+:KEY_WIDTH]}};
+            end
+          end
+          HBM_READ_DONE: begin
+            if (stop_hbm_read)
+              hbm_read_state_next[i] = HBM_READ_IDLE;
+          end
+        endcase
+        case (hbm_write_state[i])
+          // We only intend to write the dirty byte to the correct address
+          HBM_WRITE_IDLE: begin
+            if (start_hbm_write)
+              if (address == current_addresses[i])
+                hbm_write_state_next[i] = HBM_WRITE_ADDRESS;
+              else
+                hbm_write_state_next[i] = HBM_WRITE_DONE;
+          end
+          HBM_WRITE_ADDRESS: begin
+            m_axi_awaddr[i]   = current_addresses[i] << ADDRESS_SHIFT;
+            m_axi_awvalid[i]  = 1'b1;
+            m_axi_wdata[i][0] = 1'b1;
+            m_axi_wvalid[i]   = 1'b1;
+            if (m_axi_awready[i]) begin
+              hbm_write_state_next[i] = HBM_WRITE;
+              if (m_axi_wready[i])
+                hbm_write_state_next[i] = HBM_WRITE_DONE;
+            end
+          end
+          HBM_WRITE: begin
+            m_axi_wdata[i][0] = 1'b1;
+            m_axi_wvalid[i]   = 1'b1;
+            if (m_axi_wready[i])
+              hbm_write_state_next[i] = HBM_WRITE_DONE;
+          end
+          HBM_WRITE_DONE: begin
+            if (stop_hbm_write)
+              hbm_write_state_next[i] = HBM_WRITE_IDLE;
+          end
+        endcase
+      end
+    end
+  endgenerate
+endmodule
diff --git a/src/hbm_subsystem/election_engine.sv b/src/hbm_subsystem/election_engine.sv
new file mode 100644
index 0000000..e6b6c49
--- /dev/null
+++ b/src/hbm_subsystem/election_engine.sv
@@ -0,0 +1,356 @@
+import metadata_pkg::*; 
+
+module election_engine #(
+  parameter int MAX_NODES   = 32,
+  parameter int FIFO_DEPTH  = 16,
+  parameter int TIMER_WIDTH = 25,  // ~134ms
+  parameter int SEED        = 32'hdeadbeef,
+  parameter logic [TIMER_WIDTH-1:0] TAP_MASK = 25'h1200000,
+  parameter logic            [31:0] NODE_IP  = 0
+) (
+  input  logic        axi_aclk,
+  input  logic        axi_rstn,
+
+  input  logic [31:0] s_axi_awaddr,
+  input  logic        s_axi_awvalid,
+  output logic        s_axi_awready,
+  input  logic [31:0] s_axi_wdata,
+  input  logic  [7:0] s_axi_wstrb,
+  input  logic        s_axi_wvalid,
+  output logic        s_axi_wready,
+  output logic  [1:0] s_axi_bresp,
+  output logic        s_axi_bvalid,
+  input  logic        s_axi_bready,
+  input  logic [31:0] s_axi_araddr,
+  input  logic        s_axi_arvalid,
+  output logic        s_axi_arready,
+  output logic [31:0] s_axi_rdata,
+  output logic  [1:0] s_axi_rresp,
+  output logic        s_axi_rvalid,
+  input  logic        s_axi_rready,
+
+  input  st_metadata  metadata_in,
+  input  logic        metadata_in_valid,
+
+  output st_metadata  metadata_out,
+  output logic        metadata_out_valid,
+
+  output logic        is_leader
+);
+
+typedef enum logic [7:0] { 
+  FOLLOWER,
+  CANDIDATE,
+  LEADER
+} role_e;
+
+localparam int PTR_WIDTH = $clog2(MAX_NODES);
+
+logic             [7:0] term, term_next;
+logic             [7:0] leader, leader_next;
+role_e                  role, role_next;
+logic             [7:0] num_sent;
+logic                   sending;
+logic                   majority;
+logic   [PTR_WIDTH-1:0] votes;
+logic [TIMER_WIDTH-1:0] timer_max;
+logic [TIMER_WIDTH-1:0] timer;
+logic [TIMER_WIDTH-1:0] random;
+logic                   timeout;
+logic   [PTR_WIDTH-1:0] num_nodes;
+logic   [PTR_WIDTH-1:0] table_index;
+logic            [31:0] table_ip;
+logic            [47:0] table_mac;
+st_metadata             received;
+logic                   received_process;
+logic                   received_empty;
+logic                   received_available;
+logic                   axi_write_ready;
+logic                   axi_read_ready;
+logic                   reset_timer;
+logic                   reset_votes;
+logic                   send_answer;
+logic                   send_broadcast;
+opcode_e                send_opcode;
+
+// FIXME: If master is not ready when address is num_sent, it misses the response
+assign axi_read_ready     = s_axi_arvalid && s_axi_rready;
+assign axi_write_ready    = s_axi_awvalid && s_axi_wvalid;
+assign received_available = !received_empty;
+assign is_leader          = role == LEADER;
+
+// AXI Slave logic
+always_ff @(posedge axi_aclk) begin
+  if (!axi_rstn) begin
+    s_axi_awready  <= 1'b0;
+    s_axi_wready   <= 1'b0;
+    s_axi_bvalid   <= 1'b0;
+    s_axi_bresp    <= 2'b00;
+    s_axi_arready  <= 1'b0;
+    s_axi_rdata    <= '0;
+    s_axi_rresp    <= 2'b00;
+    s_axi_rvalid   <= 1'b0;
+  end 
+  else begin
+    s_axi_awready <= axi_write_ready;
+    s_axi_wready  <= axi_write_ready;
+    s_axi_arready <= axi_read_ready;
+    if (axi_write_ready) begin
+      s_axi_bvalid <= 1'b1;
+      case (s_axi_awaddr)
+        default:;
+      endcase
+    end
+    if (axi_read_ready) begin
+      s_axi_rvalid <= 1'b1;
+      case (s_axi_araddr)
+        32'h0:   s_axi_rdata <= timer;
+        32'h1:   s_axi_rdata <= role;
+        32'h2:   s_axi_rdata <= leader;
+        32'h3:   s_axi_rdata <= term;
+        default: s_axi_rdata <= '0;
+      endcase
+    end
+  end
+end
+
+// RAFT Leader Election
+always_ff @(posedge axi_aclk) begin
+  if (!axi_rstn) begin
+    role     <= FOLLOWER;
+    term     <= 0;
+    leader   <= 0;
+  end
+  else begin
+    role     <= role_next;
+    term     <= term_next;
+    leader   <= leader_next;
+  end
+end
+
+// FIXME: Does not wait for sender to be ready
+always_comb begin
+  role_next        = role;
+  term_next        = term;
+  leader_next      = leader;
+  received_process = 1'b1;
+  reset_timer      = 1'b0;
+  reset_votes      = 1'b0;
+  send_answer      = 1'b0;
+  send_broadcast   = 1'b0;
+  send_opcode      = HEARTBEAT;
+  case (role)
+    FOLLOWER: begin
+      if (timeout) begin
+        term_next = term + 1;
+        role_next = CANDIDATE;
+      end
+      else if (received_available) begin
+        reset_timer      = 1'b1;
+        received_process = 1'b1;
+        case (received.opcode)
+          HEARTBEAT: begin
+            send_answer = 1'b1;
+            send_opcode = HEARTBEAT_ACK;
+          end
+          VOTE_REQUEST: begin
+            if (received.index > term) begin
+              term_next   = received.index;
+              leader_next = received.ip;
+              send_answer = 1'b1;
+              send_opcode = VOTE;
+            end
+          end
+        endcase
+      end
+    end
+    CANDIDATE: begin
+      if (timeout) begin
+        reset_timer    = 1'b1;
+        send_broadcast = 1'b1;
+        send_opcode    = VOTE_REQUEST;
+      end
+      else if (received_available) begin
+        case (received.opcode)
+          HEARTBEAT, VOTE_REQUEST: begin
+            if (received.index >= term) begin
+              reset_timer = 1'b1;
+              role_next   = FOLLOWER;
+              term_next   = received.index;
+              leader_next = received.ip;
+              send_answer = 1'b1;
+              if (received.opcode == VOTE_REQUEST)
+                send_opcode = VOTE;
+              else
+                send_opcode = HEARTBEAT_ACK;
+            end
+          end
+          VOTE: begin
+            if (majority) begin
+              reset_votes    = 1'b1;
+              reset_timer    = 1'b1;
+              role_next      = LEADER;
+              leader_next    = NODE_IP;
+              send_broadcast = 1'b1;
+              send_opcode    = HEARTBEAT;
+            end
+          end
+        endcase
+      end
+    end
+    LEADER: begin
+      if (timeout) begin
+        reset_timer    = 1'b1;
+        send_broadcast = 1'b1;
+        send_opcode    = HEARTBEAT;
+      end
+    end
+  endcase
+end
+
+// Timer 
+always_ff @(posedge axi_aclk) begin
+  if (!axi_rstn || reset_timer) begin
+    timer   <= 0;
+    timeout <= 1'b0;
+  end
+  else begin
+    timer   <= timer + 1;
+    timeout <= 1'b0;
+    if (timer == timer_max) begin
+      timer   <= timer;
+      timeout <= 1'b1;
+    end
+  end
+end
+
+
+// Receiver
+always_ff @(posedge axi_aclk) begin
+  if (!axi_rstn || reset_votes) begin
+    votes    <= 1;
+    majority <= 1'b0;
+  end
+  else begin
+    majority <= 1'b0;
+    if (role == CANDIDATE && metadata_in_valid && metadata_in.opcode == VOTE) begin
+      votes <= votes + 1;
+    end
+    if (votes == num_nodes / 2 + 1) begin
+      majority <= 1'b1;
+    end
+  end
+end
+
+// Sender
+always_ff @(posedge axi_aclk) begin
+  if (!axi_rstn) begin
+    metadata_out_valid <= 1'b0;
+    metadata_out       <= 0;
+    num_sent           <= 0;
+    sending            <= 1'b0;
+    table_index        <= 0;
+  end
+  else begin 
+    metadata_out_valid <= 1'b0;
+    sending            <= 1'b0;
+    table_index        <= 0;
+    if (send_answer) begin
+      metadata_out_valid  <= 1'b1;
+      metadata_out.opcode <= send_opcode;
+      metadata_out.index  <= received.index;
+      metadata_out.ip     <= received.ip;
+      metadata_out.mac    <= received.mac;
+    end
+    // Wait one cycle for IP BRAM answer
+    if (send_broadcast) begin
+      num_sent            <= 0;
+      table_index         <= 1;
+      sending             <= 1'b1;
+      metadata_out.opcode <= send_opcode;
+    end
+    if (sending && num_sent != num_nodes - 1) begin
+      num_sent            <= num_sent + 1;
+      table_index         <= table_index + 1;
+      sending             <= 1'b1;
+      metadata_out_valid  <= 1'b1;
+      metadata_out.index  <= term;
+      metadata_out.ip     <= table_ip;
+      metadata_out.mac    <= table_mac;
+    end
+  end
+end
+
+// Galois LSFR
+always_ff @(posedge axi_aclk) begin
+    if (!axi_rstn) begin
+      random    <= SEED;
+      timer_max <= SEED;
+    end
+    else begin
+      timer_max <= {1'b1, random[TIMER_WIDTH-2:0]};
+      if (reset_timer) begin
+        random <= (random >> 1) ^ (random[0] ? TAP_MASK : {TIMER_WIDTH{1'b0}});
+      end
+      // Leader should send heartbeats more often than followers expect to receive them
+      if (role == LEADER) begin
+        timer_max <= {1'b1, random[TIMER_WIDTH-2:0]} >> 2;
+      end
+    end
+end
+
+nodes_table #( 
+  .TABLE_SIZE     (MAX_NODES)
+) nodes_table_inst (
+  .aclk           (axi_aclk),
+  .rstn           (axi_rstn),
+
+  .metadata_valid (metadata_in_valid),
+  .metadata       (metadata_in),
+
+  .num_nodes      (num_nodes),
+  .index          (table_index),
+  .ip             (table_ip),
+  .mac            (table_mac)
+);
+
+// Received packets FIFO
+xpm_fifo_sync #(
+  .DOUT_RESET_VALUE    ("0"),
+  .ECC_MODE            ("no_ecc"),
+  .FIFO_MEMORY_TYPE    ("auto"),
+  .FIFO_READ_LATENCY   (1),
+  .FIFO_WRITE_DEPTH    (FIFO_DEPTH),
+  .PROG_FULL_THRESH    (FIFO_DEPTH-5),
+  .READ_DATA_WIDTH     (METADATA_WIDTH),
+  .READ_MODE           ("fwft"),
+  .WRITE_DATA_WIDTH    (METADATA_WIDTH)
+) receiver_fifo (
+  .wr_en               (metadata_in_valid),
+  .din                 (metadata_in),
+  .wr_ack              (),
+  .rd_en               (received_process),
+  .data_valid          (),
+  .dout                (received),
+  .wr_data_count       (),
+  .rd_data_count       (),
+  .empty               (received_empty),
+  .full                (),
+  .almost_empty        (),
+  .almost_full         (),
+  .overflow            (),
+  .underflow           (),
+  .prog_empty          (),
+  .prog_full           (),
+  .sleep               (1'b0),
+  .sbiterr             (),
+  .dbiterr             (),
+  .injectsbiterr       (1'b0),
+  .injectdbiterr       (1'b0),
+  .wr_clk              (axi_aclk),
+  .rst                 (~axi_rstn),
+  .rd_rst_busy         (),
+  .wr_rst_busy         ()
+);
+
+endmodule
diff --git a/src/hbm_subsystem/hbm_bd.tcl b/src/hbm_subsystem/hbm_bd.tcl
index 97fedbc..1f9a435 100644
--- a/src/hbm_subsystem/hbm_bd.tcl
+++ b/src/hbm_subsystem/hbm_bd.tcl
@@ -133,6 +133,7 @@ if { $bCheckIPs == 1 } {
 xilinx.com:ip:hbm:1.0\
 xilinx.com:ip:clk_wiz:6.0\
 xilinx.com:ip:proc_sys_reset:5.0\
+xilinx.com:ip:axi_datamover:5.1\
 xilinx.com:ip:smartconnect:1.0\
 "
 
@@ -229,15 +230,202 @@ proc create_root_design { parentCell } {
    CONFIG.WUSER_WIDTH {64} \
    ] $s_axi_hbm
 
+  set s_axis_dm_s2mm [ create_bd_intf_port -mode Slave -vlnv xilinx.com:interface:axis_rtl:1.0 s_axis_dm_s2mm ]
+  set_property -dict [ list \
+   CONFIG.FREQ_HZ {250000000} \
+   CONFIG.HAS_TKEEP {1} \
+   CONFIG.HAS_TLAST {1} \
+   CONFIG.HAS_TREADY {1} \
+   CONFIG.HAS_TSTRB {0} \
+   CONFIG.LAYERED_METADATA {undef} \
+   CONFIG.TDATA_NUM_BYTES {64} \
+   CONFIG.TDEST_WIDTH {0} \
+   CONFIG.TID_WIDTH {0} \
+   CONFIG.TUSER_WIDTH {0} \
+   ] $s_axis_dm_s2mm
+
+  set s_axis_dm_s2mm_cmd [ create_bd_intf_port -mode Slave -vlnv xilinx.com:interface:axis_rtl:1.0 s_axis_dm_s2mm_cmd ]
+  set_property -dict [ list \
+   CONFIG.FREQ_HZ {250000000} \
+   CONFIG.HAS_TKEEP {0} \
+   CONFIG.HAS_TLAST {0} \
+   CONFIG.HAS_TREADY {1} \
+   CONFIG.HAS_TSTRB {0} \
+   CONFIG.LAYERED_METADATA {undef} \
+   CONFIG.TDATA_NUM_BYTES {10} \
+   CONFIG.TDEST_WIDTH {0} \
+   CONFIG.TID_WIDTH {0} \
+   CONFIG.TUSER_WIDTH {0} \
+   ] $s_axis_dm_s2mm_cmd
+
+  set s_axis_dm_mm2s_cmd [ create_bd_intf_port -mode Slave -vlnv xilinx.com:interface:axis_rtl:1.0 s_axis_dm_mm2s_cmd ]
+  set_property -dict [ list \
+   CONFIG.FREQ_HZ {250000000} \
+   CONFIG.HAS_TKEEP {0} \
+   CONFIG.HAS_TLAST {0} \
+   CONFIG.HAS_TREADY {1} \
+   CONFIG.HAS_TSTRB {0} \
+   CONFIG.LAYERED_METADATA {undef} \
+   CONFIG.TDATA_NUM_BYTES {10} \
+   CONFIG.TDEST_WIDTH {0} \
+   CONFIG.TID_WIDTH {0} \
+   CONFIG.TUSER_WIDTH {0} \
+   ] $s_axis_dm_mm2s_cmd
+
+  set m_axis_dm_mm2s [ create_bd_intf_port -mode Master -vlnv xilinx.com:interface:axis_rtl:1.0 m_axis_dm_mm2s ]
+  set_property -dict [ list \
+   CONFIG.FREQ_HZ {250000000} \
+   ] $m_axis_dm_mm2s
+
+  set m_axis_dm_s2mm_status [ create_bd_intf_port -mode Master -vlnv xilinx.com:interface:axis_rtl:1.0 m_axis_dm_s2mm_status ]
+  set_property -dict [ list \
+   CONFIG.FREQ_HZ {250000000} \
+   ] $m_axis_dm_s2mm_status
+
+  set m_axis_dm_mm2s_status [ create_bd_intf_port -mode Master -vlnv xilinx.com:interface:axis_rtl:1.0 m_axis_dm_mm2s_status ]
+  set_property -dict [ list \
+   CONFIG.FREQ_HZ {250000000} \
+   ] $m_axis_dm_mm2s_status
+
+  set s_axi_2 [ create_bd_intf_port -mode Slave -vlnv xilinx.com:interface:aximm_rtl:1.0 s_axi_2 ]
+  set_property -dict [ list \
+   CONFIG.ADDR_WIDTH {34} \
+   CONFIG.ARUSER_WIDTH {0} \
+   CONFIG.AWUSER_WIDTH {0} \
+   CONFIG.BUSER_WIDTH {0} \
+   CONFIG.DATA_WIDTH {256} \
+   CONFIG.FREQ_HZ {250000000} \
+   CONFIG.HAS_BRESP {1} \
+   CONFIG.HAS_BURST {1} \
+   CONFIG.HAS_CACHE {0} \
+   CONFIG.HAS_LOCK {0} \
+   CONFIG.HAS_PROT {0} \
+   CONFIG.HAS_QOS {0} \
+   CONFIG.HAS_REGION {0} \
+   CONFIG.HAS_RRESP {1} \
+   CONFIG.HAS_WSTRB {1} \
+   CONFIG.ID_WIDTH {6} \
+   CONFIG.MAX_BURST_LENGTH {16} \
+   CONFIG.NUM_READ_OUTSTANDING {2} \
+   CONFIG.NUM_READ_THREADS {1} \
+   CONFIG.NUM_WRITE_OUTSTANDING {2} \
+   CONFIG.NUM_WRITE_THREADS {1} \
+   CONFIG.PROTOCOL {AXI3} \
+   CONFIG.READ_WRITE_MODE {READ_WRITE} \
+   CONFIG.RUSER_BITS_PER_BYTE {0} \
+   CONFIG.RUSER_WIDTH {0} \
+   CONFIG.SUPPORTS_NARROW_BURST {1} \
+   CONFIG.WUSER_BITS_PER_BYTE {0} \
+   CONFIG.WUSER_WIDTH {0} \
+   ] $s_axi_2
+
+  set s_axi_1 [ create_bd_intf_port -mode Slave -vlnv xilinx.com:interface:aximm_rtl:1.0 s_axi_1 ]
+  set_property -dict [ list \
+   CONFIG.ADDR_WIDTH {34} \
+   CONFIG.ARUSER_WIDTH {0} \
+   CONFIG.AWUSER_WIDTH {0} \
+   CONFIG.BUSER_WIDTH {0} \
+   CONFIG.DATA_WIDTH {256} \
+   CONFIG.FREQ_HZ {250000000} \
+   CONFIG.HAS_BRESP {1} \
+   CONFIG.HAS_BURST {1} \
+   CONFIG.HAS_CACHE {0} \
+   CONFIG.HAS_LOCK {0} \
+   CONFIG.HAS_PROT {0} \
+   CONFIG.HAS_QOS {0} \
+   CONFIG.HAS_REGION {0} \
+   CONFIG.HAS_RRESP {1} \
+   CONFIG.HAS_WSTRB {1} \
+   CONFIG.ID_WIDTH {6} \
+   CONFIG.MAX_BURST_LENGTH {16} \
+   CONFIG.NUM_READ_OUTSTANDING {2} \
+   CONFIG.NUM_READ_THREADS {1} \
+   CONFIG.NUM_WRITE_OUTSTANDING {2} \
+   CONFIG.NUM_WRITE_THREADS {1} \
+   CONFIG.PROTOCOL {AXI3} \
+   CONFIG.READ_WRITE_MODE {READ_WRITE} \
+   CONFIG.RUSER_BITS_PER_BYTE {0} \
+   CONFIG.RUSER_WIDTH {0} \
+   CONFIG.SUPPORTS_NARROW_BURST {1} \
+   CONFIG.WUSER_BITS_PER_BYTE {0} \
+   CONFIG.WUSER_WIDTH {0} \
+   ] $s_axi_1
+
+  set s_axi_3 [ create_bd_intf_port -mode Slave -vlnv xilinx.com:interface:aximm_rtl:1.0 s_axi_3 ]
+  set_property -dict [ list \
+   CONFIG.ADDR_WIDTH {34} \
+   CONFIG.ARUSER_WIDTH {0} \
+   CONFIG.AWUSER_WIDTH {0} \
+   CONFIG.BUSER_WIDTH {0} \
+   CONFIG.DATA_WIDTH {256} \
+   CONFIG.FREQ_HZ {250000000} \
+   CONFIG.HAS_BRESP {1} \
+   CONFIG.HAS_BURST {1} \
+   CONFIG.HAS_CACHE {0} \
+   CONFIG.HAS_LOCK {0} \
+   CONFIG.HAS_PROT {0} \
+   CONFIG.HAS_QOS {0} \
+   CONFIG.HAS_REGION {0} \
+   CONFIG.HAS_RRESP {1} \
+   CONFIG.HAS_WSTRB {1} \
+   CONFIG.ID_WIDTH {6} \
+   CONFIG.MAX_BURST_LENGTH {16} \
+   CONFIG.NUM_READ_OUTSTANDING {2} \
+   CONFIG.NUM_READ_THREADS {1} \
+   CONFIG.NUM_WRITE_OUTSTANDING {2} \
+   CONFIG.NUM_WRITE_THREADS {1} \
+   CONFIG.PROTOCOL {AXI3} \
+   CONFIG.READ_WRITE_MODE {READ_WRITE} \
+   CONFIG.RUSER_BITS_PER_BYTE {0} \
+   CONFIG.RUSER_WIDTH {0} \
+   CONFIG.SUPPORTS_NARROW_BURST {1} \
+   CONFIG.WUSER_BITS_PER_BYTE {0} \
+   CONFIG.WUSER_WIDTH {0} \
+   ] $s_axi_3
+
+  set s_axi_0 [ create_bd_intf_port -mode Slave -vlnv xilinx.com:interface:aximm_rtl:1.0 s_axi_0 ]
+  set_property -dict [ list \
+   CONFIG.ADDR_WIDTH {34} \
+   CONFIG.ARUSER_WIDTH {0} \
+   CONFIG.AWUSER_WIDTH {0} \
+   CONFIG.BUSER_WIDTH {0} \
+   CONFIG.DATA_WIDTH {256} \
+   CONFIG.FREQ_HZ {250000000} \
+   CONFIG.HAS_BRESP {1} \
+   CONFIG.HAS_BURST {1} \
+   CONFIG.HAS_CACHE {0} \
+   CONFIG.HAS_LOCK {0} \
+   CONFIG.HAS_PROT {0} \
+   CONFIG.HAS_QOS {0} \
+   CONFIG.HAS_REGION {0} \
+   CONFIG.HAS_RRESP {1} \
+   CONFIG.HAS_WSTRB {1} \
+   CONFIG.ID_WIDTH {6} \
+   CONFIG.MAX_BURST_LENGTH {16} \
+   CONFIG.NUM_READ_OUTSTANDING {2} \
+   CONFIG.NUM_READ_THREADS {1} \
+   CONFIG.NUM_WRITE_OUTSTANDING {2} \
+   CONFIG.NUM_WRITE_THREADS {1} \
+   CONFIG.PROTOCOL {AXI3} \
+   CONFIG.READ_WRITE_MODE {READ_WRITE} \
+   CONFIG.RUSER_BITS_PER_BYTE {0} \
+   CONFIG.RUSER_WIDTH {0} \
+   CONFIG.SUPPORTS_NARROW_BURST {1} \
+   CONFIG.WUSER_BITS_PER_BYTE {0} \
+   CONFIG.WUSER_WIDTH {0} \
+   ] $s_axi_0
+
 
   # Create ports
   set axi_resetn [ create_bd_port -dir I axi_resetn ]
   set hbm_ref_clk [ create_bd_port -dir I -type clk -freq_hz 100000000 hbm_ref_clk ]
   set axi_clk [ create_bd_port -dir I -type clk -freq_hz 250000000 axi_clk ]
   set_property -dict [ list \
-   CONFIG.ASSOCIATED_BUSIF {s_axi_hbm} \
+   CONFIG.ASSOCIATED_BUSIF {s_axi_hbm:s_axis_dm_s2mm:s_axis_dm_s2mm_cmd:s_axis_dm_mm2s_cmd:m_axis_dm_mm2s:m_axis_dm_s2mm_status:m_axis_dm_mm2s_status:s_axi_2:s_axi_1:s_axi_3:s_axi_0} \
    CONFIG.CLK_DOMAIN {hbm_bd_0_0_axi_aclk} \
  ] $axi_clk
+  set apb_complete_0 [ create_bd_port -dir O apb_complete_0 ]
+  set apb_complete_1 [ create_bd_port -dir O apb_complete_1 ]
 
   # Create instance: hbm_0, and set properties
   set hbm_0 [ create_bd_cell -type ip -vlnv xilinx.com:ip:hbm:1.0 hbm_0 ]
@@ -246,6 +434,7 @@ proc create_root_design { parentCell } {
     CONFIG.USER_AXI_INPUT_CLK1_FREQ {250} \
     CONFIG.USER_AXI_INPUT_CLK_FREQ {250} \
     CONFIG.USER_HBM_DENSITY {16GB} \
+    CONFIG.USER_MC0_REORDER_EN {false} \
     CONFIG.USER_MC0_USER_PARITY_EN {false} \
     CONFIG.USER_SAXI_00 {false} \
     CONFIG.USER_SAXI_01 {false} \
@@ -259,12 +448,12 @@ proc create_root_design { parentCell } {
     CONFIG.USER_SAXI_09 {false} \
     CONFIG.USER_SAXI_10 {false} \
     CONFIG.USER_SAXI_11 {false} \
-    CONFIG.USER_SAXI_12 {false} \
-    CONFIG.USER_SAXI_13 {false} \
-    CONFIG.USER_SAXI_14 {false} \
-    CONFIG.USER_SAXI_16 {false} \
-    CONFIG.USER_SAXI_17 {false} \
-    CONFIG.USER_SAXI_18 {false} \
+    CONFIG.USER_SAXI_12 {true} \
+    CONFIG.USER_SAXI_13 {true} \
+    CONFIG.USER_SAXI_14 {true} \
+    CONFIG.USER_SAXI_16 {true} \
+    CONFIG.USER_SAXI_17 {true} \
+    CONFIG.USER_SAXI_18 {true} \
     CONFIG.USER_SAXI_19 {false} \
     CONFIG.USER_SAXI_20 {false} \
     CONFIG.USER_SAXI_21 {false} \
@@ -301,6 +490,38 @@ proc create_root_design { parentCell } {
   # Create instance: proc_sys_reset_0, and set properties
   set proc_sys_reset_0 [ create_bd_cell -type ip -vlnv xilinx.com:ip:proc_sys_reset:5.0 proc_sys_reset_0 ]
 
+  # Create instance: axi_datamover_0, and set properties
+  set axi_datamover_0 [ create_bd_cell -type ip -vlnv xilinx.com:ip:axi_datamover:5.1 axi_datamover_0 ]
+  set_property -dict [list \
+    CONFIG.c_addr_width {34} \
+    CONFIG.c_dummy {1} \
+    CONFIG.c_enable_cache_user {false} \
+    CONFIG.c_include_mm2s_dre {false} \
+    CONFIG.c_include_s2mm_dre {false} \
+    CONFIG.c_m_axi_mm2s_data_width {512} \
+    CONFIG.c_m_axi_mm2s_id_width {0} \
+    CONFIG.c_m_axi_s2mm_data_width {512} \
+    CONFIG.c_m_axi_s2mm_id_width {0} \
+    CONFIG.c_m_axis_mm2s_tdata_width {512} \
+    CONFIG.c_mm2s_btt_used {23} \
+    CONFIG.c_mm2s_burst_size {64} \
+    CONFIG.c_mm2s_include_sf {true} \
+    CONFIG.c_s2mm_btt_used {23} \
+    CONFIG.c_s2mm_burst_size {64} \
+    CONFIG.c_s2mm_support_indet_btt {false} \
+    CONFIG.c_s_axis_s2mm_tdata_width {512} \
+    CONFIG.c_single_interface {0} \
+  ] $axi_datamover_0
+
+
+  # Create instance: smartconnect_1, and set properties
+  set smartconnect_1 [ create_bd_cell -type ip -vlnv xilinx.com:ip:smartconnect:1.0 smartconnect_1 ]
+  set_property -dict [list \
+    CONFIG.NUM_MI {1} \
+    CONFIG.NUM_SI {1} \
+  ] $smartconnect_1
+
+
   # Create instance: smartconnect_0, and set properties
   set smartconnect_0 [ create_bd_cell -type ip -vlnv xilinx.com:ip:smartconnect:1.0 smartconnect_0 ]
   set_property -dict [list \
@@ -309,14 +530,62 @@ proc create_root_design { parentCell } {
   ] $smartconnect_0
 
 
+  # Create instance: smartconnect_2, and set properties
+  set smartconnect_2 [ create_bd_cell -type ip -vlnv xilinx.com:ip:smartconnect:1.0 smartconnect_2 ]
+  set_property CONFIG.NUM_SI {1} $smartconnect_2
+
+
   # Create interface connections
   connect_bd_intf_net -intf_net S00_AXI_0_1 [get_bd_intf_ports s_axi_hbm] [get_bd_intf_pins smartconnect_0/S00_AXI]
-  connect_bd_intf_net -intf_net smartconnect_0_M00_AXI [get_bd_intf_pins smartconnect_0/M00_AXI] [get_bd_intf_pins hbm_0/SAXI_15_8HI]
+  connect_bd_intf_net -intf_net S_AXIS_MM2S_CMD_0_1 [get_bd_intf_ports s_axis_dm_mm2s_cmd] [get_bd_intf_pins axi_datamover_0/S_AXIS_MM2S_CMD]
+  connect_bd_intf_net -intf_net S_AXIS_S2MM_0_1 [get_bd_intf_ports s_axis_dm_s2mm] [get_bd_intf_pins axi_datamover_0/S_AXIS_S2MM]
+  connect_bd_intf_net -intf_net S_AXIS_S2MM_CMD_0_1 [get_bd_intf_ports s_axis_dm_s2mm_cmd] [get_bd_intf_pins axi_datamover_0/S_AXIS_S2MM_CMD]
+  connect_bd_intf_net -intf_net axi_datamover_0_M_AXIS_MM2S [get_bd_intf_ports m_axis_dm_mm2s] [get_bd_intf_pins axi_datamover_0/M_AXIS_MM2S]
+  connect_bd_intf_net -intf_net axi_datamover_0_M_AXIS_MM2S_STS [get_bd_intf_ports m_axis_dm_mm2s_status] [get_bd_intf_pins axi_datamover_0/M_AXIS_MM2S_STS]
+  connect_bd_intf_net -intf_net axi_datamover_0_M_AXIS_S2MM_STS [get_bd_intf_ports m_axis_dm_s2mm_status] [get_bd_intf_pins axi_datamover_0/M_AXIS_S2MM_STS]
+  connect_bd_intf_net -intf_net axi_datamover_0_M_AXI_MM2S [get_bd_intf_pins axi_datamover_0/M_AXI_MM2S] [get_bd_intf_pins smartconnect_2/S00_AXI]
+  connect_bd_intf_net -intf_net axi_datamover_0_M_AXI_S2MM [get_bd_intf_pins axi_datamover_0/M_AXI_S2MM] [get_bd_intf_pins smartconnect_1/S00_AXI]
+  connect_bd_intf_net -intf_net s_axi_0_1 [get_bd_intf_ports s_axi_0] [get_bd_intf_pins hbm_0/SAXI_14_8HI]
+  connect_bd_intf_net -intf_net s_axi_1_1 [get_bd_intf_ports s_axi_1] [get_bd_intf_pins hbm_0/SAXI_15_8HI]
+  connect_bd_intf_net -intf_net s_axi_2_1 [get_bd_intf_ports s_axi_2] [get_bd_intf_pins hbm_0/SAXI_17_8HI]
+  connect_bd_intf_net -intf_net s_axi_3_1 [get_bd_intf_ports s_axi_3] [get_bd_intf_pins hbm_0/SAXI_16_8HI]
+  connect_bd_intf_net -intf_net smartconnect_0_M00_AXI [get_bd_intf_pins smartconnect_0/M00_AXI] [get_bd_intf_pins hbm_0/SAXI_12_8HI]
+  connect_bd_intf_net -intf_net smartconnect_1_M00_AXI [get_bd_intf_pins smartconnect_1/M00_AXI] [get_bd_intf_pins hbm_0/SAXI_18_8HI]
+  connect_bd_intf_net -intf_net smartconnect_2_M00_AXI [get_bd_intf_pins smartconnect_2/M00_AXI] [get_bd_intf_pins hbm_0/SAXI_13_8HI]
 
   # Create port connections
   connect_bd_net -net aclk_0_1  [get_bd_ports axi_clk] \
+  [get_bd_pins hbm_0/AXI_15_ACLK] \
+  [get_bd_pins smartconnect_1/aclk] \
+  [get_bd_pins axi_datamover_0/m_axi_mm2s_aclk] \
+  [get_bd_pins axi_datamover_0/m_axis_mm2s_cmdsts_aclk] \
+  [get_bd_pins axi_datamover_0/m_axi_s2mm_aclk] \
+  [get_bd_pins axi_datamover_0/m_axis_s2mm_cmdsts_awclk] \
+  [get_bd_pins hbm_0/AXI_16_ACLK] \
   [get_bd_pins smartconnect_0/aclk] \
-  [get_bd_pins hbm_0/AXI_15_ACLK]
+  [get_bd_pins hbm_0/AXI_13_ACLK] \
+  [get_bd_pins hbm_0/AXI_14_ACLK] \
+  [get_bd_pins hbm_0/AXI_17_ACLK] \
+  [get_bd_pins hbm_0/AXI_18_ACLK] \
+  [get_bd_pins smartconnect_2/aclk] \
+  [get_bd_pins hbm_0/AXI_12_ACLK]
+  connect_bd_net -net axi_aresetn_0  [get_bd_ports axi_resetn] \
+  [get_bd_pins hbm_0/AXI_15_ARESET_N] \
+  [get_bd_pins clk_wiz_0/resetn] \
+  [get_bd_pins proc_sys_reset_0/ext_reset_in] \
+  [get_bd_pins hbm_0/AXI_16_ARESET_N] \
+  [get_bd_pins smartconnect_1/aresetn] \
+  [get_bd_pins axi_datamover_0/m_axi_mm2s_aresetn] \
+  [get_bd_pins axi_datamover_0/m_axis_s2mm_cmdsts_aresetn] \
+  [get_bd_pins axi_datamover_0/m_axi_s2mm_aresetn] \
+  [get_bd_pins axi_datamover_0/m_axis_mm2s_cmdsts_aresetn] \
+  [get_bd_pins smartconnect_0/aresetn] \
+  [get_bd_pins hbm_0/AXI_17_ARESET_N] \
+  [get_bd_pins hbm_0/AXI_18_ARESET_N] \
+  [get_bd_pins hbm_0/AXI_14_ARESET_N] \
+  [get_bd_pins hbm_0/AXI_13_ARESET_N] \
+  [get_bd_pins smartconnect_2/aresetn] \
+  [get_bd_pins hbm_0/AXI_12_ARESET_N]
   connect_bd_net -net clk_in1_0_1  [get_bd_ports hbm_ref_clk] \
   [get_bd_pins clk_wiz_0/clk_in1]
   connect_bd_net -net clk_wiz_0_clk_out1  [get_bd_pins clk_wiz_0/clk_out1] \
@@ -327,48 +596,239 @@ proc create_root_design { parentCell } {
   [get_bd_pins proc_sys_reset_0/slowest_sync_clk]
   connect_bd_net -net clk_wiz_0_locked  [get_bd_pins clk_wiz_0/locked] \
   [get_bd_pins proc_sys_reset_0/dcm_locked]
+  connect_bd_net -net hbm_0_apb_complete_0  [get_bd_pins hbm_0/apb_complete_0] \
+  [get_bd_ports apb_complete_0]
+  connect_bd_net -net hbm_0_apb_complete_1  [get_bd_pins hbm_0/apb_complete_1] \
+  [get_bd_ports apb_complete_1]
   connect_bd_net -net proc_sys_reset_0_peripheral_aresetn  [get_bd_pins proc_sys_reset_0/peripheral_aresetn] \
   [get_bd_pins hbm_0/APB_0_PRESET_N] \
   [get_bd_pins hbm_0/APB_1_PRESET_N]
-  connect_bd_net -net axi_aresetn_0  [get_bd_ports axi_resetn] \
-  [get_bd_pins hbm_0/AXI_15_ARESET_N] \
-  [get_bd_pins smartconnect_0/aresetn] \
-  [get_bd_pins clk_wiz_0/resetn] \
-  [get_bd_pins proc_sys_reset_0/ext_reset_in]
 
   # Create address segments
-  assign_bd_address -offset 0x00000000 -range 0x10000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM00] -force
-  assign_bd_address -offset 0x20000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM01] -force
-  assign_bd_address -offset 0x40000000 -range 0x10000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM02] -force
-  assign_bd_address -offset 0x60000000 -range 0x10000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM03] -force
-  assign_bd_address -offset 0x80000000 -range 0x10000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM04] -force
-  assign_bd_address -offset 0xA0000000 -range 0x10000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM05] -force
-  assign_bd_address -offset 0xC0000000 -range 0x10000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM06] -force
-  assign_bd_address -offset 0xE0000000 -range 0x10000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM07] -force
-  assign_bd_address -offset 0x000100000000 -range 0x10000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM08] -force
-  assign_bd_address -offset 0x000120000000 -range 0x10000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM09] -force
-  assign_bd_address -offset 0x000140000000 -range 0x10000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM10] -force
-  assign_bd_address -offset 0x000160000000 -range 0x10000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM11] -force
-  assign_bd_address -offset 0x000180000000 -range 0x10000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM12] -force
-  assign_bd_address -offset 0x0001A0000000 -range 0x10000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM13] -force
-  assign_bd_address -offset 0x0001C0000000 -range 0x10000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM14] -force
-  assign_bd_address -offset 0x0001E0000000 -range 0x10000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM15] -force
-  assign_bd_address -offset 0x000200000000 -range 0x10000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM16] -force
-  assign_bd_address -offset 0x000220000000 -range 0x10000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM17] -force
-  assign_bd_address -offset 0x000240000000 -range 0x10000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM18] -force
-  assign_bd_address -offset 0x000260000000 -range 0x10000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM19] -force
-  assign_bd_address -offset 0x000280000000 -range 0x10000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM20] -force
-  assign_bd_address -offset 0x0002A0000000 -range 0x10000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM21] -force
-  assign_bd_address -offset 0x0002C0000000 -range 0x10000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM22] -force
-  assign_bd_address -offset 0x0002E0000000 -range 0x10000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM23] -force
-  assign_bd_address -offset 0x000300000000 -range 0x10000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM24] -force
-  assign_bd_address -offset 0x000320000000 -range 0x10000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM25] -force
-  assign_bd_address -offset 0x000340000000 -range 0x10000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM26] -force
-  assign_bd_address -offset 0x000360000000 -range 0x10000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM27] -force
-  assign_bd_address -offset 0x000380000000 -range 0x10000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM28] -force
-  assign_bd_address -offset 0x0003A0000000 -range 0x10000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM29] -force
-  assign_bd_address -offset 0x0003C0000000 -range 0x10000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM30] -force
-  assign_bd_address -offset 0x0003E0000000 -range 0x10000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM31] -force
+  assign_bd_address -offset 0x00000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces axi_datamover_0/Data_MM2S] [get_bd_addr_segs hbm_0/SAXI_13_8HI/HBM_MEM00] -force
+  assign_bd_address -offset 0x20000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces axi_datamover_0/Data_MM2S] [get_bd_addr_segs hbm_0/SAXI_13_8HI/HBM_MEM01] -force
+  assign_bd_address -offset 0x40000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces axi_datamover_0/Data_MM2S] [get_bd_addr_segs hbm_0/SAXI_13_8HI/HBM_MEM02] -force
+  assign_bd_address -offset 0x60000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces axi_datamover_0/Data_MM2S] [get_bd_addr_segs hbm_0/SAXI_13_8HI/HBM_MEM03] -force
+  assign_bd_address -offset 0x80000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces axi_datamover_0/Data_MM2S] [get_bd_addr_segs hbm_0/SAXI_13_8HI/HBM_MEM04] -force
+  assign_bd_address -offset 0xA0000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces axi_datamover_0/Data_MM2S] [get_bd_addr_segs hbm_0/SAXI_13_8HI/HBM_MEM05] -force
+  assign_bd_address -offset 0xC0000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces axi_datamover_0/Data_MM2S] [get_bd_addr_segs hbm_0/SAXI_13_8HI/HBM_MEM06] -force
+  assign_bd_address -offset 0xE0000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces axi_datamover_0/Data_MM2S] [get_bd_addr_segs hbm_0/SAXI_13_8HI/HBM_MEM07] -force
+  assign_bd_address -offset 0x000100000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces axi_datamover_0/Data_MM2S] [get_bd_addr_segs hbm_0/SAXI_13_8HI/HBM_MEM08] -force
+  assign_bd_address -offset 0x000120000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces axi_datamover_0/Data_MM2S] [get_bd_addr_segs hbm_0/SAXI_13_8HI/HBM_MEM09] -force
+  assign_bd_address -offset 0x000140000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces axi_datamover_0/Data_MM2S] [get_bd_addr_segs hbm_0/SAXI_13_8HI/HBM_MEM10] -force
+  assign_bd_address -offset 0x000160000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces axi_datamover_0/Data_MM2S] [get_bd_addr_segs hbm_0/SAXI_13_8HI/HBM_MEM11] -force
+  assign_bd_address -offset 0x000180000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces axi_datamover_0/Data_MM2S] [get_bd_addr_segs hbm_0/SAXI_13_8HI/HBM_MEM12] -force
+  assign_bd_address -offset 0x0001A0000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces axi_datamover_0/Data_MM2S] [get_bd_addr_segs hbm_0/SAXI_13_8HI/HBM_MEM13] -force
+  assign_bd_address -offset 0x0001C0000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces axi_datamover_0/Data_MM2S] [get_bd_addr_segs hbm_0/SAXI_13_8HI/HBM_MEM14] -force
+  assign_bd_address -offset 0x0001E0000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces axi_datamover_0/Data_MM2S] [get_bd_addr_segs hbm_0/SAXI_13_8HI/HBM_MEM15] -force
+  assign_bd_address -offset 0x000200000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces axi_datamover_0/Data_MM2S] [get_bd_addr_segs hbm_0/SAXI_13_8HI/HBM_MEM16] -force
+  assign_bd_address -offset 0x000220000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces axi_datamover_0/Data_MM2S] [get_bd_addr_segs hbm_0/SAXI_13_8HI/HBM_MEM17] -force
+  assign_bd_address -offset 0x000240000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces axi_datamover_0/Data_MM2S] [get_bd_addr_segs hbm_0/SAXI_13_8HI/HBM_MEM18] -force
+  assign_bd_address -offset 0x000260000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces axi_datamover_0/Data_MM2S] [get_bd_addr_segs hbm_0/SAXI_13_8HI/HBM_MEM19] -force
+  assign_bd_address -offset 0x000280000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces axi_datamover_0/Data_MM2S] [get_bd_addr_segs hbm_0/SAXI_13_8HI/HBM_MEM20] -force
+  assign_bd_address -offset 0x0002A0000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces axi_datamover_0/Data_MM2S] [get_bd_addr_segs hbm_0/SAXI_13_8HI/HBM_MEM21] -force
+  assign_bd_address -offset 0x0002C0000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces axi_datamover_0/Data_MM2S] [get_bd_addr_segs hbm_0/SAXI_13_8HI/HBM_MEM22] -force
+  assign_bd_address -offset 0x0002E0000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces axi_datamover_0/Data_MM2S] [get_bd_addr_segs hbm_0/SAXI_13_8HI/HBM_MEM23] -force
+  assign_bd_address -offset 0x000300000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces axi_datamover_0/Data_MM2S] [get_bd_addr_segs hbm_0/SAXI_13_8HI/HBM_MEM24] -force
+  assign_bd_address -offset 0x000320000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces axi_datamover_0/Data_MM2S] [get_bd_addr_segs hbm_0/SAXI_13_8HI/HBM_MEM25] -force
+  assign_bd_address -offset 0x000340000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces axi_datamover_0/Data_MM2S] [get_bd_addr_segs hbm_0/SAXI_13_8HI/HBM_MEM26] -force
+  assign_bd_address -offset 0x000360000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces axi_datamover_0/Data_MM2S] [get_bd_addr_segs hbm_0/SAXI_13_8HI/HBM_MEM27] -force
+  assign_bd_address -offset 0x000380000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces axi_datamover_0/Data_MM2S] [get_bd_addr_segs hbm_0/SAXI_13_8HI/HBM_MEM28] -force
+  assign_bd_address -offset 0x0003A0000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces axi_datamover_0/Data_MM2S] [get_bd_addr_segs hbm_0/SAXI_13_8HI/HBM_MEM29] -force
+  assign_bd_address -offset 0x0003C0000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces axi_datamover_0/Data_MM2S] [get_bd_addr_segs hbm_0/SAXI_13_8HI/HBM_MEM30] -force
+  assign_bd_address -offset 0x0003E0000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces axi_datamover_0/Data_MM2S] [get_bd_addr_segs hbm_0/SAXI_13_8HI/HBM_MEM31] -force
+  assign_bd_address -offset 0x00000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces axi_datamover_0/Data_S2MM] [get_bd_addr_segs hbm_0/SAXI_18_8HI/HBM_MEM00] -force
+  assign_bd_address -offset 0x20000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces axi_datamover_0/Data_S2MM] [get_bd_addr_segs hbm_0/SAXI_18_8HI/HBM_MEM01] -force
+  assign_bd_address -offset 0x40000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces axi_datamover_0/Data_S2MM] [get_bd_addr_segs hbm_0/SAXI_18_8HI/HBM_MEM02] -force
+  assign_bd_address -offset 0x60000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces axi_datamover_0/Data_S2MM] [get_bd_addr_segs hbm_0/SAXI_18_8HI/HBM_MEM03] -force
+  assign_bd_address -offset 0x80000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces axi_datamover_0/Data_S2MM] [get_bd_addr_segs hbm_0/SAXI_18_8HI/HBM_MEM04] -force
+  assign_bd_address -offset 0xA0000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces axi_datamover_0/Data_S2MM] [get_bd_addr_segs hbm_0/SAXI_18_8HI/HBM_MEM05] -force
+  assign_bd_address -offset 0xC0000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces axi_datamover_0/Data_S2MM] [get_bd_addr_segs hbm_0/SAXI_18_8HI/HBM_MEM06] -force
+  assign_bd_address -offset 0xE0000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces axi_datamover_0/Data_S2MM] [get_bd_addr_segs hbm_0/SAXI_18_8HI/HBM_MEM07] -force
+  assign_bd_address -offset 0x000100000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces axi_datamover_0/Data_S2MM] [get_bd_addr_segs hbm_0/SAXI_18_8HI/HBM_MEM08] -force
+  assign_bd_address -offset 0x000120000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces axi_datamover_0/Data_S2MM] [get_bd_addr_segs hbm_0/SAXI_18_8HI/HBM_MEM09] -force
+  assign_bd_address -offset 0x000140000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces axi_datamover_0/Data_S2MM] [get_bd_addr_segs hbm_0/SAXI_18_8HI/HBM_MEM10] -force
+  assign_bd_address -offset 0x000160000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces axi_datamover_0/Data_S2MM] [get_bd_addr_segs hbm_0/SAXI_18_8HI/HBM_MEM11] -force
+  assign_bd_address -offset 0x000180000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces axi_datamover_0/Data_S2MM] [get_bd_addr_segs hbm_0/SAXI_18_8HI/HBM_MEM12] -force
+  assign_bd_address -offset 0x0001A0000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces axi_datamover_0/Data_S2MM] [get_bd_addr_segs hbm_0/SAXI_18_8HI/HBM_MEM13] -force
+  assign_bd_address -offset 0x0001C0000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces axi_datamover_0/Data_S2MM] [get_bd_addr_segs hbm_0/SAXI_18_8HI/HBM_MEM14] -force
+  assign_bd_address -offset 0x0001E0000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces axi_datamover_0/Data_S2MM] [get_bd_addr_segs hbm_0/SAXI_18_8HI/HBM_MEM15] -force
+  assign_bd_address -offset 0x000200000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces axi_datamover_0/Data_S2MM] [get_bd_addr_segs hbm_0/SAXI_18_8HI/HBM_MEM16] -force
+  assign_bd_address -offset 0x000220000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces axi_datamover_0/Data_S2MM] [get_bd_addr_segs hbm_0/SAXI_18_8HI/HBM_MEM17] -force
+  assign_bd_address -offset 0x000240000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces axi_datamover_0/Data_S2MM] [get_bd_addr_segs hbm_0/SAXI_18_8HI/HBM_MEM18] -force
+  assign_bd_address -offset 0x000260000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces axi_datamover_0/Data_S2MM] [get_bd_addr_segs hbm_0/SAXI_18_8HI/HBM_MEM19] -force
+  assign_bd_address -offset 0x000280000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces axi_datamover_0/Data_S2MM] [get_bd_addr_segs hbm_0/SAXI_18_8HI/HBM_MEM20] -force
+  assign_bd_address -offset 0x0002A0000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces axi_datamover_0/Data_S2MM] [get_bd_addr_segs hbm_0/SAXI_18_8HI/HBM_MEM21] -force
+  assign_bd_address -offset 0x0002C0000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces axi_datamover_0/Data_S2MM] [get_bd_addr_segs hbm_0/SAXI_18_8HI/HBM_MEM22] -force
+  assign_bd_address -offset 0x0002E0000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces axi_datamover_0/Data_S2MM] [get_bd_addr_segs hbm_0/SAXI_18_8HI/HBM_MEM23] -force
+  assign_bd_address -offset 0x000300000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces axi_datamover_0/Data_S2MM] [get_bd_addr_segs hbm_0/SAXI_18_8HI/HBM_MEM24] -force
+  assign_bd_address -offset 0x000320000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces axi_datamover_0/Data_S2MM] [get_bd_addr_segs hbm_0/SAXI_18_8HI/HBM_MEM25] -force
+  assign_bd_address -offset 0x000340000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces axi_datamover_0/Data_S2MM] [get_bd_addr_segs hbm_0/SAXI_18_8HI/HBM_MEM26] -force
+  assign_bd_address -offset 0x000360000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces axi_datamover_0/Data_S2MM] [get_bd_addr_segs hbm_0/SAXI_18_8HI/HBM_MEM27] -force
+  assign_bd_address -offset 0x000380000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces axi_datamover_0/Data_S2MM] [get_bd_addr_segs hbm_0/SAXI_18_8HI/HBM_MEM28] -force
+  assign_bd_address -offset 0x0003A0000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces axi_datamover_0/Data_S2MM] [get_bd_addr_segs hbm_0/SAXI_18_8HI/HBM_MEM29] -force
+  assign_bd_address -offset 0x0003C0000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces axi_datamover_0/Data_S2MM] [get_bd_addr_segs hbm_0/SAXI_18_8HI/HBM_MEM30] -force
+  assign_bd_address -offset 0x0003E0000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces axi_datamover_0/Data_S2MM] [get_bd_addr_segs hbm_0/SAXI_18_8HI/HBM_MEM31] -force
+  assign_bd_address -offset 0x00000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_0] [get_bd_addr_segs hbm_0/SAXI_14_8HI/HBM_MEM00] -force
+  assign_bd_address -offset 0x20000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_0] [get_bd_addr_segs hbm_0/SAXI_14_8HI/HBM_MEM01] -force
+  assign_bd_address -offset 0x40000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_0] [get_bd_addr_segs hbm_0/SAXI_14_8HI/HBM_MEM02] -force
+  assign_bd_address -offset 0x60000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_0] [get_bd_addr_segs hbm_0/SAXI_14_8HI/HBM_MEM03] -force
+  assign_bd_address -offset 0x80000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_0] [get_bd_addr_segs hbm_0/SAXI_14_8HI/HBM_MEM04] -force
+  assign_bd_address -offset 0xA0000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_0] [get_bd_addr_segs hbm_0/SAXI_14_8HI/HBM_MEM05] -force
+  assign_bd_address -offset 0xC0000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_0] [get_bd_addr_segs hbm_0/SAXI_14_8HI/HBM_MEM06] -force
+  assign_bd_address -offset 0xE0000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_0] [get_bd_addr_segs hbm_0/SAXI_14_8HI/HBM_MEM07] -force
+  assign_bd_address -offset 0x000100000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_0] [get_bd_addr_segs hbm_0/SAXI_14_8HI/HBM_MEM08] -force
+  assign_bd_address -offset 0x000120000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_0] [get_bd_addr_segs hbm_0/SAXI_14_8HI/HBM_MEM09] -force
+  assign_bd_address -offset 0x000140000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_0] [get_bd_addr_segs hbm_0/SAXI_14_8HI/HBM_MEM10] -force
+  assign_bd_address -offset 0x000160000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_0] [get_bd_addr_segs hbm_0/SAXI_14_8HI/HBM_MEM11] -force
+  assign_bd_address -offset 0x000180000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_0] [get_bd_addr_segs hbm_0/SAXI_14_8HI/HBM_MEM12] -force
+  assign_bd_address -offset 0x0001A0000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_0] [get_bd_addr_segs hbm_0/SAXI_14_8HI/HBM_MEM13] -force
+  assign_bd_address -offset 0x0001C0000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_0] [get_bd_addr_segs hbm_0/SAXI_14_8HI/HBM_MEM14] -force
+  assign_bd_address -offset 0x0001E0000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_0] [get_bd_addr_segs hbm_0/SAXI_14_8HI/HBM_MEM15] -force
+  assign_bd_address -offset 0x000200000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_0] [get_bd_addr_segs hbm_0/SAXI_14_8HI/HBM_MEM16] -force
+  assign_bd_address -offset 0x000220000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_0] [get_bd_addr_segs hbm_0/SAXI_14_8HI/HBM_MEM17] -force
+  assign_bd_address -offset 0x000240000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_0] [get_bd_addr_segs hbm_0/SAXI_14_8HI/HBM_MEM18] -force
+  assign_bd_address -offset 0x000260000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_0] [get_bd_addr_segs hbm_0/SAXI_14_8HI/HBM_MEM19] -force
+  assign_bd_address -offset 0x000280000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_0] [get_bd_addr_segs hbm_0/SAXI_14_8HI/HBM_MEM20] -force
+  assign_bd_address -offset 0x0002A0000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_0] [get_bd_addr_segs hbm_0/SAXI_14_8HI/HBM_MEM21] -force
+  assign_bd_address -offset 0x0002C0000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_0] [get_bd_addr_segs hbm_0/SAXI_14_8HI/HBM_MEM22] -force
+  assign_bd_address -offset 0x0002E0000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_0] [get_bd_addr_segs hbm_0/SAXI_14_8HI/HBM_MEM23] -force
+  assign_bd_address -offset 0x000300000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_0] [get_bd_addr_segs hbm_0/SAXI_14_8HI/HBM_MEM24] -force
+  assign_bd_address -offset 0x000320000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_0] [get_bd_addr_segs hbm_0/SAXI_14_8HI/HBM_MEM25] -force
+  assign_bd_address -offset 0x000340000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_0] [get_bd_addr_segs hbm_0/SAXI_14_8HI/HBM_MEM26] -force
+  assign_bd_address -offset 0x000360000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_0] [get_bd_addr_segs hbm_0/SAXI_14_8HI/HBM_MEM27] -force
+  assign_bd_address -offset 0x000380000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_0] [get_bd_addr_segs hbm_0/SAXI_14_8HI/HBM_MEM28] -force
+  assign_bd_address -offset 0x0003A0000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_0] [get_bd_addr_segs hbm_0/SAXI_14_8HI/HBM_MEM29] -force
+  assign_bd_address -offset 0x0003C0000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_0] [get_bd_addr_segs hbm_0/SAXI_14_8HI/HBM_MEM30] -force
+  assign_bd_address -offset 0x0003E0000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_0] [get_bd_addr_segs hbm_0/SAXI_14_8HI/HBM_MEM31] -force
+  assign_bd_address -offset 0x00000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_1] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM00] -force
+  assign_bd_address -offset 0x20000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_1] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM01] -force
+  assign_bd_address -offset 0x40000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_1] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM02] -force
+  assign_bd_address -offset 0x60000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_1] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM03] -force
+  assign_bd_address -offset 0x80000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_1] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM04] -force
+  assign_bd_address -offset 0xA0000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_1] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM05] -force
+  assign_bd_address -offset 0xC0000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_1] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM06] -force
+  assign_bd_address -offset 0xE0000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_1] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM07] -force
+  assign_bd_address -offset 0x000100000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_1] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM08] -force
+  assign_bd_address -offset 0x000120000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_1] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM09] -force
+  assign_bd_address -offset 0x000140000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_1] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM10] -force
+  assign_bd_address -offset 0x000160000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_1] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM11] -force
+  assign_bd_address -offset 0x000180000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_1] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM12] -force
+  assign_bd_address -offset 0x0001A0000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_1] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM13] -force
+  assign_bd_address -offset 0x0001C0000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_1] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM14] -force
+  assign_bd_address -offset 0x0001E0000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_1] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM15] -force
+  assign_bd_address -offset 0x000200000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_1] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM16] -force
+  assign_bd_address -offset 0x000220000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_1] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM17] -force
+  assign_bd_address -offset 0x000240000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_1] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM18] -force
+  assign_bd_address -offset 0x000260000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_1] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM19] -force
+  assign_bd_address -offset 0x000280000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_1] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM20] -force
+  assign_bd_address -offset 0x0002A0000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_1] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM21] -force
+  assign_bd_address -offset 0x0002C0000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_1] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM22] -force
+  assign_bd_address -offset 0x0002E0000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_1] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM23] -force
+  assign_bd_address -offset 0x000300000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_1] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM24] -force
+  assign_bd_address -offset 0x000320000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_1] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM25] -force
+  assign_bd_address -offset 0x000340000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_1] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM26] -force
+  assign_bd_address -offset 0x000360000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_1] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM27] -force
+  assign_bd_address -offset 0x000380000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_1] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM28] -force
+  assign_bd_address -offset 0x0003A0000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_1] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM29] -force
+  assign_bd_address -offset 0x0003C0000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_1] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM30] -force
+  assign_bd_address -offset 0x0003E0000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_1] [get_bd_addr_segs hbm_0/SAXI_15_8HI/HBM_MEM31] -force
+  assign_bd_address -offset 0x00000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_2] [get_bd_addr_segs hbm_0/SAXI_17_8HI/HBM_MEM00] -force
+  assign_bd_address -offset 0x20000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_2] [get_bd_addr_segs hbm_0/SAXI_17_8HI/HBM_MEM01] -force
+  assign_bd_address -offset 0x40000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_2] [get_bd_addr_segs hbm_0/SAXI_17_8HI/HBM_MEM02] -force
+  assign_bd_address -offset 0x60000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_2] [get_bd_addr_segs hbm_0/SAXI_17_8HI/HBM_MEM03] -force
+  assign_bd_address -offset 0x80000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_2] [get_bd_addr_segs hbm_0/SAXI_17_8HI/HBM_MEM04] -force
+  assign_bd_address -offset 0xA0000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_2] [get_bd_addr_segs hbm_0/SAXI_17_8HI/HBM_MEM05] -force
+  assign_bd_address -offset 0xC0000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_2] [get_bd_addr_segs hbm_0/SAXI_17_8HI/HBM_MEM06] -force
+  assign_bd_address -offset 0xE0000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_2] [get_bd_addr_segs hbm_0/SAXI_17_8HI/HBM_MEM07] -force
+  assign_bd_address -offset 0x000100000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_2] [get_bd_addr_segs hbm_0/SAXI_17_8HI/HBM_MEM08] -force
+  assign_bd_address -offset 0x000120000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_2] [get_bd_addr_segs hbm_0/SAXI_17_8HI/HBM_MEM09] -force
+  assign_bd_address -offset 0x000140000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_2] [get_bd_addr_segs hbm_0/SAXI_17_8HI/HBM_MEM10] -force
+  assign_bd_address -offset 0x000160000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_2] [get_bd_addr_segs hbm_0/SAXI_17_8HI/HBM_MEM11] -force
+  assign_bd_address -offset 0x000180000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_2] [get_bd_addr_segs hbm_0/SAXI_17_8HI/HBM_MEM12] -force
+  assign_bd_address -offset 0x0001A0000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_2] [get_bd_addr_segs hbm_0/SAXI_17_8HI/HBM_MEM13] -force
+  assign_bd_address -offset 0x0001C0000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_2] [get_bd_addr_segs hbm_0/SAXI_17_8HI/HBM_MEM14] -force
+  assign_bd_address -offset 0x0001E0000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_2] [get_bd_addr_segs hbm_0/SAXI_17_8HI/HBM_MEM15] -force
+  assign_bd_address -offset 0x000200000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_2] [get_bd_addr_segs hbm_0/SAXI_17_8HI/HBM_MEM16] -force
+  assign_bd_address -offset 0x000220000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_2] [get_bd_addr_segs hbm_0/SAXI_17_8HI/HBM_MEM17] -force
+  assign_bd_address -offset 0x000240000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_2] [get_bd_addr_segs hbm_0/SAXI_17_8HI/HBM_MEM18] -force
+  assign_bd_address -offset 0x000260000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_2] [get_bd_addr_segs hbm_0/SAXI_17_8HI/HBM_MEM19] -force
+  assign_bd_address -offset 0x000280000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_2] [get_bd_addr_segs hbm_0/SAXI_17_8HI/HBM_MEM20] -force
+  assign_bd_address -offset 0x0002A0000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_2] [get_bd_addr_segs hbm_0/SAXI_17_8HI/HBM_MEM21] -force
+  assign_bd_address -offset 0x0002C0000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_2] [get_bd_addr_segs hbm_0/SAXI_17_8HI/HBM_MEM22] -force
+  assign_bd_address -offset 0x0002E0000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_2] [get_bd_addr_segs hbm_0/SAXI_17_8HI/HBM_MEM23] -force
+  assign_bd_address -offset 0x000300000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_2] [get_bd_addr_segs hbm_0/SAXI_17_8HI/HBM_MEM24] -force
+  assign_bd_address -offset 0x000320000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_2] [get_bd_addr_segs hbm_0/SAXI_17_8HI/HBM_MEM25] -force
+  assign_bd_address -offset 0x000340000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_2] [get_bd_addr_segs hbm_0/SAXI_17_8HI/HBM_MEM26] -force
+  assign_bd_address -offset 0x000360000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_2] [get_bd_addr_segs hbm_0/SAXI_17_8HI/HBM_MEM27] -force
+  assign_bd_address -offset 0x000380000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_2] [get_bd_addr_segs hbm_0/SAXI_17_8HI/HBM_MEM28] -force
+  assign_bd_address -offset 0x0003A0000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_2] [get_bd_addr_segs hbm_0/SAXI_17_8HI/HBM_MEM29] -force
+  assign_bd_address -offset 0x0003C0000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_2] [get_bd_addr_segs hbm_0/SAXI_17_8HI/HBM_MEM30] -force
+  assign_bd_address -offset 0x0003E0000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_2] [get_bd_addr_segs hbm_0/SAXI_17_8HI/HBM_MEM31] -force
+  assign_bd_address -offset 0x00000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_3] [get_bd_addr_segs hbm_0/SAXI_16_8HI/HBM_MEM00] -force
+  assign_bd_address -offset 0x20000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_3] [get_bd_addr_segs hbm_0/SAXI_16_8HI/HBM_MEM01] -force
+  assign_bd_address -offset 0x40000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_3] [get_bd_addr_segs hbm_0/SAXI_16_8HI/HBM_MEM02] -force
+  assign_bd_address -offset 0x60000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_3] [get_bd_addr_segs hbm_0/SAXI_16_8HI/HBM_MEM03] -force
+  assign_bd_address -offset 0x80000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_3] [get_bd_addr_segs hbm_0/SAXI_16_8HI/HBM_MEM04] -force
+  assign_bd_address -offset 0xA0000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_3] [get_bd_addr_segs hbm_0/SAXI_16_8HI/HBM_MEM05] -force
+  assign_bd_address -offset 0xC0000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_3] [get_bd_addr_segs hbm_0/SAXI_16_8HI/HBM_MEM06] -force
+  assign_bd_address -offset 0xE0000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_3] [get_bd_addr_segs hbm_0/SAXI_16_8HI/HBM_MEM07] -force
+  assign_bd_address -offset 0x000100000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_3] [get_bd_addr_segs hbm_0/SAXI_16_8HI/HBM_MEM08] -force
+  assign_bd_address -offset 0x000120000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_3] [get_bd_addr_segs hbm_0/SAXI_16_8HI/HBM_MEM09] -force
+  assign_bd_address -offset 0x000140000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_3] [get_bd_addr_segs hbm_0/SAXI_16_8HI/HBM_MEM10] -force
+  assign_bd_address -offset 0x000160000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_3] [get_bd_addr_segs hbm_0/SAXI_16_8HI/HBM_MEM11] -force
+  assign_bd_address -offset 0x000180000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_3] [get_bd_addr_segs hbm_0/SAXI_16_8HI/HBM_MEM12] -force
+  assign_bd_address -offset 0x0001A0000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_3] [get_bd_addr_segs hbm_0/SAXI_16_8HI/HBM_MEM13] -force
+  assign_bd_address -offset 0x0001C0000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_3] [get_bd_addr_segs hbm_0/SAXI_16_8HI/HBM_MEM14] -force
+  assign_bd_address -offset 0x0001E0000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_3] [get_bd_addr_segs hbm_0/SAXI_16_8HI/HBM_MEM15] -force
+  assign_bd_address -offset 0x000200000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_3] [get_bd_addr_segs hbm_0/SAXI_16_8HI/HBM_MEM16] -force
+  assign_bd_address -offset 0x000220000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_3] [get_bd_addr_segs hbm_0/SAXI_16_8HI/HBM_MEM17] -force
+  assign_bd_address -offset 0x000240000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_3] [get_bd_addr_segs hbm_0/SAXI_16_8HI/HBM_MEM18] -force
+  assign_bd_address -offset 0x000260000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_3] [get_bd_addr_segs hbm_0/SAXI_16_8HI/HBM_MEM19] -force
+  assign_bd_address -offset 0x000280000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_3] [get_bd_addr_segs hbm_0/SAXI_16_8HI/HBM_MEM20] -force
+  assign_bd_address -offset 0x0002A0000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_3] [get_bd_addr_segs hbm_0/SAXI_16_8HI/HBM_MEM21] -force
+  assign_bd_address -offset 0x0002C0000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_3] [get_bd_addr_segs hbm_0/SAXI_16_8HI/HBM_MEM22] -force
+  assign_bd_address -offset 0x0002E0000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_3] [get_bd_addr_segs hbm_0/SAXI_16_8HI/HBM_MEM23] -force
+  assign_bd_address -offset 0x000300000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_3] [get_bd_addr_segs hbm_0/SAXI_16_8HI/HBM_MEM24] -force
+  assign_bd_address -offset 0x000320000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_3] [get_bd_addr_segs hbm_0/SAXI_16_8HI/HBM_MEM25] -force
+  assign_bd_address -offset 0x000340000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_3] [get_bd_addr_segs hbm_0/SAXI_16_8HI/HBM_MEM26] -force
+  assign_bd_address -offset 0x000360000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_3] [get_bd_addr_segs hbm_0/SAXI_16_8HI/HBM_MEM27] -force
+  assign_bd_address -offset 0x000380000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_3] [get_bd_addr_segs hbm_0/SAXI_16_8HI/HBM_MEM28] -force
+  assign_bd_address -offset 0x0003A0000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_3] [get_bd_addr_segs hbm_0/SAXI_16_8HI/HBM_MEM29] -force
+  assign_bd_address -offset 0x0003C0000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_3] [get_bd_addr_segs hbm_0/SAXI_16_8HI/HBM_MEM30] -force
+  assign_bd_address -offset 0x0003E0000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_3] [get_bd_addr_segs hbm_0/SAXI_16_8HI/HBM_MEM31] -force
+  assign_bd_address -offset 0x00000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_12_8HI/HBM_MEM00] -force
+  assign_bd_address -offset 0x20000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_12_8HI/HBM_MEM01] -force
+  assign_bd_address -offset 0x40000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_12_8HI/HBM_MEM02] -force
+  assign_bd_address -offset 0x60000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_12_8HI/HBM_MEM03] -force
+  assign_bd_address -offset 0x80000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_12_8HI/HBM_MEM04] -force
+  assign_bd_address -offset 0xA0000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_12_8HI/HBM_MEM05] -force
+  assign_bd_address -offset 0xC0000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_12_8HI/HBM_MEM06] -force
+  assign_bd_address -offset 0xE0000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_12_8HI/HBM_MEM07] -force
+  assign_bd_address -offset 0x000100000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_12_8HI/HBM_MEM08] -force
+  assign_bd_address -offset 0x000120000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_12_8HI/HBM_MEM09] -force
+  assign_bd_address -offset 0x000140000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_12_8HI/HBM_MEM10] -force
+  assign_bd_address -offset 0x000160000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_12_8HI/HBM_MEM11] -force
+  assign_bd_address -offset 0x000180000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_12_8HI/HBM_MEM12] -force
+  assign_bd_address -offset 0x0001A0000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_12_8HI/HBM_MEM13] -force
+  assign_bd_address -offset 0x0001C0000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_12_8HI/HBM_MEM14] -force
+  assign_bd_address -offset 0x0001E0000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_12_8HI/HBM_MEM15] -force
+  assign_bd_address -offset 0x000200000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_12_8HI/HBM_MEM16] -force
+  assign_bd_address -offset 0x000220000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_12_8HI/HBM_MEM17] -force
+  assign_bd_address -offset 0x000240000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_12_8HI/HBM_MEM18] -force
+  assign_bd_address -offset 0x000260000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_12_8HI/HBM_MEM19] -force
+  assign_bd_address -offset 0x000280000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_12_8HI/HBM_MEM20] -force
+  assign_bd_address -offset 0x0002A0000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_12_8HI/HBM_MEM21] -force
+  assign_bd_address -offset 0x0002C0000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_12_8HI/HBM_MEM22] -force
+  assign_bd_address -offset 0x0002E0000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_12_8HI/HBM_MEM23] -force
+  assign_bd_address -offset 0x000300000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_12_8HI/HBM_MEM24] -force
+  assign_bd_address -offset 0x000320000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_12_8HI/HBM_MEM25] -force
+  assign_bd_address -offset 0x000340000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_12_8HI/HBM_MEM26] -force
+  assign_bd_address -offset 0x000360000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_12_8HI/HBM_MEM27] -force
+  assign_bd_address -offset 0x000380000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_12_8HI/HBM_MEM28] -force
+  assign_bd_address -offset 0x0003A0000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_12_8HI/HBM_MEM29] -force
+  assign_bd_address -offset 0x0003C0000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_12_8HI/HBM_MEM30] -force
+  assign_bd_address -offset 0x0003E0000000 -range 0x20000000 -target_address_space [get_bd_addr_spaces s_axi_hbm] [get_bd_addr_segs hbm_0/SAXI_12_8HI/HBM_MEM31] -force
 
 
   # Restore current instance
diff --git a/src/hbm_subsystem/hbm_subsystem.sv b/src/hbm_subsystem/hbm_subsystem.sv
index 4571b97..2e15a61 100644
--- a/src/hbm_subsystem/hbm_subsystem.sv
+++ b/src/hbm_subsystem/hbm_subsystem.sv
@@ -1,4 +1,12 @@
-module hbm_subsystem (
+`timescale 1ns/1ps
+
+import metadata_pkg::*;
+
+module hbm_subsystem #(
+  parameter int          BUCKET_SIZE = 1024,
+  parameter logic [31:0] NODE_IP     = '0,
+  parameter logic [47:0] NODE_MAC    = '0
+) (
   input   [63:0] s_axi_araddr,
   input    [1:0] s_axi_arburst,
   input    [3:0] s_axi_arcache,
@@ -40,55 +48,635 @@ module hbm_subsystem (
   input   [63:0] s_axi_wuser,
   input          s_axi_wvalid,
 
+  input          s_axis_qdma_h2c_tvalid,
+  input  [511:0] s_axis_qdma_h2c_tdata,
+  input   [63:0] s_axis_qdma_h2c_tkeep,
+  input          s_axis_qdma_h2c_tlast,
+  input   [15:0] s_axis_qdma_h2c_tuser_size,
+  input   [15:0] s_axis_qdma_h2c_tuser_src,
+  input   [15:0] s_axis_qdma_h2c_tuser_dst,
+  output         s_axis_qdma_h2c_tready,
+
+  output         m_axis_qdma_c2h_tvalid,
+  output [511:0] m_axis_qdma_c2h_tdata,
+  output  [63:0] m_axis_qdma_c2h_tkeep,
+  output         m_axis_qdma_c2h_tlast,
+  output  [15:0] m_axis_qdma_c2h_tuser_size,
+  output  [15:0] m_axis_qdma_c2h_tuser_src,
+  output  [15:0] m_axis_qdma_c2h_tuser_dst,
+  input          m_axis_qdma_c2h_tready,
+
+  output         m_axis_cmac_h2c_tvalid,
+  output [511:0] m_axis_cmac_h2c_tdata,
+  output  [63:0] m_axis_cmac_h2c_tkeep,
+  output         m_axis_cmac_h2c_tlast,
+  output  [15:0] m_axis_cmac_h2c_tuser_size,
+  output  [15:0] m_axis_cmac_h2c_tuser_src,
+  output  [15:0] m_axis_cmac_h2c_tuser_dst,
+  input          m_axis_cmac_h2c_tready,
+
+  input          s_axis_cmac_c2h_tvalid,
+  input  [511:0] s_axis_cmac_c2h_tdata,
+  input   [63:0] s_axis_cmac_c2h_tkeep,
+  input          s_axis_cmac_c2h_tlast,
+  input   [15:0] s_axis_cmac_c2h_tuser_size,
+  input   [15:0] s_axis_cmac_c2h_tuser_src,
+  input   [15:0] s_axis_cmac_c2h_tuser_dst,
+  output         s_axis_cmac_c2h_tready,
+
   input          axi_clk,
-  input          axi_resetn,
+  input          axi_rstn,
   input          hbm_ref_clk
 );
-  
-  hbm_bd_wrapper hbm_inst (
-    .s_axi_hbm_araddr                (s_axi_araddr),
-    .s_axi_hbm_arburst               (s_axi_arburst),
-    .s_axi_hbm_arcache               (s_axi_arcache),
-    .s_axi_hbm_arid                  (s_axi_arid),
-    .s_axi_hbm_arlen                 (s_axi_arlen),
-    .s_axi_hbm_arlock                (s_axi_arlock),
-    .s_axi_hbm_arprot                (s_axi_arprot),
-    .s_axi_hbm_arqos                 (s_axi_arqos),
-    .s_axi_hbm_arready               (s_axi_arready),
-    .s_axi_hbm_arsize                (s_axi_arsize),
-    .s_axi_hbm_aruser                (s_axi_aruser),
-    .s_axi_hbm_arvalid               (s_axi_arvalid),
-    .s_axi_hbm_awaddr                (s_axi_awaddr),
-    .s_axi_hbm_awburst               (s_axi_awburst),
-    .s_axi_hbm_awcache               (s_axi_awcache),
-    .s_axi_hbm_awid                  (s_axi_awid),
-    .s_axi_hbm_awlen                 (s_axi_awlen),
-    .s_axi_hbm_awlock                (s_axi_awlock),
-    .s_axi_hbm_awprot                (s_axi_awprot),
-    .s_axi_hbm_awqos                 (s_axi_awqos),
-    .s_axi_hbm_awready               (s_axi_awready),
-    .s_axi_hbm_awsize                (s_axi_awsize),
-    .s_axi_hbm_awuser                (s_axi_awuser),
-    .s_axi_hbm_awvalid               (s_axi_awvalid),
-    .s_axi_hbm_bid                   (s_axi_bid),
-    .s_axi_hbm_bready                (s_axi_bready),
-    .s_axi_hbm_bresp                 (s_axi_bresp),
-    .s_axi_hbm_bvalid                (s_axi_bvalid),
-    .s_axi_hbm_rdata                 (s_axi_rdata),
-    .s_axi_hbm_rid                   (s_axi_rid),
-    .s_axi_hbm_rlast                 (s_axi_rlast),
-    .s_axi_hbm_rready                (s_axi_rready),
-    .s_axi_hbm_rresp                 (s_axi_rresp),
-    .s_axi_hbm_rvalid                (s_axi_rvalid),
-    .s_axi_hbm_wdata                 (s_axi_wdata),
-    .s_axi_hbm_wlast                 (s_axi_wlast),
-    .s_axi_hbm_wready                (s_axi_wready),
-    .s_axi_hbm_wstrb                 (s_axi_wstrb),
-    .s_axi_hbm_wuser                 (s_axi_wuser),
-    .s_axi_hbm_wvalid                (s_axi_wvalid),
-
-    .axi_clk                         (axi_clk),
-    .axi_resetn                      (axi_resetn),
-    .hbm_ref_clk                     (hbm_ref_clk)
-  );
-  endmodule
\ No newline at end of file
+
+localparam NUM_HASHES    = 4;
+localparam ADDRESS_WIDTH = 34;  // 16 GB
+localparam HASH_WIDTH    = ADDRESS_WIDTH - $clog2(BUCKET_SIZE);
+
+localparam logic [HASH_WIDTH-1:0] HASH_MATRIX [NUM_HASHES][KEY_WIDTH-1:0] = '{{
+  24'hA3C5D1, 24'hD4F921, 24'h98B337, 24'h345678,
+  24'hEAD00F, 24'hADC0DE, 24'h55AAAA, 24'hACE123,
+  24'hF23456, 24'hBEEF12, 24'h0FFEE0, 24'hBADB07,
+  24'hBCDEF0, 24'hBCDE12, 24'h4679BD, 24'h2468AC,
+  24'hAAAAAA, 24'hBBBBBB, 24'hCCCCCC, 24'h234567,
+  24'h654321, 24'hEDCBA9, 24'hACEACE, 24'hC001D0,
+  24'hEADC0D, 24'hADD00D, 24'h0DEC0D, 24'hDCAFE,
+  24'h3579BF, 24'h468ACE, 24'h579BDF, 24'h68ACED,
+  24'h55AAAA, 24'h66BBBB, 24'h77CCCC, 24'h88DDDD,
+  24'h99EEEE, 24'hAAFFFF, 24'hBBB111, 24'hCCC222,
+  24'hDDD333, 24'hEEE444, 24'hFFF555, 24'h111222,
+  24'h222333, 24'h333444, 24'h444555, 24'h555666,
+  24'h666777, 24'h777888, 24'h888999, 24'h999AAA,
+  24'hAAA111, 24'hBBB222, 24'hCCC333, 24'hDDD444,
+  24'hEEE555, 24'hFFF666, 24'h2345AB, 24'hDC123,
+  24'h4567CD, 24'h6789EF, 24'h89AB12, 24'hBCDEF3
+}, {
+  24'h123456, 24'h234567, 24'h345678, 24'h456789,
+  24'h56789A, 24'h6789AB, 24'h789ABC, 24'h89ABCD,
+  24'h9ABCDE, 24'hABCDE0, 24'hBCDEF1, 24'hCDEF12,
+  24'hDEF123, 24'hEF1234, 24'hF12345, 24'h012345,
+  24'h111111, 24'h222222, 24'h333333, 24'h444444,
+  24'h555555, 24'h666666, 24'h777777, 24'h888888,
+  24'h999999, 24'hAAAAAA, 24'hBBBBBB, 24'hCCCCCC,
+  24'hDDDDDD, 24'hEEEEEE, 24'hFFFFFF, 24'h000000,
+  24'h13579B, 24'h2468AC, 24'h3579BD, 24'h468ACE,
+  24'h579BDF, 24'h68ACEF, 24'h79BDF0, 24'h8ACE01,
+  24'h9BDF12, 24'hACEF23, 24'hBDF034, 24'hCEF145,
+  24'hDF0256, 24'hEF1367, 24'hF02478, 24'h012589,
+  24'h12369A, 24'h2347AB, 24'h3458BC, 24'h4569CD,
+  24'h567ADE, 24'h678BEF, 24'h789C01, 24'h89AD12,
+  24'h9ABE23, 24'hABCF34, 24'hBC0145, 24'hCD1256,
+  24'hDE2367, 24'hEF3478, 24'hF04589, 24'h01269A
+}, {
+  24'hFACE01, 24'hDEAD02, 24'hBEEF03, 24'hCAFE04,
+  24'hBABE05, 24'hFEED06, 24'hC0DE07, 24'hF00D08,
+  24'h1CED09, 24'hBAD10A, 24'hC0010B, 24'hDAD10C,
+  24'hACED0D, 24'hBA510E, 24'hD00D0F, 24'hFEED10,
+  24'h111AAA, 24'h222BBB, 24'h333CCC, 24'h444DDD,
+  24'h555EEE, 24'h666FFF, 24'h777000, 24'h888111,
+  24'h999222, 24'hAAA333, 24'hBBB444, 24'hCCC555,
+  24'hDDD666, 24'hEEE777, 24'hFFF888, 24'h000999,
+  24'hAAAA01, 24'hBBBB02, 24'hCCCC03, 24'hDDDD04,
+  24'hEEEE05, 24'hFFFF06, 24'h123407, 24'h234508,
+  24'h345609, 24'h45670A, 24'h56780B, 24'h67890C,
+  24'h789A0D, 24'h89AB0E, 24'h9ABC0F, 24'hABCD10,
+  24'hBCDE11, 24'hCDEF12, 24'hDEF013, 24'hEF0114,
+  24'hF01215, 24'h012316, 24'h123417, 24'h234518,
+  24'h345619, 24'h45671A, 24'h56781B, 24'h67891C,
+  24'h789A1D, 24'h89AB1E, 24'h9ABC1F, 24'hABCD20
+}, {
+  24'h102938, 24'h293847, 24'h384756, 24'h475665,
+  24'h566574, 24'h665483, 24'h754392, 24'h843A01,
+  24'h932B10, 24'hA21C20, 24'hB10D30, 24'hC00E40,
+  24'hDF0F50, 24'hEE1060, 24'hFD1170, 24'h0C1280,
+  24'h1B1390, 24'h2A14A0, 24'h3915B0, 24'h4816C0,
+  24'h5717D0, 24'h6618E0, 24'h7519F0, 24'h842A00,
+  24'h933B10, 24'hA24C20, 24'hB15D30, 24'hC06E40,
+  24'hD17F50, 24'hE29060, 24'hF3A170, 24'h04B280,
+  24'h15C390, 24'h26D4A0, 24'h37E5B0, 24'h48F6C0,
+  24'h5907D0, 24'h6A18E0, 24'h7B29F0, 24'h8C3A00,
+  24'h9D4B10, 24'hAE5C20, 24'hBF6D30, 24'hD07E40,
+  24'hE18F50, 24'hF2A060, 24'h03B170, 24'h14C280,
+  24'h25D390, 24'h36E4A0, 24'h47F5B0, 24'h5806C0,
+  24'h6917D0, 24'h7A28E0, 24'h8B39F0, 24'h9C4A00,
+  24'hAD5B10, 24'hBE6C20, 24'hCF7D30, 24'hD08E40,
+  24'hE19F50, 24'hF2B060, 24'h03C170, 24'h14D280
+}};
+
+logic  [33:0]  axi_araddr   [NUM_HASHES];
+logic   [1:0]  axi_arburst  [NUM_HASHES];
+logic   [3:0]  axi_arcache  [NUM_HASHES];
+logic   [3:0]  axi_arid     [NUM_HASHES];
+logic   [3:0]  axi_arlen    [NUM_HASHES];
+logic   [1:0]  axi_arlock   [NUM_HASHES];
+logic   [2:0]  axi_arprot   [NUM_HASHES];
+logic          axi_arready  [NUM_HASHES];
+logic   [2:0]  axi_arsize   [NUM_HASHES];
+logic          axi_arvalid  [NUM_HASHES];
+logic  [33:0]  axi_awaddr   [NUM_HASHES];
+logic   [1:0]  axi_awburst  [NUM_HASHES];
+logic   [3:0]  axi_awcache  [NUM_HASHES];
+logic   [3:0]  axi_awid     [NUM_HASHES];
+logic   [3:0]  axi_awlen    [NUM_HASHES];
+logic   [1:0]  axi_awlock   [NUM_HASHES];
+logic   [2:0]  axi_awprot   [NUM_HASHES];
+logic          axi_awready  [NUM_HASHES];
+logic   [2:0]  axi_awsize   [NUM_HASHES];
+logic          axi_awvalid  [NUM_HASHES];
+logic   [3:0]  axi_bid      [NUM_HASHES];
+logic          axi_bready   [NUM_HASHES];
+logic   [1:0]  axi_bresp    [NUM_HASHES];
+logic          axi_bvalid   [NUM_HASHES];
+logic [255:0]  axi_rdata    [NUM_HASHES];
+logic   [3:0]  axi_rid      [NUM_HASHES];
+logic          axi_rlast    [NUM_HASHES];
+logic          axi_rready   [NUM_HASHES];
+logic   [1:0]  axi_rresp    [NUM_HASHES];
+logic          axi_rvalid   [NUM_HASHES];
+logic [255:0]  axi_wdata    [NUM_HASHES];
+logic          axi_wlast    [NUM_HASHES];
+logic          axi_wready   [NUM_HASHES];
+logic  [31:0]  axi_wstrb    [NUM_HASHES];
+logic          axi_wvalid   [NUM_HASHES];
+
+logic         axis_dm_write_tvalid;
+logic [511:0] axis_dm_write_tdata;
+logic  [63:0] axis_dm_write_tkeep;
+logic         axis_dm_write_tlast;
+logic         axis_dm_write_tready;
+
+logic         axis_dm_read_tvalid;
+logic [511:0] axis_dm_read_tdata;
+logic  [63:0] axis_dm_read_tkeep;
+logic         axis_dm_read_tlast;
+logic         axis_dm_read_tready;
+
+logic         axis_dm_write_cmd_tvalid;
+logic  [79:0] axis_dm_write_cmd_tdata;
+logic         axis_dm_write_cmd_tready;
+
+logic         axis_dm_read_cmd_tvalid;
+logic  [79:0] axis_dm_read_cmd_tdata;
+logic         axis_dm_read_cmd_tready;
+
+logic   [7:0] axis_dm_write_sts_tdata;
+logic         axis_dm_write_sts_tkeep;
+logic         axis_dm_write_sts_tlast;
+logic         axis_dm_write_sts_tvalid;
+logic         axis_dm_write_sts_tready;
+
+logic   [7:0] axis_dm_read_sts_tdata;
+logic         axis_dm_read_sts_tkeep;
+logic         axis_dm_read_sts_tlast;
+logic         axis_dm_read_sts_tvalid;
+logic         axis_dm_read_sts_tready;
+
+logic         axis_parser_to_filter_tvalid;
+logic [511:0] axis_parser_to_filter_tdata;
+logic  [63:0] axis_parser_to_filter_tkeep;
+logic         axis_parser_to_filter_tlast;
+logic  [47:0] axis_parser_to_filter_tuser;
+logic         axis_parser_to_filter_tready;
+
+logic         axis_filter_to_replication_tvalid;
+logic [511:0] axis_filter_to_replication_tdata;
+logic  [63:0] axis_filter_to_replication_tkeep;
+logic         axis_filter_to_replication_tlast;
+logic  [47:0] axis_filter_to_replication_tuser;
+logic         axis_filter_to_replication_tready;
+
+logic         axis_replication_to_deparser_tvalid;
+logic [511:0] axis_replication_to_deparser_tdata;
+logic  [63:0] axis_replication_to_deparser_tkeep;
+logic         axis_replication_to_deparser_tlast;
+logic         axis_replication_to_deparser_tready;
+
+logic         axis_deparser_to_arbiter_tvalid;
+logic [511:0] axis_deparser_to_arbiter_tdata;
+logic  [63:0] axis_deparser_to_arbiter_tkeep;
+logic         axis_deparser_to_arbiter_tlast;
+logic         axis_deparser_to_arbiter_tready;
+
+st_metadata parser_metadata;
+logic       parser_metadata_valid;
+st_metadata replication_metadata;
+logic       replication_metadata_valid;
+
+assign axis_dm_write_sts_tready = 1'b1;
+assign axis_dm_read_sts_tready  = 1'b1;
+
+// The reset waits until the HBM has finished initial configuration
+logic apb_complete_0;
+logic apb_complete_reg;
+logic rstn;
+
+assign rstn = axi_rstn && apb_complete_reg;
+
+always_ff @(posedge axi_clk) begin
+  if(~axi_rstn)
+    apb_complete_reg <= 1'b0;
+  else
+    apb_complete_reg <= apb_complete_0;
+end
+
+// The valid signal for the parser's incoming user metadata is raised only on the first beat
+logic parser_metadata_in_valid;
+logic parser_metadata_in_valid_toggle;
+
+assign parser_metadata_in_valid = parser_metadata_in_valid_toggle && s_axis_cmac_c2h_tvalid && s_axis_cmac_c2h_tready;
+
+always_ff @(posedge axi_clk) begin
+  if(~axi_rstn) begin
+    parser_metadata_in_valid_toggle <= 1'b1;
+  end
+  else begin
+    if (s_axis_cmac_c2h_tvalid && s_axis_cmac_c2h_tready && !s_axis_cmac_c2h_tlast) 
+      parser_metadata_in_valid_toggle <= 1'b0;  
+    if (s_axis_cmac_c2h_tvalid && s_axis_cmac_c2h_tready && s_axis_cmac_c2h_tlast)
+      parser_metadata_in_valid_toggle <= 1'b1;
+  end
+end
+
+// The filter signal from parser is stored until next value
+logic is_replication;
+logic is_replication_reg;
+
+assign axis_parser_to_filter_tdest = parser_metadata_valid ? is_replication : is_replication_reg;
+
+always_ff @(posedge axi_clk) begin
+  if(~axi_rstn)
+    is_replication_reg <= 1'b0;
+  else if (parser_metadata_valid)
+    is_replication_reg <= is_replication;
+end
+
+// Split the QDMA's tuser into each part
+logic [47:0] axis_qdma_c2h_tuser;
+assign m_axis_qdma_c2h_tuser_size = axis_qdma_c2h_tuser[47:32];
+assign m_axis_qdma_c2h_tuser_src  = axis_qdma_c2h_tuser[32:16];
+assign m_axis_qdma_c2h_tuser_dst  = axis_qdma_c2h_tuser[15:0];
+
+replication_subsystem #(
+  .BUCKET_SIZE               (BUCKET_SIZE),
+  .NODE_IP                   (NODE_IP),
+  .NODE_MAC                  (NODE_MAC),
+  .HASH_WIDTH                (HASH_WIDTH),
+  .HASH_MATRIX               (HASH_MATRIX)
+) replication_subsystem_inst (
+  .s_axis_tvalid             (axis_filter_to_replication_tvalid),
+  .s_axis_tdata              (axis_filter_to_replication_tdata),
+  .s_axis_tkeep              (axis_filter_to_replication_tkeep),
+  .s_axis_tlast              (axis_filter_to_replication_tlast),
+  .s_axis_tready             (axis_filter_to_replication_tready),
+  .metadata_in               (parser_metadata),
+  .metadata_in_valid         (parser_metadata_valid && is_replication),
+   
+  .m_axis_tvalid             (axis_replication_to_deparser_tvalid),
+  .m_axis_tdata              (axis_replication_to_deparser_tdata),
+  .m_axis_tkeep              (axis_replication_to_deparser_tkeep),
+  .m_axis_tlast              (axis_replication_to_deparser_tlast),
+  .m_axis_tready             (axis_replication_to_deparser_tready),
+  .metadata_out              (replication_metadata),
+  .metadata_out_valid        (replication_metadata_valid),
+
+  .s_axis_dm_tvalid          (axis_dm_read_tvalid),
+  .s_axis_dm_tdata           (axis_dm_read_tdata),
+  .s_axis_dm_tkeep           (axis_dm_read_tkeep),
+  .s_axis_dm_tlast           (axis_dm_read_tlast),
+  .s_axis_dm_tready          (axis_dm_read_tready),
+
+  .m_axis_dm_tvalid          (axis_dm_write_tvalid),
+  .m_axis_dm_tdata           (axis_dm_write_tdata),
+  .m_axis_dm_tkeep           (axis_dm_write_tkeep),
+  .m_axis_dm_tlast           (axis_dm_write_tlast),
+  .m_axis_dm_tready          (axis_dm_write_tready),
+
+  .m_axis_dm_mm2s_cmd_tvalid (axis_dm_read_cmd_tvalid),
+  .m_axis_dm_mm2s_cmd_tdata  (axis_dm_read_cmd_tdata),
+  .m_axis_dm_mm2s_cmd_tready (axis_dm_read_cmd_tready),
+
+  .m_axis_dm_s2mm_cmd_tvalid (axis_dm_write_cmd_tvalid),
+  .m_axis_dm_s2mm_cmd_tdata  (axis_dm_write_cmd_tdata),
+  .m_axis_dm_s2mm_cmd_tready (axis_dm_write_cmd_tready),
+
+  .m_axi_araddr              (axi_araddr),
+  .m_axi_arburst             (axi_arburst),
+  .m_axi_arid                (axi_arid),
+  .m_axi_arlen               (axi_arlen),
+  .m_axi_arready             (axi_arready),
+  .m_axi_arsize              (axi_arsize),
+  .m_axi_arvalid             (axi_arvalid),
+  .m_axi_awaddr              (axi_awaddr),
+  .m_axi_awburst             (axi_awburst),
+  .m_axi_awid                (axi_awid),
+  .m_axi_awlen               (axi_awlen),
+  .m_axi_awready             (axi_awready),
+  .m_axi_awsize              (axi_awsize),
+  .m_axi_awvalid             (axi_awvalid),
+  .m_axi_bid                 (axi_bid),
+  .m_axi_bready              (axi_bready),
+  .m_axi_bresp               (axi_bresp),
+  .m_axi_bvalid              (axi_bvalid),
+  .m_axi_rdata               (axi_rdata),
+  .m_axi_rid                 (axi_rid),
+  .m_axi_rlast               (axi_rlast),
+  .m_axi_rready              (axi_rready),
+  .m_axi_rresp               (axi_rresp),
+  .m_axi_rvalid              (axi_rvalid),
+  .m_axi_wdata               (axi_wdata),
+  .m_axi_wlast               (axi_wlast),
+  .m_axi_wready              (axi_wready),
+  .m_axi_wstrb               (axi_wstrb),
+  .m_axi_wvalid              (axi_wvalid),
+
+  .axi_clk                   (axi_clk),
+  .axi_rstn                  (rstn)
+);
+
+packet_parser packet_parser_inst (
+  .s_axis_tvalid           (s_axis_cmac_c2h_tvalid), 
+  .s_axis_tdata            (s_axis_cmac_c2h_tdata), 
+  .s_axis_tkeep            (s_axis_cmac_c2h_tkeep), 
+  .s_axis_tlast            (s_axis_cmac_c2h_tlast),
+  .s_axis_tuser            ({s_axis_cmac_c2h_tuser_size, s_axis_cmac_c2h_tuser_src, s_axis_cmac_c2h_tuser_dst}),
+  .s_axis_tready           (s_axis_cmac_c2h_tready), 
+  .user_metadata_in        ('0),
+  .user_metadata_in_valid  (parser_metadata_in_valid),
+
+  .m_axis_tvalid           (axis_parser_to_filter_tvalid), 
+  .m_axis_tdata            (axis_parser_to_filter_tdata), 
+  .m_axis_tkeep            (axis_parser_to_filter_tkeep), 
+  .m_axis_tlast            (axis_parser_to_filter_tlast),
+  .m_axis_tuser            (axis_parser_to_filter_tuser),
+  .m_axis_tready           (axis_parser_to_filter_tready), 
+  .user_metadata_out       ({parser_metadata, is_replication}),
+  .user_metadata_out_valid (parser_metadata_valid),
+
+  .s_axis_aclk             (axi_clk),
+  .s_axis_aresetn          (rstn)
+);
+
+packet_deparser packet_deparser_inst (
+  .s_axis_tvalid           (axis_replication_to_deparser_tvalid), 
+  .s_axis_tdata            (axis_replication_to_deparser_tdata), 
+  .s_axis_tkeep            (axis_replication_to_deparser_tkeep), 
+  .s_axis_tlast            (axis_replication_to_deparser_tlast), 
+  .s_axis_tready           (axis_replication_to_deparser_tready), 
+  .user_metadata_in        ({replication_metadata, NODE_IP, NODE_MAC}),
+  .user_metadata_in_valid  (replication_metadata_valid),
+
+  .m_axis_tvalid           (axis_deparser_to_arbiter_tvalid), 
+  .m_axis_tdata            (axis_deparser_to_arbiter_tdata), 
+  .m_axis_tkeep            (axis_deparser_to_arbiter_tkeep), 
+  .m_axis_tlast            (axis_deparser_to_arbiter_tlast), 
+  .m_axis_tready           (axis_deparser_to_arbiter_tready), 
+  .user_metadata_out       (),
+  .user_metadata_out_valid (),
+
+  .s_axis_aclk             (axi_clk),
+  .s_axis_aresetn          (rstn)
+);
+
+packet_filter packet_filter_inst (
+  .s_axis_tvalid           (axis_parser_to_filter_tvalid), 
+  .s_axis_tdata            (axis_parser_to_filter_tdata),
+  .s_axis_tkeep            (axis_parser_to_filter_tkeep),
+  .s_axis_tlast            (axis_parser_to_filter_tlast),
+  .s_axis_tuser            (axis_parser_to_filter_tuser),
+  .s_axis_tdest            (axis_parser_to_filter_tdest),
+  .s_axis_tready           (axis_parser_to_filter_tready),
+
+  .m_axis_tvalid           ({axis_filter_to_replication_tvalid, m_axis_qdma_c2h_tvalid}),
+  .m_axis_tdata            ({axis_filter_to_replication_tdata, m_axis_qdma_c2h_tdata}),
+  .m_axis_tkeep            ({axis_filter_to_replication_tkeep, m_axis_qdma_c2h_tkeep}),
+  .m_axis_tlast            ({axis_filter_to_replication_tlast, m_axis_qdma_c2h_tlast}),
+  .m_axis_tuser            ({axis_filter_to_replication_tuser, axis_qdma_c2h_tuser}),
+  .m_axis_tdest            (),
+  .m_axis_tready           ({axis_filter_to_replication_tready, m_axis_qdma_c2h_tready}),
+
+  .aclk                    (axi_clk),
+  .aresetn                 (rstn)
+);
+
+packet_arbiter packet_arbiter_inst (
+  .s_axis_tvalid           ({axis_deparser_to_arbiter_tvalid, s_axis_qdma_h2c_tvalid}), 
+  .s_axis_tdata            ({axis_deparser_to_arbiter_tdata, s_axis_qdma_h2c_tdata}),
+  .s_axis_tkeep            ({axis_deparser_to_arbiter_tkeep, s_axis_qdma_h2c_tkeep}),
+  .s_axis_tlast            ({axis_deparser_to_arbiter_tlast, s_axis_qdma_h2c_tlast}),
+  .s_axis_tuser            ({{16'h0, 16'h0, 16'h0040}, {s_axis_qdma_h2c_tuser_size, s_axis_qdma_h2c_tuser_src, s_axis_qdma_h2c_tuser_dst}}),
+  .s_axis_tready           ({axis_deparser_to_arbiter_tready, s_axis_qdma_h2c_tready}),
+
+  .m_axis_tvalid           (m_axis_cmac_h2c_tvalid),
+  .m_axis_tdata            (m_axis_cmac_h2c_tdata),
+  .m_axis_tkeep            (m_axis_cmac_h2c_tkeep),
+  .m_axis_tlast            (m_axis_cmac_h2c_tlast),
+  .m_axis_tuser            ({m_axis_cmac_h2c_tuser_size, m_axis_cmac_h2c_tuser_src, m_axis_cmac_h2c_tuser_dst}),
+  .m_axis_tready           (m_axis_cmac_h2c_tready),
+
+  .s_req_suppress          (2'b0),
+  .aclk                    (axi_clk),
+  .aresetn                 (rstn)
+);
+
+hbm_bd_wrapper hbm_inst (
+  .s_axi_hbm_araddr                (s_axi_araddr),
+  .s_axi_hbm_arburst               (s_axi_arburst),
+  .s_axi_hbm_arcache               (s_axi_arcache),
+  .s_axi_hbm_arid                  (s_axi_arid),
+  .s_axi_hbm_arlen                 (s_axi_arlen),
+  .s_axi_hbm_arlock                (s_axi_arlock),
+  .s_axi_hbm_arprot                (s_axi_arprot),
+  .s_axi_hbm_arqos                 (s_axi_arqos),
+  .s_axi_hbm_arready               (s_axi_arready),
+  .s_axi_hbm_arsize                (s_axi_arsize),
+  .s_axi_hbm_aruser                (s_axi_aruser),
+  .s_axi_hbm_arvalid               (s_axi_arvalid),
+  .s_axi_hbm_awaddr                (s_axi_awaddr),
+  .s_axi_hbm_awburst               (s_axi_awburst),
+  .s_axi_hbm_awcache               (s_axi_awcache),
+  .s_axi_hbm_awid                  (s_axi_awid),
+  .s_axi_hbm_awlen                 (s_axi_awlen),
+  .s_axi_hbm_awlock                (s_axi_awlock),
+  .s_axi_hbm_awprot                (s_axi_awprot),
+  .s_axi_hbm_awqos                 (s_axi_awqos),
+  .s_axi_hbm_awready               (s_axi_awready),
+  .s_axi_hbm_awsize                (s_axi_awsize),
+  .s_axi_hbm_awuser                (s_axi_awuser),
+  .s_axi_hbm_awvalid               (s_axi_awvalid),
+  .s_axi_hbm_bid                   (s_axi_bid),
+  .s_axi_hbm_bready                (s_axi_bready),
+  .s_axi_hbm_bresp                 (s_axi_bresp),
+  .s_axi_hbm_bvalid                (s_axi_bvalid),
+  .s_axi_hbm_rdata                 (s_axi_rdata),
+  .s_axi_hbm_rid                   (s_axi_rid),
+  .s_axi_hbm_rlast                 (s_axi_rlast),
+  .s_axi_hbm_rready                (s_axi_rready),
+  .s_axi_hbm_rresp                 (s_axi_rresp),
+  .s_axi_hbm_rvalid                (s_axi_rvalid),
+  .s_axi_hbm_wdata                 (s_axi_wdata),
+  .s_axi_hbm_wlast                 (s_axi_wlast),
+  .s_axi_hbm_wready                (s_axi_wready),
+  .s_axi_hbm_wstrb                 (s_axi_wstrb),
+  .s_axi_hbm_wuser                 (s_axi_wuser),
+  .s_axi_hbm_wvalid                (s_axi_wvalid),
+
+  .s_axi_0_araddr                  (axi_araddr[0]),
+  .s_axi_0_arburst                 (axi_arburst[0]),
+  .s_axi_0_arid                    (axi_arid[0]),
+  .s_axi_0_arlen                   (axi_arlen[0]),
+  .s_axi_0_arready                 (axi_arready[0]),
+  .s_axi_0_arsize                  (axi_arsize[0]),
+  .s_axi_0_arvalid                 (axi_arvalid[0]),
+  .s_axi_0_awaddr                  (axi_awaddr[0]),
+  .s_axi_0_awburst                 (axi_awburst[0]),
+  .s_axi_0_awid                    (axi_awid[0]),
+  .s_axi_0_awlen                   (axi_awlen[0]),
+  .s_axi_0_awready                 (axi_awready[0]),
+  .s_axi_0_awsize                  (axi_awsize[0]),
+  .s_axi_0_awvalid                 (axi_awvalid[0]),
+  .s_axi_0_bid                     (axi_bid[0]),
+  .s_axi_0_bready                  (axi_bready[0]),
+  .s_axi_0_bresp                   (axi_bresp[0]),
+  .s_axi_0_bvalid                  (axi_bvalid[0]),
+  .s_axi_0_rdata                   (axi_rdata[0]),
+  .s_axi_0_rid                     (axi_rid[0]),
+  .s_axi_0_rlast                   (axi_rlast[0]),
+  .s_axi_0_rready                  (axi_rready[0]),
+  .s_axi_0_rresp                   (axi_rresp[0]),
+  .s_axi_0_rvalid                  (axi_rvalid[0]),
+  .s_axi_0_wdata                   (axi_wdata[0]),
+  .s_axi_0_wlast                   (axi_wlast[0]),
+  .s_axi_0_wready                  (axi_wready[0]),
+  .s_axi_0_wstrb                   (axi_wstrb[0]),
+  .s_axi_0_wvalid                  (axi_wvalid[0]),
+
+  .s_axi_1_araddr                  (axi_araddr[1]),
+  .s_axi_1_arburst                 (axi_arburst[1]),
+  .s_axi_1_arid                    (axi_arid[1]),
+  .s_axi_1_arlen                   (axi_arlen[1]),
+  .s_axi_1_arready                 (axi_arready[1]),
+  .s_axi_1_arsize                  (axi_arsize[1]),
+  .s_axi_1_arvalid                 (axi_arvalid[1]),
+  .s_axi_1_awaddr                  (axi_awaddr[1]),
+  .s_axi_1_awburst                 (axi_awburst[1]),
+  .s_axi_1_awid                    (axi_awid[1]),
+  .s_axi_1_awlen                   (axi_awlen[1]),
+  .s_axi_1_awready                 (axi_awready[1]),
+  .s_axi_1_awsize                  (axi_awsize[1]),
+  .s_axi_1_awvalid                 (axi_awvalid[1]),
+  .s_axi_1_bid                     (axi_bid[1]),
+  .s_axi_1_bready                  (axi_bready[1]),
+  .s_axi_1_bresp                   (axi_bresp[1]),
+  .s_axi_1_bvalid                  (axi_bvalid[1]),
+  .s_axi_1_rdata                   (axi_rdata[1]),
+  .s_axi_1_rid                     (axi_rid[1]),
+  .s_axi_1_rlast                   (axi_rlast[1]),
+  .s_axi_1_rready                  (axi_rready[1]),
+  .s_axi_1_rresp                   (axi_rresp[1]),
+  .s_axi_1_rvalid                  (axi_rvalid[1]),
+  .s_axi_1_wdata                   (axi_wdata[1]),
+  .s_axi_1_wlast                   (axi_wlast[1]),
+  .s_axi_1_wready                  (axi_wready[1]),
+  .s_axi_1_wstrb                   (axi_wstrb[1]),
+  .s_axi_1_wvalid                  (axi_wvalid[1]),
+
+  .s_axi_2_araddr                  (axi_araddr[2]),
+  .s_axi_2_arburst                 (axi_arburst[2]),
+  .s_axi_2_arid                    (axi_arid[2]),
+  .s_axi_2_arlen                   (axi_arlen[2]),
+  .s_axi_2_arready                 (axi_arready[2]),
+  .s_axi_2_arsize                  (axi_arsize[2]),
+  .s_axi_2_arvalid                 (axi_arvalid[2]),
+  .s_axi_2_awaddr                  (axi_awaddr[2]),
+  .s_axi_2_awburst                 (axi_awburst[2]),
+  .s_axi_2_awid                    (axi_awid[2]),
+  .s_axi_2_awlen                   (axi_awlen[2]),
+  .s_axi_2_awready                 (axi_awready[2]),
+  .s_axi_2_awsize                  (axi_awsize[2]),
+  .s_axi_2_awvalid                 (axi_awvalid[2]),
+  .s_axi_2_bid                     (axi_bid[2]),
+  .s_axi_2_bready                  (axi_bready[2]),
+  .s_axi_2_bresp                   (axi_bresp[2]),
+  .s_axi_2_bvalid                  (axi_bvalid[2]),
+  .s_axi_2_rdata                   (axi_rdata[2]),
+  .s_axi_2_rid                     (axi_rid[2]),
+  .s_axi_2_rlast                   (axi_rlast[2]),
+  .s_axi_2_rready                  (axi_rready[2]),
+  .s_axi_2_rresp                   (axi_rresp[2]),
+  .s_axi_2_rvalid                  (axi_rvalid[2]),
+  .s_axi_2_wdata                   (axi_wdata[2]),
+  .s_axi_2_wlast                   (axi_wlast[2]),
+  .s_axi_2_wready                  (axi_wready[2]),
+  .s_axi_2_wstrb                   (axi_wstrb[2]),
+  .s_axi_2_wvalid                  (axi_wvalid[2]),
+
+  .s_axi_3_araddr                  (axi_araddr[3]),
+  .s_axi_3_arburst                 (axi_arburst[3]),
+  .s_axi_3_arid                    (axi_arid[3]),
+  .s_axi_3_arlen                   (axi_arlen[3]),
+  .s_axi_3_arready                 (axi_arready[3]),
+  .s_axi_3_arsize                  (axi_arsize[3]),
+  .s_axi_3_arvalid                 (axi_arvalid[3]),
+  .s_axi_3_awaddr                  (axi_awaddr[3]),
+  .s_axi_3_awburst                 (axi_awburst[3]),
+  .s_axi_3_awid                    (axi_awid[3]),
+  .s_axi_3_awlen                   (axi_awlen[3]),
+  .s_axi_3_awready                 (axi_awready[3]),
+  .s_axi_3_awsize                  (axi_awsize[3]),
+  .s_axi_3_awvalid                 (axi_awvalid[3]),
+  .s_axi_3_bid                     (axi_bid[3]),
+  .s_axi_3_bready                  (axi_bready[3]),
+  .s_axi_3_bresp                   (axi_bresp[3]),
+  .s_axi_3_bvalid                  (axi_bvalid[3]),
+  .s_axi_3_rdata                   (axi_rdata[3]),
+  .s_axi_3_rid                     (axi_rid[3]),
+  .s_axi_3_rlast                   (axi_rlast[3]),
+  .s_axi_3_rready                  (axi_rready[3]),
+  .s_axi_3_rresp                   (axi_rresp[3]),
+  .s_axi_3_rvalid                  (axi_rvalid[3]),
+  .s_axi_3_wdata                   (axi_wdata[3]),
+  .s_axi_3_wlast                   (axi_wlast[3]),
+  .s_axi_3_wready                  (axi_wready[3]),
+  .s_axi_3_wstrb                   (axi_wstrb[3]),
+  .s_axi_3_wvalid                  (axi_wvalid[3]),
+
+  .s_axis_dm_s2mm_tvalid           (axis_dm_write_tvalid),
+  .s_axis_dm_s2mm_tdata            (axis_dm_write_tdata),
+  .s_axis_dm_s2mm_tkeep            (axis_dm_write_tkeep),
+  .s_axis_dm_s2mm_tlast            (axis_dm_write_tlast),
+  .s_axis_dm_s2mm_tready           (axis_dm_write_tready),
+
+  .m_axis_dm_mm2s_tvalid           (axis_dm_read_tvalid),
+  .m_axis_dm_mm2s_tdata            (axis_dm_read_tdata),
+  .m_axis_dm_mm2s_tkeep            (axis_dm_read_tkeep),
+  .m_axis_dm_mm2s_tlast            (axis_dm_read_tlast),
+  .m_axis_dm_mm2s_tready           (axis_dm_read_tready),
+
+  .s_axis_dm_s2mm_cmd_tvalid       (axis_dm_write_cmd_tvalid),
+  .s_axis_dm_s2mm_cmd_tdata        (axis_dm_write_cmd_tdata),
+  .s_axis_dm_s2mm_cmd_tready       (axis_dm_write_cmd_tready),
+
+  .s_axis_dm_mm2s_cmd_tvalid       (axis_dm_read_cmd_tvalid),
+  .s_axis_dm_mm2s_cmd_tdata        (axis_dm_read_cmd_tdata),
+  .s_axis_dm_mm2s_cmd_tready       (axis_dm_read_cmd_tready),
+
+  .m_axis_dm_s2mm_status_tdata     (axis_dm_write_sts_tdata),
+  .m_axis_dm_s2mm_status_tkeep     (axis_dm_write_sts_tkeep),
+  .m_axis_dm_s2mm_status_tlast     (axis_dm_write_sts_tlast),
+  .m_axis_dm_s2mm_status_tvalid    (axis_dm_write_sts_tvalid),
+  .m_axis_dm_s2mm_status_tready    (axis_dm_write_sts_tready),
+
+  .m_axis_dm_mm2s_status_tdata     (axis_dm_read_sts_tdata),
+  .m_axis_dm_mm2s_status_tkeep     (axis_dm_read_sts_tkeep),
+  .m_axis_dm_mm2s_status_tlast     (axis_dm_read_sts_tlast),
+  .m_axis_dm_mm2s_status_tvalid    (axis_dm_read_sts_tvalid),
+  .m_axis_dm_mm2s_status_tready    (axis_dm_read_sts_tready),
+
+  .apb_complete_0                  (apb_complete_0),
+  .apb_complete_1                  (),
+  .axi_clk                         (axi_clk),
+  .axi_resetn                      (axi_rstn),
+  .hbm_ref_clk                     (hbm_ref_clk)
+);
+
+endmodule
\ No newline at end of file
diff --git a/src/hbm_subsystem/memory_controller/bvalid_buffer.sv b/src/hbm_subsystem/memory_controller/bvalid_buffer.sv
new file mode 100644
index 0000000..bfa4dc3
--- /dev/null
+++ b/src/hbm_subsystem/memory_controller/bvalid_buffer.sv
@@ -0,0 +1,69 @@
+// typedef struct packed {
+//   logic          [31:0] ip;      // IPv4 address of the sender
+//   logic          [47:0] mac;     // Mac address of the sender
+//   logic           [7:0] id;      // Operation identifier used to distinguish consecutive writes
+//   logic           [7:0] opcode;  // Operation code
+//   logic          [63:0] key;
+// } st_metadata;
+
+module bvalid_buffer #(
+  parameter DEPTH      = 64,
+  parameter PTR_WIDTH  = $clog2(DEPTH)
+)(
+  input  logic         aclk,
+  input  logic         aresetn,
+
+  // Slave side (no ready)
+  input  logic         s_bresp,
+  input  logic         s_bvalid,
+
+  // Master side (with ready)
+  output logic         m_bvalid,
+  output logic         m_bresp,
+  input  logic         m_bready
+
+);
+
+  // Memory Buffers
+  logic mem [DEPTH-1:0];
+
+  // Write & Read pointers
+  logic [PTR_WIDTH-1:0] write_ptr;
+  logic [PTR_WIDTH-1:0] read_ptr;
+
+  // Counter
+  logic [PTR_WIDTH-1:0] count;
+
+always_ff @(posedge aclk or negedge aresetn) begin
+  if (!aresetn) begin
+    write_ptr <= '0;
+    read_ptr  <= '0;
+    count     <= '0;
+  end 
+  else begin
+    // Write
+    if (s_bvalid) begin
+      mem[write_ptr] <= s_bresp;
+      write_ptr      <= write_ptr + 1;
+      if (count < (DEPTH-1))
+        count <= count + 1;
+    end
+
+    // Read
+    if (m_bvalid && m_bready) begin
+      read_ptr <= read_ptr + 1;
+      count    <= count - 1;
+    end
+  end
+end
+
+  logic m_resp;
+  always_comb begin
+  m_resp = 1'b0;
+  end
+
+  assign m_bvalid = (count != 0);
+  assign m_bresp  = m_bready? mem[read_ptr] :m_resp;
+  
+
+endmodule
\ No newline at end of file
diff --git a/src/hbm_subsystem/memory_controller/memory_controller.sv b/src/hbm_subsystem/memory_controller/memory_controller.sv
new file mode 100644
index 0000000..b023d8f
--- /dev/null
+++ b/src/hbm_subsystem/memory_controller/memory_controller.sv
@@ -0,0 +1,945 @@
+`timescale 1ns / 1ps
+//////////////////////////////////////////////////////////////////////////////////
+// Company: 
+// Engineer: 
+// 
+// Create Date: 09/01/2025 10:21:43 AM
+// Design Name: 
+// Module Name: Memory_Controller
+// Project Name: 
+// Target Devices: 
+// Tool Versions: 
+// Description: 
+// 
+// Dependencies: 
+// 
+// Revision: 
+// Revision 0.02 - File Created  
+// Additional Comments: 
+// 
+//////////////////////////////////////////////////////////////////////////////////
+
+
+module memory_controller #(
+    parameter  int BUCKET_SIZE       = 1024,
+    parameter  int CMD_WIDTH         = 80,
+    parameter  int CMD_STATUS_WIDTH  = 8,
+    parameter  int DATA_WIDTH        = 512,
+    parameter  int TKEEP_WIDTH       = DATA_WIDTH/8,
+    parameter  int TUSER_WIDTH       = 16,
+    parameter  int CMD_FIFO_DEPTH    = 32,
+    parameter  int STREAM_FIFO_DEPTH = 64,
+    parameter  int KEY_WIDTH         = 64,
+    localparam int HASH_WIDTH        = 34 - $clog2(BUCKET_SIZE)
+)(
+    
+    // 250Mhz Memory Controller Clock & Reset.
+    input logic                         aclk,
+    input logic                         aresetn,
+    
+    // HBM Stack Interface complete (FSM Starters)
+    input logic                         abp_complete0,
+
+    // Master AXI-Stream signals [To Replication Engine]
+    input  logic                        m_axis_tready,
+    output logic [DATA_WIDTH-1:0]       m_axis_tdata,
+    output logic [TKEEP_WIDTH-1:0]      m_axis_tkeep,
+    output logic                        m_axis_tlast,
+    output logic                        m_axis_tvalid,
+
+    // Master AXI-Stream signals [From DataMover]
+    output logic                        s_dm_axis_tready,
+    input  logic [DATA_WIDTH-1:0]       s_dm_axis_tdata,
+    input  logic [TKEEP_WIDTH-1:0]      s_dm_axis_tkeep,
+    input  logic                        s_dm_axis_tlast,
+    input  logic                        s_dm_axis_tvalid,
+
+    // Slave AXI-Stream signals [From Replication Engine]
+    output logic                        s_axis_tready,
+    input  logic [DATA_WIDTH-1:0]       s_axis_tdata,
+    input  logic [TKEEP_WIDTH-1:0]      s_axis_tkeep,
+    input  logic                        s_axis_tlast,
+    input  logic                        s_axis_tvalid,
+
+    // Slave AXI-Stream signals [To DataMover]
+    input  logic                        m_dm_axis_tready,
+    output logic [DATA_WIDTH-1:0]       m_dm_axis_tdata,
+    output logic [TKEEP_WIDTH-1:0]      m_dm_axis_tkeep,
+    output logic                        m_dm_axis_tlast,
+    output logic                        m_dm_axis_tvalid,
+    
+    // Metadata mem_in
+    input  st_metadata                  metadata_mem_in,
+    input  logic                        metadata_mem_in_valid,
+
+    // Metadata mem_out
+    output st_metadata                  metadata_mem_out,
+    output logic                        metadata_mem_out_valid,
+
+    // Bvalid in
+    input  logic [1:0]                  s_bresp,
+    input  logic                        s_bvalid,
+    input  logic                        s_bready,
+
+    // MM2S Commands
+    input  logic                        mm2s_cmd_tready,
+    output logic [CMD_WIDTH-1:0]        mm2s_cmd_tdata,
+    output logic                        mm2s_cmd_tvalid,
+
+    // S2MM Commands
+    input  logic                        s2mm_cmd_tready,
+    output logic [CMD_WIDTH-1:0]        s2mm_cmd_tdata,
+    output logic                        s2mm_cmd_tvalid,
+
+    // MM2S Status
+    input  logic [CMD_STATUS_WIDTH-1:0] s_axis_mm2s_sts_tdata,
+    input  logic                        s_axis_mm2s_sts_tkeep,
+    input  logic                        s_axis_mm2s_sts_tlast,
+    input  logic                        s_axis_mm2s_sts_tvalid,
+    output logic                        s_axis_mm2s_sts_tready,
+
+    // S2MM Status
+    input  logic [CMD_STATUS_WIDTH-1:0] s_axis_s2mm_sts_tdata,
+    input  logic                        s_axis_s2mm_sts_tkeep,
+    input  logic                        s_axis_s2mm_sts_tlast,
+    input  logic                        s_axis_s2mm_sts_tvalid,
+    output logic                        s_axis_s2mm_sts_tready
+
+    );
+
+
+    // BTT
+    localparam logic [22:0] BTT = 23'h400;
+
+
+    //////////////////////////////////////////////////////////////////
+    // Hash Mechanism
+    //////////////////////////////////////////////////////////////////
+
+    // Precomputed pseudo-random 34-bit constants
+    localparam logic [HASH_WIDTH-1:0] HASH_MATRIX [KEY_WIDTH-1:0] = '{
+        24'hA3C5D1, 24'hD4F921, 24'h98B337, 24'h345678,
+        24'hEAD00F, 24'hADC0DE, 24'h55AAAA, 24'hACE123,
+        24'hF23456, 24'hBEEF12, 24'h0FFEE0, 24'hBADB07,
+        24'hBCDEF0, 24'hBCDE12, 24'h4679BD, 24'h2468AC,
+        24'hAAAAAA, 24'hBBBBBB, 24'hCCCCCC, 24'h234567,
+        24'h654321, 24'hEDCBA9, 24'hACEACE, 24'hC001D0,
+        24'hEADC0D, 24'hADD00D, 24'h0DEC0D, 24'hDCAFE,
+        24'h3579BF, 24'h468ACE, 24'h579BDF, 24'h68ACED,
+        24'h55AAAA, 24'h66BBBB, 24'h77CCCC, 24'h88DDDD,
+        24'h99EEEE, 24'hAAFFFF, 24'hBBB111, 24'hCCC222,
+        24'hDDD333, 24'hEEE444, 24'hFFF555, 24'h111222,
+        24'h222333, 24'h333444, 24'h444555, 24'h555666,
+        24'h666777, 24'h777888, 24'h888999, 24'h999AAA,
+        24'hAAA111, 24'hBBB222, 24'hCCC333, 24'hDDD444,
+        24'hEEE555, 24'hFFF666, 24'h2345AB, 24'hDC123,
+        24'h4567CD, 24'h6789EF, 24'h89AB12, 24'hBCDEF3
+    };
+
+    //Hash function
+    function automatic logic [HASH_WIDTH-1:0] hash (
+        input logic  [KEY_WIDTH-1:0] key,
+        input logic [HASH_WIDTH-1:0] matrix [KEY_WIDTH-1:0]
+    );
+        logic [HASH_WIDTH-1:0] accumulator = '0;
+        for (int i = 0; i < KEY_WIDTH; i = i + 1)
+            if (key[i])
+                accumulator ^= matrix[i];
+        return accumulator;
+    endfunction
+
+    //////////////////////////////////////////////////////////////////
+    // B VALID Buffers
+    //////////////////////////////////////////////////////////////////
+
+    // Global Bvalid Buffer signals
+    logic         m_bvalid_buff;
+    logic         m_bresp_buff;
+    logic         m_bready_buff;
+
+    bvalid_buffer #(
+        .DEPTH(CMD_FIFO_DEPTH)
+    ) bvalid_in_buffer (
+        .aclk               (aclk),
+        .aresetn            (aresetn),
+
+        .s_bvalid           (s_bvalid),
+        .s_bresp            (s_bready),
+
+        .m_bvalid           (m_bvalid_buff),
+        .m_bresp            (m_bresp_buff),
+        .m_bready           (m_bready_buff)
+    );
+
+    //////////////////////////////////////////////////////////////////
+    // Metadata Buffers
+    //////////////////////////////////////////////////////////////////
+
+    // Global Metadata Buffer signals
+    st_metadata metadata_tdata_buff;
+    logic       metadata_tvalid_buff;
+    logic       metadata_tready_buff;
+
+    metadata_buffer #(
+        .DEPTH(CMD_FIFO_DEPTH)
+    ) metadata_in_buffer (
+        .aclk               (aclk),
+        .aresetn            (aresetn),
+
+        .s_valid            (metadata_mem_in_valid),
+        .s_data             (metadata_mem_in),
+
+        .m_valid            (metadata_tvalid_buff),
+        .m_data             (metadata_tdata_buff),
+        .m_ready            (metadata_tready_buff)
+    );
+
+    // Write Metadata Buffer signals
+    st_metadata s2mm_wr_meta_tdata;
+    logic       s2mm_wr_meta_tvalid;
+
+    st_metadata s2mm_rd_meta_tdata;
+    logic       s2mm_rd_meta_tvalid;
+    logic       s2mm_rd_meta_tready;
+
+    metadata_buffer #(
+        .DEPTH(CMD_FIFO_DEPTH/2)
+    ) wr_metadata_buffer (
+        .aclk               (aclk),
+        .aresetn            (aresetn),
+
+        .s_valid            (s2mm_wr_meta_tvalid),
+        .s_data             (s2mm_wr_meta_tdata),
+
+        .m_valid            (s2mm_rd_meta_tvalid),
+        .m_data             (s2mm_rd_meta_tdata),
+        .m_ready            (s2mm_rd_meta_tready)
+    );
+
+    // Read Metadata Buffer signals
+    st_metadata mm2s_wr_meta_tdata;
+    logic       mm2s_wr_meta_tvalid;
+
+    st_metadata mm2s_rd_meta_tdata;
+    logic       mm2s_rd_meta_tvalid;
+    logic       mm2s_rd_meta_tready;
+
+    metadata_buffer #(
+        .DEPTH(CMD_FIFO_DEPTH/2)
+    ) rd_metadata_buffer (
+        .aclk               (aclk),
+        .aresetn            (aresetn),
+
+        .s_valid            (mm2s_wr_meta_tvalid),
+        .s_data             (mm2s_wr_meta_tdata),
+
+        .m_valid            (mm2s_rd_meta_tvalid),
+        .m_data             (mm2s_rd_meta_tdata),
+        .m_ready            (mm2s_rd_meta_tready)
+    );
+
+    //////////////////////////////////////////////////////////////////
+    // AXI-Stream Buffer [Write]
+    //////////////////////////////////////////////////////////////////
+
+    // Stream Buffer signals
+    logic [DATA_WIDTH-1:0]  s_tdata_buff;
+    logic [TKEEP_WIDTH-1:0] s_tkeep_buff;
+    logic                   s_tvalid_buff;
+    logic                   s_tlast_buff;
+    logic                   s_tready_buff;
+
+    // stream_buffer #(
+    //     .DATA_WIDTH (DATA_WIDTH),
+    //     .KEEP_WIDTH (TKEEP_WIDTH),
+    //     .DEPTH      (STREAM_FIFO_DEPTH)
+    // ) s2mm_stream_buffer_inst (
+    //     .aclk               (aclk),
+    //     .aresetn            (aresetn),
+    //     //Slave
+    //     .s_axis_tdata       (s_axis_tdata),
+    //     .s_axis_tkeep       (s_axis_tkeep),
+    //     .s_axis_tvalid      (s_axis_tvalid),
+    //     .s_axis_tlast       (s_axis_tlast),
+    //     .s_axis_tready      (s_axis_tready),
+    //     //Master
+    //     .m_axis_tdata       (s_tdata_buff),
+    //     .m_axis_tkeep       (s_tkeep_buff),
+    //     .m_axis_tvalid      (s_tvalid_buff),
+    //     .m_axis_tlast       (s_tlast_buff),
+    //     .m_axis_tready      (s_tready_buff)
+    // );
+
+    logic s2mm_stream_buffer_full;
+    logic s2mm_stream_buffer_empty;
+
+    assign s_axis_tready = !s2mm_stream_buffer_full;
+    assign s_tvalid_buff = !s2mm_stream_buffer_empty;
+
+    xpm_fifo_sync #(
+        .DOUT_RESET_VALUE    ("0"),
+        .ECC_MODE            ("no_ecc"),
+        .FIFO_MEMORY_TYPE    ("auto"),
+        .FIFO_READ_LATENCY   (1),
+        .FIFO_WRITE_DEPTH    (STREAM_FIFO_DEPTH),
+        .PROG_FULL_THRESH    (STREAM_FIFO_DEPTH-5),
+        .READ_DATA_WIDTH     (DATA_WIDTH + TKEEP_WIDTH + 1),
+        .READ_MODE           ("fwft"),
+        .WRITE_DATA_WIDTH    (DATA_WIDTH + TKEEP_WIDTH + 1)
+    ) s2mm_stream_buffer_inst (
+        .wr_en               (s_axis_tvalid),
+        .din                 ({s_axis_tdata, s_axis_tkeep, s_axis_tlast}),
+        .wr_ack              (),
+        .rd_en               (s_tready_buff),
+        .data_valid          (),
+        .dout                ({s_tdata_buff, s_tkeep_buff, s_tlast_buff}),
+        .wr_data_count       (),
+        .rd_data_count       (),
+        .empty               (s2mm_stream_buffer_empty),
+        .full                (s2mm_stream_buffer_full),
+        .almost_empty        (),
+        .almost_full         (),
+        .overflow            (),
+        .underflow           (),
+        .prog_empty          (),
+        .prog_full           (),
+        .sleep               (1'b0),
+        .sbiterr             (),
+        .dbiterr             (),
+        .injectsbiterr       (1'b0),
+        .injectdbiterr       (1'b0),
+        .wr_clk              (aclk),
+        .rst                 (~aresetn),
+        .rd_rst_busy         (),
+        .wr_rst_busy         ()
+        );
+
+    //////////////////////////////////////////////////////////////////
+    // Synchronization [Write]
+    //////////////////////////////////////////////////////////////////
+
+    // Synchronizer signals
+    logic command_sent;
+    logic stream_sent;
+    logic stream_enable;
+
+    synchronizer #(
+        .N(16)
+    ) synchronizer_inst (
+        .aclk               (aclk),
+        .aresetn            (aresetn),
+
+        .s2mm_cmd_start     (abp_complete0),
+
+        .command_sent       (command_sent),
+        .stream_sent        (stream_sent),
+        .stream_enable      (stream_enable)
+    );
+
+    //////////////////////////////////////////////////////////////////
+    // AXI-Stream Buffer [Write Ack]
+    //////////////////////////////////////////////////////////////////
+
+    // Ack Stream Buffer signals
+    logic [DATA_WIDTH-1:0]  s_ack_tdata_buff;
+    logic [TKEEP_WIDTH-1:0] s_ack_tkeep_buff;
+    logic                   s_ack_tvalid_buff;
+    logic                   s_ack_tlast_buff;
+    logic                   s_ack_tready_buff;
+
+    logic [DATA_WIDTH-1:0]  m_ack_tdata_buff;
+    logic [TKEEP_WIDTH-1:0] m_ack_tkeep_buff;
+    logic                   m_ack_tvalid_buff;
+    logic                   m_ack_tlast_buff;
+    logic                   m_ack_tready_buff;
+
+    // stream_buffer #(
+    //     .DATA_WIDTH (DATA_WIDTH),
+    //     .KEEP_WIDTH (TKEEP_WIDTH),
+    //     .DEPTH      (STREAM_FIFO_DEPTH/2)
+    // ) writeack_stream_buffer_inst (
+    //     .aclk               (aclk),
+    //     .aresetn            (aresetn),
+    //     //Slave
+    //     .s_axis_tdata       (s_ack_tdata_buff),
+    //     .s_axis_tkeep       (s_ack_tkeep_buff),
+    //     .s_axis_tvalid      (s_ack_tvalid_buff),
+    //     .s_axis_tlast       (s_ack_tlast_buff),
+    //     .s_axis_tready      (s_ack_tready_buff),
+    //     //Master
+    //     .m_axis_tdata       (m_ack_tdata_buff),
+    //     .m_axis_tkeep       (m_ack_tkeep_buff),
+    //     .m_axis_tvalid      (m_ack_tvalid_buff),
+    //     .m_axis_tlast       (m_ack_tlast_buff),
+    //     .m_axis_tready      (m_ack_tready_buff)
+    // );
+
+    logic wa_stream_buffer_full;
+    logic wa_stream_buffer_empty;
+
+    assign s_ack_tready_buff = !wa_stream_buffer_full;
+    assign m_ack_tvalid_buff = !wa_stream_buffer_empty;
+
+    xpm_fifo_sync #(
+        .DOUT_RESET_VALUE    ("0"),
+        .ECC_MODE            ("no_ecc"),
+        .FIFO_MEMORY_TYPE    ("auto"),
+        .FIFO_READ_LATENCY   (1),
+        .FIFO_WRITE_DEPTH    (STREAM_FIFO_DEPTH),
+        .PROG_FULL_THRESH    (STREAM_FIFO_DEPTH-5),
+        .READ_DATA_WIDTH     (DATA_WIDTH + TKEEP_WIDTH + 1),
+        .READ_MODE           ("fwft"),
+        .WRITE_DATA_WIDTH    (DATA_WIDTH + TKEEP_WIDTH + 1)
+    ) wa_stream_buffer_inst (
+        .wr_en               (s_ack_tvalid_buff),
+        .din                 ({s_ack_tdata_buff, s_ack_tkeep_buff, s_ack_tlast_buff}),
+        .wr_ack              (),
+        .rd_en               (m_ack_tready_buff),
+        .data_valid          (),
+        .dout                ({m_ack_tdata_buff, m_ack_tkeep_buff, m_ack_tlast_buff}),
+        .wr_data_count       (),
+        .rd_data_count       (),
+        .empty               (wa_stream_buffer_empty),
+        .full                (wa_stream_buffer_full),
+        .almost_empty        (),
+        .almost_full         (),
+        .overflow            (),
+        .underflow           (),
+        .prog_empty          (),
+        .prog_full           (),
+        .sleep               (1'b0),
+        .sbiterr             (),
+        .dbiterr             (),
+        .injectsbiterr       (1'b0),
+        .injectdbiterr       (1'b0),
+        .wr_clk              (aclk),
+        .rst                 (~aresetn),
+        .rd_rst_busy         (),
+        .wr_rst_busy         ()
+    );
+
+    //////////////////////////////////////////////////////////////////
+    // AXI-Stream Buffer [Read]
+    //////////////////////////////////////////////////////////////////
+
+    // Stream Buffer signals
+    logic [DATA_WIDTH-1:0]  m_tdata_buff;
+    logic [TKEEP_WIDTH-1:0] m_tkeep_buff;
+    logic                   m_tvalid_buff;
+    logic                   m_tlast_buff;
+    logic                   m_tready_buff;
+
+    // stream_buffer #(
+    //     .DATA_WIDTH (DATA_WIDTH),
+    //     .KEEP_WIDTH (TKEEP_WIDTH),
+    //     .DEPTH      (STREAM_FIFO_DEPTH*2)
+    // ) mm2s_stream_buffer_inst (
+    //     .aclk             (aclk),
+    //     .aresetn          (aresetn),
+    //     //Slave
+    //     .s_axis_tdata     (s_dm_axis_tdata),
+    //     .s_axis_tkeep     (s_dm_axis_tkeep),
+    //     .s_axis_tvalid    (s_dm_axis_tvalid),
+    //     .s_axis_tlast     (s_dm_axis_tlast),
+    //     .s_axis_tready    (s_dm_axis_tready),
+    //     //Master
+    //     .m_axis_tdata     (m_tdata_buff),
+    //     .m_axis_tkeep     (m_tkeep_buff),
+    //     .m_axis_tvalid    (m_tvalid_buff),
+    //     .m_axis_tlast     (m_tlast_buff),
+    //     .m_axis_tready    (m_tready_buff)
+    // );
+
+    logic mm2s_stream_buffer_full;
+    logic mm2s_stream_buffer_empty;
+
+    assign s_dm_axis_tready = !mm2s_stream_buffer_full;
+    assign m_tvalid_buff    = !mm2s_stream_buffer_empty;
+
+    xpm_fifo_sync #(
+        .DOUT_RESET_VALUE    ("0"),
+        .ECC_MODE            ("no_ecc"),
+        .FIFO_MEMORY_TYPE    ("auto"),
+        .FIFO_READ_LATENCY   (1),
+        .FIFO_WRITE_DEPTH    (STREAM_FIFO_DEPTH),
+        .PROG_FULL_THRESH    (STREAM_FIFO_DEPTH-5),
+        .READ_DATA_WIDTH     (DATA_WIDTH + TKEEP_WIDTH + 1),
+        .READ_MODE           ("fwft"),
+        .WRITE_DATA_WIDTH    (DATA_WIDTH + TKEEP_WIDTH + 1)
+    ) mm2s_stream_buffer_inst (
+        .wr_en               (s_dm_axis_tvalid),
+        .din                 ({s_dm_axis_tdata, s_dm_axis_tkeep, s_dm_axis_tlast}),
+        .wr_ack              (),
+        .rd_en               (m_tready_buff),
+        .data_valid          (),
+        .dout                ({m_tdata_buff, m_tkeep_buff, m_tlast_buff}),
+        .wr_data_count       (),
+        .rd_data_count       (),
+        .empty               (mm2s_stream_buffer_empty),
+        .full                (mm2s_stream_buffer_full),
+        .almost_empty        (),
+        .almost_full         (),
+        .overflow            (),
+        .underflow           (),
+        .prog_empty          (),
+        .prog_full           (),
+        .sleep               (1'b0),
+        .sbiterr             (),
+        .dbiterr             (),
+        .injectsbiterr       (1'b0),
+        .injectdbiterr       (1'b0),
+        .wr_clk              (aclk),
+        .rst                 (~aresetn),
+        .rd_rst_busy         (),
+        .wr_rst_busy         ()
+    );
+
+
+    //////////////////////////////////////////////////////////////////
+    // Controller state machine S2MM & MM2S
+    //////////////////////////////////////////////////////////////////
+
+    //******************************************
+    //        Memory Mapped Command FSM
+    //******************************************
+
+    typedef enum logic [1:0] {
+        READ,
+        WRITE,
+        READ_RESULT,
+        WRITE_ACK
+    } opcode_t;
+
+    // Command FSM states
+    typedef enum {C_IDLE,C_START,C_VALID,C_READY} state_c;
+    
+    state_c cmd_reg, cmd_next;
+    
+    logic [HASH_WIDTH-1:0] cmd_address;
+
+    always_ff @(posedge aclk or negedge aresetn) begin
+    if (!aresetn) begin // Boot up the FSM.
+        cmd_reg         <= C_IDLE;
+    end else begin
+        cmd_reg         <= cmd_next;
+    end
+    end
+
+    // Memory Mapped Command FSM
+    always_comb begin
+        cmd_next = cmd_reg;
+
+        metadata_tready_buff = 1'b0;
+        
+        command_sent = 1'b0;
+        cmd_address = '0;
+
+        // MM2S
+        mm2s_cmd_tdata = '0;
+        mm2s_cmd_tvalid = 1'b0;
+
+        mm2s_wr_meta_tdata = '0;
+        mm2s_wr_meta_tvalid = 1'b0;
+
+        // S2MM
+        s2mm_cmd_tdata = '0;
+        s2mm_cmd_tvalid = 1'b0;
+
+        s2mm_wr_meta_tdata = '0;
+        s2mm_wr_meta_tvalid = 1'b0;
+
+        // Ack Stream signals
+        s_ack_tdata_buff = '0;
+        s_ack_tkeep_buff = '0;
+        s_ack_tvalid_buff = 1'b0;
+        s_ack_tlast_buff = 1'b0;
+
+        case(cmd_reg)
+
+        //CMD IDLE state
+        C_IDLE: begin 
+            if(abp_complete0)
+                cmd_next = C_START;
+            else
+                cmd_next = C_IDLE;
+        end
+
+        //CMD START state
+        C_START: begin 
+            cmd_next = C_VALID;
+        end
+
+        //CMD VALID state
+        C_VALID: begin
+            if(metadata_tvalid_buff) //**SLAVE-SIDE.
+                cmd_next = C_READY;
+            else
+                cmd_next = C_VALID;
+        end
+
+        //CMD READY state
+        C_READY: begin
+            metadata_tready_buff = 1'b1;
+            cmd_address = hash(metadata_tdata_buff.key, HASH_MATRIX);
+
+            case (metadata_tdata_buff.opcode)
+                8'h00: begin
+                    if(mm2s_cmd_tready) begin  //**MASTER-SIDE.
+                        mm2s_wr_meta_tvalid = 1'b1;
+                        mm2s_wr_meta_tdata = metadata_tdata_buff;
+                        mm2s_cmd_tvalid = 1'b1;
+                        mm2s_cmd_tdata = {8'h00, 6'b0,cmd_address,10'b0 ,1'b0,1'b1,6'b000000,1'b1,BTT};
+                        cmd_next = C_VALID;                    
+                    end
+                end 
+                8'h01: begin
+                    if(s2mm_cmd_tready && s_ack_tready_buff)begin  //**MASTER-SIDE. 
+                        s2mm_wr_meta_tvalid = 1'b1;
+                        s2mm_wr_meta_tdata = metadata_tdata_buff; 
+                        s2mm_cmd_tvalid = 1'b1;    
+                        s2mm_cmd_tdata = {8'h00, 6'b0,cmd_address,10'b0 ,1'b0,1'b1,6'b000000,1'b1,BTT};  
+                        command_sent = 1'b1;
+                        s_ack_tdata_buff = '0;
+                        s_ack_tkeep_buff = '0;
+                        s_ack_tvalid_buff = 1'b1;
+                        s_ack_tlast_buff = 1'b1;
+                        cmd_next = C_VALID;
+                    end
+                end
+                default:;
+            endcase
+
+
+        end
+        default:;
+        endcase
+    end
+
+    //************************************************
+    //             AXI-Stream FSM [Write]
+    //************************************************
+
+    // S2MM FSM states
+    typedef enum {S2MM_IDLE,S2MM_START,S2MM_VALID,S2MM_READY} state_t;
+    
+    state_t s2mm_reg, s2mm_next; 
+
+    always_ff@(posedge aclk, negedge aresetn) begin
+        if(!aresetn) // Boot up the FSM.
+            s2mm_reg <= S2MM_IDLE;
+        else 
+            s2mm_reg <= s2mm_next; 
+    end
+
+    // Axi Stream FSM [Write]
+    always_comb begin
+        
+        s2mm_next = s2mm_reg;
+
+        s_tready_buff = 1'b0;
+
+        m_dm_axis_tvalid = 1'b0;
+        m_dm_axis_tdata = '0;
+        m_dm_axis_tkeep = '0;
+        m_dm_axis_tlast = 1'b0;
+
+        stream_sent = 1'b0;
+        
+        case(s2mm_reg)
+
+        //AXI IDLE state
+        S2MM_IDLE: begin 
+            if(abp_complete0)
+                s2mm_next = S2MM_START;
+            else
+                s2mm_next = S2MM_IDLE;
+        end
+
+        //AXI START state
+        S2MM_START: begin 
+            if(stream_enable) begin
+                s2mm_next = S2MM_VALID;
+            end
+            else
+                s2mm_next = S2MM_START;
+        end
+
+        //AXI VALID state
+        S2MM_VALID: begin
+            if(s_tvalid_buff && stream_enable) //**SLAVE-SIDE.
+                s2mm_next = S2MM_READY;
+            else
+                s2mm_next = S2MM_VALID;
+        end
+
+        //AXI READY state
+        S2MM_READY: begin
+            if(s_tvalid_buff && m_dm_axis_tready) begin //**MASTER-SIDE.
+                s_tready_buff = 1'b1;
+                m_dm_axis_tvalid = 1'b1;
+                m_dm_axis_tdata = s_tlast_buff ? {4'hF, s_tdata_buff[507:0]} : s_tdata_buff;
+                m_dm_axis_tkeep = s_tlast_buff ? {4'hF, s_tkeep_buff[59:0]}   : s_tkeep_buff;
+                m_dm_axis_tlast = s_tlast_buff;
+                if(s_tlast_buff) begin
+                    s2mm_next = S2MM_VALID;
+                    stream_sent = 1'b1;
+                end
+            end
+            else
+                s2mm_next = S2MM_READY;
+        end
+        default:;
+        endcase
+    end
+
+    //************************************************
+    //             AXI-Stream FSM [Read]
+    //************************************************
+/*
+    // mm2s axi
+    logic [DATA_WIDTH-1:0]  mm2s_axis_tdata;
+    logic [TKEEP_WIDTH-1:0] mm2s_axis_tkeep;
+    logic                   mm2s_axis_tlast;
+    logic                   mm2s_axis_tvalid;
+
+
+    // MM2S FSM states
+    typedef enum {MM2S_IDLE,MM2S_START,MM2S_VALID,MM2S_READY} state_f;
+    
+    state_f state_reg, state_next; 
+
+    always_ff@(posedge aclk, negedge aresetn) begin
+        if(!aresetn) // Boot up the FSM.
+            state_reg <= MM2S_IDLE;
+        else 
+            state_reg <= state_next; 
+    end
+
+    // Axi Stream FSM
+    always_comb begin
+
+        state_next = state_reg;
+
+        m_tready_buff = 1'b0;
+
+        mm2s_axis_tvalid = 1'b0;
+        mm2s_axis_tdata = '0;
+        mm2s_axis_tkeep = '0;
+        mm2s_axis_tlast = '0;
+
+        case(state_reg)
+
+        //AXI IDLE state
+        MM2S_IDLE: begin 
+            if(abp_complete0)
+                state_next = MM2S_START;
+            else
+                state_next = MM2S_IDLE;
+        end
+
+        //AXI START state
+        MM2S_START: begin
+            state_next = MM2S_VALID;
+        end
+
+        //AXI VALID state
+        MM2S_VALID: begin
+            if(m_tvalid_buff) //**SLAVE-SIDE.
+                state_next = MM2S_READY;
+            else
+                state_next = MM2S_VALID;
+        end
+
+        //AXI READY state
+        MM2S_READY: begin 
+            if(m_tvalid_buff && m_axis_tready) begin
+                m_tready_buff = 1'b1;
+
+                mm2s_axis_tvalid = 1'b1;
+                mm2s_axis_tdata = m_tdata_buff;
+                mm2s_axis_tkeep = m_tkeep_buff;
+                mm2s_axis_tlast = m_tlast_buff;
+
+                if(m_tlast_buff) begin
+                    state_next = MM2S_VALID;
+                end
+            end    
+            else
+                state_next = MM2S_READY;
+        end
+
+        endcase
+    end
+*/
+
+
+    //************************************************
+    //         Write-ack/Read Arbitrer FSM
+    //************************************************
+ 
+    // Arbitrer FSM states
+    typedef enum logic [1:0] {RET_IDLE, RET_TYPE, RET_ACK, RET_READ} sel_t;
+    sel_t sel, sel_n;
+
+    logic sent_first_read;
+
+    always_comb begin
+        sel_n = sel;
+
+        // m_axi
+        m_axis_tvalid = 1'b0;
+        m_axis_tdata  = '0;
+        m_axis_tkeep  = '0;
+        m_axis_tlast  = 1'b0;
+
+        //MM2S Buffer tready
+        m_tready_buff = 1'b0;
+        //Write Ack Buffer tready
+        m_ack_tready_buff = 1'b0;
+        //Bvalid Buffer tready
+        m_bready_buff = 1'b0;
+
+        metadata_mem_out = '0;
+        metadata_mem_out_valid = 1'b0;
+
+        //S2MM metadata buffer
+        s2mm_rd_meta_tready = 0;
+        //MM2S metadata buffer
+        mm2s_rd_meta_tready= 0;
+
+        case (sel)
+    
+        //Arbitrer IDLE state
+        RET_IDLE: begin 
+            if(abp_complete0)
+                sel_n = RET_TYPE;
+            else
+                sel_n= RET_IDLE;
+        end
+        
+
+        //Arbitrer TYPE state
+        RET_TYPE: begin
+        if (m_ack_tvalid_buff && s2mm_rd_meta_tvalid && m_bvalid_buff) 
+            sel_n = RET_ACK;
+        else if (m_tvalid_buff && mm2s_rd_meta_tvalid) 
+            sel_n = RET_READ;
+        else
+            sel_n = RET_TYPE;
+        end
+
+        // RET_ACK: begin
+        //     if (s2mm_rd_meta_tvalid && m_bvalid_buff) begin
+        //         m_axis_tvalid = 1'b1;
+        //         m_axis_tdata = '0;
+        //         m_axis_tkeep = '0;
+        //         m_axis_tlast = 1'b1;
+
+        //         metadata_mem_out_valid = 1'b1;
+        //         metadata_mem_out = s2mm_rd_meta_tdata;
+
+        //         if (m_axis_tready) begin
+        //             m_bready_buff = 1'b1;
+        //             s2mm_rd_meta_tready = 1'b1;
+        //             sel_n = RET_TYPE;
+        //         end
+        //     end
+        // end
+
+        //Arbitrer ACK state
+        RET_ACK: begin
+            if (m_ack_tvalid_buff && m_axis_tready && s2mm_rd_meta_tvalid && m_bvalid_buff) begin
+                m_bready_buff = 1'b1;
+                m_axis_tvalid = 1'b1;
+                m_ack_tready_buff = 1'b1;
+                m_axis_tdata = m_ack_tdata_buff;
+                m_axis_tkeep = m_ack_tkeep_buff;
+                m_axis_tlast = m_ack_tlast_buff;
+
+                s2mm_rd_meta_tready = 1'b1;
+                metadata_mem_out_valid = 1'b1;
+                metadata_mem_out = s2mm_rd_meta_tdata;
+
+                sel_n = RET_TYPE;
+            end
+        end
+
+        //Arbitrer READ state
+        RET_READ: begin
+            if (m_tvalid_buff && m_axis_tready) begin            
+                m_axis_tvalid = 1'b1;
+                m_tready_buff = 1'b1;
+                m_axis_tdata  = m_tlast_buff ? {4'h0, m_tdata_buff[507:0]} : m_tdata_buff;
+                m_axis_tkeep  = m_tlast_buff ? {4'h0, m_tkeep_buff[59:0]}  : m_tkeep_buff;
+                m_axis_tlast  = m_tlast_buff;
+
+
+            
+                if (!sent_first_read) begin
+                    mm2s_rd_meta_tready = 1'b1;
+                    metadata_mem_out_valid = 1'b1;
+                    metadata_mem_out = mm2s_rd_meta_tdata;
+                end
+
+                if(m_tlast_buff) begin
+                    sel_n = RET_TYPE;
+                end
+
+            end
+            else begin
+                sel_n = RET_READ;
+            end
+        end
+        default:;
+        endcase
+    end
+
+    always_ff @(posedge aclk or negedge aresetn) begin
+        if (!aresetn) begin
+        sel             <= RET_IDLE;
+        sent_first_read <= 0;
+        end 
+        else begin
+        sel <= sel_n;
+
+            if (sel == RET_READ) begin
+                if (!sent_first_read && m_tvalid_buff && m_axis_tready)
+                    sent_first_read <= 1;
+                if (m_tvalid_buff && m_axis_tready && m_tlast_buff)
+                    sent_first_read <= 0;
+                end 
+            else begin
+                sent_first_read <= 0;
+            end
+        end
+    end
+
+    
+
+    //******************************************
+    //         AXI-Stream Status Hardware 
+    //******************************************
+    /*Clearing the status signals (needed for datamover stable functionality)*/
+
+    // MM2S
+    always_ff@(posedge aclk, negedge aresetn) begin
+        if(!aresetn || !abp_complete0) // Boot up the STS Hardware.
+            s_axis_mm2s_sts_tready <= 1'b0;
+        else if (s_axis_mm2s_sts_tvalid)
+            s_axis_mm2s_sts_tready <= 1'b1; 
+        else
+            s_axis_mm2s_sts_tready <= 1'b0;
+    end
+
+
+    // S2MM
+    always_ff@(posedge aclk, negedge aresetn) begin
+        if(!aresetn || !abp_complete0) // Boot up the STS Hardware.
+            s_axis_s2mm_sts_tready <= 1'b0;
+        else if (s_axis_s2mm_sts_tvalid)
+            s_axis_s2mm_sts_tready <= 1'b1; 
+        else
+            s_axis_s2mm_sts_tready <= 1'b0;
+    end
+
+endmodule
\ No newline at end of file
diff --git a/src/hbm_subsystem/memory_controller/metadata_buffer.sv b/src/hbm_subsystem/memory_controller/metadata_buffer.sv
new file mode 100644
index 0000000..ca0873a
--- /dev/null
+++ b/src/hbm_subsystem/memory_controller/metadata_buffer.sv
@@ -0,0 +1,72 @@
+// typedef struct packed {
+//   logic          [31:0] ip;      // IPv4 address of the sender
+//   logic          [47:0] mac;     // Mac address of the sender
+//   logic           [7:0] id;      // Operation identifier used to distinguish consecutive writes
+//   logic           [7:0] opcode;  // Operation code
+//   logic          [63:0] key;
+// } st_metadata;
+
+module metadata_buffer #(
+  parameter DEPTH      = 64,
+  parameter PTR_WIDTH  = $clog2(DEPTH)
+)(
+  input  logic         aclk,
+  input  logic         aresetn,
+
+  // Slave side (no ready)
+  input  logic         s_valid,
+  input  st_metadata   s_data,
+
+  // Master side (with ready)
+  output logic         m_valid,
+  output st_metadata   m_data,
+  input  logic         m_ready
+);
+
+  // Memory Buffers
+  st_metadata mem [DEPTH-1:0];
+
+  // Write & Read pointers
+  logic [PTR_WIDTH-1:0] write_ptr;
+  logic [PTR_WIDTH-1:0] read_ptr;
+
+  // Counter
+  logic [PTR_WIDTH-1:0] count;
+
+always_ff @(posedge aclk or negedge aresetn) begin
+  if (!aresetn) begin
+    write_ptr <= '0;
+    read_ptr  <= '0;
+    count     <= '0;
+  end 
+  else begin
+    // Write
+    if (s_valid) begin
+      mem[write_ptr] <= s_data;
+      write_ptr      <= write_ptr + 1;
+      if (count < (DEPTH-1))
+        count <= count + 1;
+    end
+
+    // Read
+    if (m_valid && m_ready) begin
+      read_ptr <= read_ptr + 1;
+      count    <= count - 1;
+    end
+  end
+end
+
+  st_metadata m_rand;
+  always_comb begin
+  m_rand.ip = '0;
+  m_rand.id ='0;
+  m_rand.opcode ='0;
+  m_rand.key  = '0;
+  m_rand.mac = '0;
+  end
+
+  assign m_valid = (count != 0);
+  assign m_data  = m_ready? mem[read_ptr] :m_rand;
+  
+
+endmodule
\ No newline at end of file
diff --git a/src/hbm_subsystem/memory_controller/synchronizer.sv b/src/hbm_subsystem/memory_controller/synchronizer.sv
new file mode 100644
index 0000000..291d34f
--- /dev/null
+++ b/src/hbm_subsystem/memory_controller/synchronizer.sv
@@ -0,0 +1,98 @@
+`timescale 1ns / 1ps
+//////////////////////////////////////////////////////////////////////////////////
+// Company: 
+// Engineer: 
+// 
+// Create Date: 05/17/2025 08:44:13 PM
+// Design Name: 
+// Module Name: Controller_Arbitrer
+// Project Name: 
+// Target Devices: 
+// Tool Versions: 
+// Description: 
+// 
+// Dependencies: 
+// 
+// Revision:
+// Revision 0.01 - File Created
+// Additional Comments:
+// 
+//////////////////////////////////////////////////////////////////////////////////
+module synchronizer #(
+    parameter N = 8
+)(
+    input logic  aclk,
+    input logic  aresetn,
+
+    input logic  s2mm_cmd_start,
+
+    input logic  command_sent,
+    input logic  stream_sent,
+
+    output logic stream_enable
+);
+
+    // Arbitrer FSM states
+    typedef enum {A_IDLE,A_WAIT_COMMAND,A_INCR_COMMAND,A_DECR_COMMAND} state_a;
+
+    logic [N-1:0] cmd_count_reg;
+    logic [N-1:0] cmd_count_next;
+
+    state_a state_reg, state_next; 
+
+    always_ff @(posedge aclk, negedge aresetn) begin
+        if(!aresetn) begin // Boot up the FSM.
+            state_reg <= A_IDLE;
+            cmd_count_reg <= '0;
+        end
+        else begin
+            state_reg <= state_next;
+            cmd_count_reg <= cmd_count_next; 
+        end
+    end
+
+    // Arbitrer FSM
+    always_comb begin
+        state_next = state_reg;
+        cmd_count_next = cmd_count_reg;
+
+        case(state_reg)
+
+        //Arbitrer IDLE state
+        A_IDLE: begin 
+            if(s2mm_cmd_start)
+                state_next = A_WAIT_COMMAND;
+            else
+                state_next = A_IDLE;
+        end
+        
+        //CMD START state
+        A_WAIT_COMMAND: begin
+            if(command_sent && stream_sent)
+                state_next = A_WAIT_COMMAND; // no change
+            else if (command_sent)
+                state_next = A_INCR_COMMAND;
+            else if (stream_sent)
+                state_next = A_DECR_COMMAND;
+            else
+                state_next = A_WAIT_COMMAND;
+        end
+
+        A_INCR_COMMAND: begin
+            cmd_count_next = cmd_count_reg +1;
+            state_next = A_WAIT_COMMAND;
+        end 
+
+        A_DECR_COMMAND: begin
+        if(cmd_count_reg > 0)
+                cmd_count_next = cmd_count_reg -1;
+            state_next = A_WAIT_COMMAND;
+        end
+
+        endcase
+
+    end
+
+    assign stream_enable = (cmd_count_reg !=0);
+
+endmodule
\ No newline at end of file
diff --git a/src/hbm_subsystem/metadata.sv b/src/hbm_subsystem/metadata.sv
new file mode 100644
index 0000000..de2bfb7
--- /dev/null
+++ b/src/hbm_subsystem/metadata.sv
@@ -0,0 +1,31 @@
+package metadata_pkg;
+
+parameter int KEY_WIDTH = 64;
+parameter logic [31:0] DIRTY_TAG = {<< 8 {32'hF0CACC1A}};
+
+typedef enum logic [7:0] {
+  READ              = 8'h00,
+  WRITE             = 8'h01,
+  READ_RESULT       = 8'h02,
+  READ_NOT_FOUND    = 8'h03,
+  WRITE_ACK         = 8'h04,
+  WRITE_ACK_LEADER  = 8'h05,
+  HEARTBEAT         = 8'h06,
+  HEARTBEAT_ACK     = 8'h07,
+  VOTE_REQUEST      = 8'h08,
+  VOTE              = 8'h09,
+  SWAP_READ         = 8'h0A,
+  SWAP_WRITE        = 8'h0B
+} opcode_e;
+
+typedef struct packed {
+  logic          [31:0] ip;     
+  logic          [47:0] mac;    
+  opcode_e              opcode; 
+  logic           [7:0] index;     
+  logic [KEY_WIDTH-1:0] key;
+} st_metadata;
+
+parameter int METADATA_WIDTH = $bits(st_metadata);
+
+endpackage
\ No newline at end of file
diff --git a/src/hbm_subsystem/nodes_table.sv b/src/hbm_subsystem/nodes_table.sv
new file mode 100644
index 0000000..a4d79eb
--- /dev/null
+++ b/src/hbm_subsystem/nodes_table.sv
@@ -0,0 +1,84 @@
+import metadata_pkg::*;
+
+module nodes_table #(
+  parameter int TABLE_SIZE = 32,
+  parameter int PTR_WIDTH  = $clog2(TABLE_SIZE)
+) (
+  input  logic                 aclk,
+  input  logic                 rstn,
+ 
+  input  logic                 metadata_valid,
+  input  st_metadata           metadata,
+
+  input  logic [PTR_WIDTH-1:0] index,
+  output logic [PTR_WIDTH-1:0] num_nodes,
+  output logic          [31:0] ip,
+  output logic          [47:0] mac
+);
+
+// TODO: Decrease num_nodes if a node has not sent heartbeat in a while
+
+localparam int TABLE_WIDTH = 32 + 48;
+localparam int HASH_SEED   = 32'h9E3779B1;
+
+function automatic logic [PTR_WIDTH-1:0] hash(input logic [31:0] ip);
+  logic [31:0] mult;
+  mult = ip * HASH_SEED;
+  return mult[31-:PTR_WIDTH];
+endfunction
+
+// FIXME: Collisions are never taken care of
+logic [TABLE_SIZE-1:0] is_in_network;
+logic  [PTR_WIDTH-1:0] hashed_ip;
+
+(* ram_style = "block" *)
+logic [TABLE_WIDTH-1:0] ip_table [TABLE_SIZE];
+logic   [PTR_WIDTH-1:0] read_ptr,  write_ptr;
+logic [TABLE_WIDTH-1:0] read_data, write_data;
+logic                   write_en;
+
+assign hashed_ip = hash(metadata.ip);
+assign read_ptr  = index;
+assign ip        = read_data[TABLE_WIDTH-1-:32];
+assign mac       = read_data[TABLE_WIDTH-1-32-:48];
+
+// initial begin
+//   for (int i = 0; i < TABLE_SIZE; i++) begin
+//     ip_table[i] = '0;
+//   end
+// end
+
+// IP table logic
+always_ff @(posedge aclk) begin
+  if (!rstn) begin
+    read_data <= 0;
+  end
+  else begin
+    read_data <= ip_table[read_ptr];
+    if (write_en) begin
+      ip_table[write_ptr] <= write_data;
+    end
+  end
+end
+
+always_ff @(posedge aclk) begin
+  if (!rstn) begin
+    is_in_network <= '0;
+    num_nodes     <= 1;
+    write_en      <= 1'b0;
+    write_ptr     <= '0;
+    write_data    <= '0;
+  end
+  else begin
+    write_en <= 1'b0;
+    if (metadata_valid && !is_in_network[hashed_ip]) begin
+      is_in_network[hashed_ip] <= 1'b1;
+      num_nodes  <= num_nodes + 1;
+      write_en   <= 1'b1;
+      write_ptr  <= num_nodes - 1;
+      write_data <= {metadata.ip, metadata.mac};
+    end
+  end
+end
+
+endmodule
\ No newline at end of file
diff --git a/src/hbm_subsystem/packet_deparser.p4 b/src/hbm_subsystem/packet_deparser.p4
new file mode 100644
index 0000000..ba7b1f6
--- /dev/null
+++ b/src/hbm_subsystem/packet_deparser.p4
@@ -0,0 +1,259 @@
+#include <core.p4>
+#include <xsa.p4>
+
+typedef bit<48>  MacAddr;
+typedef bit<32>  IPv4Addr;
+
+const bit<16> QINQ_TYPE = 0x88A8;
+const bit<16> VLAN_TYPE = 0x8100;
+const bit<16> IPV4_TYPE = 0x0800;
+
+const bit<8>  TCP_PROT  = 0x06;
+const bit<8>  UDP_PROT  = 0x11;
+
+const bit<16> REPLICATION_PORT = 0x7777;
+
+const bit<16> IP_HEADER_SIZE   = 20;
+const bit<16> UDP_HEADER_SIZE  = 8; 
+const bit<16> REP_HEADER_SIZE  = 2;
+const bit<16> KEY_SIZE         = 8;
+const bit<16> PAYLOAD_SIZE     = 1024 - 4 - 8;
+const bit<16> MINIMUM_SIZE     = 60 - IP_HEADER_SIZE - UDP_HEADER_SIZE - REP_HEADER_SIZE;
+
+// Replication opcodes
+const bit<8> READ              = 0x00;
+const bit<8> WRITE             = 0x01;
+const bit<8> READ_RESULT       = 0x02;
+const bit<8> READ_NOT_FOUND    = 0x03;
+const bit<8> WRITE_ACK         = 0x04;
+const bit<8> WRITE_ACK_LEADER  = 0x05;
+
+const bit<8> HEARTBEAT         = 0x06;
+const bit<8> HEARTBEAT_ACK     = 0x07;
+const bit<8> VOTE_REQUEST      = 0x08;
+const bit<8> VOTE              = 0x09;
+
+const bit<32> DIRTY_TAG        = 0xF0CACC1A;
+
+// ********************************************************************** //
+// *************************** H E A D E R S  *************************** //
+// ********************************************************************** //
+
+header eth_mac_t {
+  MacAddr dmac; // Destination MAC address
+  MacAddr smac; // Source MAC address
+  bit<16> type; // Tag Protocol Identifier
+}
+
+header vlan_t {
+  bit<3>  pcp;  // Priority code point
+  bit<1>  cfi;  // Drop eligible indicator
+  bit<12> vid;  // VLAN identifier
+  bit<16> tpid; // Tag protocol identifier
+}
+
+header ipv4_t {
+  bit<4>   version;  // Version (4 for IPv4)
+  bit<4>   hdr_len;  // Header length in 32b words
+  bit<8>   tos;      // Type of Service
+  bit<16>  length;   // Packet length in 32b words
+  bit<16>  id;       // Identification
+  bit<3>   flags;    // Flags
+  bit<13>  offset;   // Fragment offset
+  bit<8>   ttl;      // Time to live
+  bit<8>   protocol; // Next protocol
+  bit<16>  hdr_chk;  // Header checksum
+  IPv4Addr src;      // Source address
+  IPv4Addr dst;      // Destination address
+}
+
+header ipv4_opt_t {
+  varbit<320> options; // IPv4 options - length = (ipv4.hdr_len - 5) * 32
+}
+
+header tcp_t {
+  bit<16> src_port;   // Source port
+  bit<16> dst_port;   // Destination port
+  bit<32> seqNum;     // Sequence number
+  bit<32> ackNum;     // Acknowledgment number
+  bit<4>  dataOffset; // Data offset
+  bit<6>  resv;       // Offset
+  bit<6>  flags;      // Flags
+  bit<16> window;     // Window
+  bit<16> checksum;   // TCP checksum
+  bit<16> urgPtr;     // Urgent pointer
+}
+
+header tcp_opt_t {
+  varbit<320> options; // TCP options - length = (tcp.dataOffset - 5) * 32
+}
+
+header udp_t {
+  bit<16> src_port;  // Source port
+  bit<16> dst_port;  // Destination port
+  bit<16> length;    // UDP length
+  bit<16> checksum;  // UDP checksum
+}
+
+// Replication header
+header rep_h {
+  bit<8>  opcode;
+  bit<8>  id;
+}
+
+header tag_h {
+  bit<32> tag;
+}
+
+header key_h {
+  bit<64> key;
+}
+
+// ********************************************************************** //
+// ************************* S T R U C T U R E S  *********************** //
+// ********************************************************************** //
+
+// Header structure
+struct headers {
+  eth_mac_t  eth;
+  vlan_t     new_vlan;
+  vlan_t     vlan;
+  ipv4_t     ipv4;
+  ipv4_opt_t ipv4opt;
+  tcp_t      tcp;
+  tcp_opt_t  tcpopt;
+  udp_t      udp;
+  rep_h      rep;
+  tag_h      tag;
+  key_h      key;
+}
+
+struct metadata_t {
+  bit<32> ip_src;
+  bit<48> mac_src;
+  bit<8>  opcode;
+  bit<8>  index;
+  bit<64> key;
+
+  // Fixed values
+  bit<32> ip_own;
+  bit<48> mac_own;
+}
+
+// User-defined errors
+error {
+  InvalidIPpacket,
+  InvalidTCPpacket
+}
+
+// ********************************************************************** //
+// *************************** P A R S E R  ***************************** //
+// ********************************************************************** //
+
+parser MyParser(packet_in packet,
+                out headers hdr,
+                inout metadata_t meta,
+                inout standard_metadata_t smeta) {
+
+  state start {
+    transition parse_tag;
+  }
+
+  state parse_tag {
+    packet.extract(hdr.tag);
+    transition select(hdr.tag.tag) {
+      DIRTY_TAG : parse_key;
+      default   : accept;
+    }
+  }
+
+  state parse_key {
+    packet.extract(hdr.key);
+    transition accept;
+  }
+}
+
+// ********************************************************************** //
+// **************************  P R O C E S S I N G   ******************** //
+// ********************************************************************** //
+
+control MyProcessing(inout headers hdr,
+                     inout metadata_t meta,
+                     inout standard_metadata_t smeta) {
+  // InternetChecksum() ck;
+  // bit<16> csum;
+
+  bit<16> payload_length;
+
+  apply {
+    hdr.eth.setValid();
+    hdr.ipv4.setValid();
+    hdr.udp.setValid();
+    hdr.rep.setValid();
+    hdr.key.setValid();
+
+    payload_length = MINIMUM_SIZE;
+    if (meta.opcode == WRITE || meta.opcode == READ_RESULT) {
+      payload_length = PAYLOAD_SIZE;
+    }
+
+    hdr.eth.dmac     = meta.mac_src;
+    hdr.eth.smac     = meta.mac_own;
+    hdr.eth.type     = IPV4_TYPE;
+
+    hdr.ipv4.version = 4;
+    hdr.ipv4.hdr_len = 5;
+    hdr.ipv4.tos     = 0;
+    hdr.ipv4.length  = IP_HEADER_SIZE + UDP_HEADER_SIZE + REP_HEADER_SIZE + payload_length;
+    hdr.ipv4.id      = 0;
+    hdr.ipv4.flags   = 0;
+    hdr.ipv4.offset  = 0;
+    hdr.ipv4.ttl     = 64;
+    hdr.ipv4.protocol= UDP_PROT;
+    hdr.ipv4.hdr_chk = 0;
+    hdr.ipv4.src     = meta.ip_own;
+    hdr.ipv4.dst     = meta.ip_src;
+
+    hdr.udp.src_port = REPLICATION_PORT;
+    hdr.udp.dst_port = REPLICATION_PORT;
+    hdr.udp.length   = UDP_HEADER_SIZE + REP_HEADER_SIZE + payload_length;
+    hdr.udp.checksum = 0;
+
+    hdr.rep.opcode   = meta.opcode;
+    hdr.rep.id       = meta.index;
+    hdr.key.key      = meta.key;
+
+    // ck.clear();
+    // ck.add({hdr.ipv4.version, hdr.ipv4.hdr_len, hdr.ipv4.tos, hdr.ipv4.length, hdr.ipv4.id, hdr.ipv4.flags, hdr.ipv4.offset, hdr.ipv4.ttl, hdr.ipv4.protocol, hdr.ipv4.src, hdr.ipv4.dst});
+    // ck.get(csum);
+    // hdr.ipv4.hdr_chk = csum;
+  }
+}
+
+
+// ********************************************************************** //
+// ***************************  D E P A R S E R  ************************ //
+// ********************************************************************** //
+
+control MyDeparser(packet_out packet,
+                   in headers hdr,
+                   inout metadata_t meta,
+                   inout standard_metadata_t smeta) {
+  apply {
+    packet.emit(hdr.eth);
+    packet.emit(hdr.ipv4);
+    packet.emit(hdr.udp);
+    packet.emit(hdr.rep);
+    packet.emit(hdr.key);
+  }
+}
+
+// ********************************************************************** //
+// *******************************  M A I N  **************************** //
+// ********************************************************************** //
+
+XilinxPipeline(
+  MyParser(),
+  MyProcessing(),
+  MyDeparser()
+) main;
diff --git a/src/hbm_subsystem/packet_parser.p4 b/src/hbm_subsystem/packet_parser.p4
new file mode 100644
index 0000000..0c9b444
--- /dev/null
+++ b/src/hbm_subsystem/packet_parser.p4
@@ -0,0 +1,301 @@
+#include <core.p4>
+#include <xsa.p4>
+
+typedef bit<48>  MacAddr;
+typedef bit<32>  IPv4Addr;
+
+const bit<16> QINQ_TYPE = 0x88A8;
+const bit<16> VLAN_TYPE = 0x8100;
+const bit<16> IPV4_TYPE = 0x0800;
+
+const bit<8>  TCP_PROT  = 0x06;
+const bit<8>  UDP_PROT  = 0x11;
+
+const bit<16> REPLICATION_PORT = 0x7777;
+
+// Replication opcodes
+const bit<8> READ              = 0x00;
+const bit<8> WRITE             = 0x01;
+const bit<8> READ_RESULT       = 0x02;
+const bit<8> READ_NOT_FOUND    = 0x03;
+const bit<8> WRITE_ACK         = 0x04;
+const bit<8> WRITE_ACK_LEADER  = 0x05;
+
+const bit<8> HEARTBEAT         = 0x06;
+const bit<8> HEARTBEAT_ACK     = 0x07;
+const bit<8> VOTE_REQUEST      = 0x08;
+const bit<8> VOTE              = 0x09;
+
+const bit<32> DIRTY_TAG        = 0xF0CACC1A;
+
+// ********************************************************************** //
+// *************************** H E A D E R S  *************************** //
+// ********************************************************************** //
+
+header eth_mac_t {
+  MacAddr dmac; // Destination MAC address
+  MacAddr smac; // Source MAC address
+  bit<16> type; // Tag Protocol Identifier
+}
+
+header vlan_t {
+  bit<3>  pcp;  // Priority code point
+  bit<1>  cfi;  // Drop eligible indicator
+  bit<12> vid;  // VLAN identifier
+  bit<16> tpid; // Tag protocol identifier
+}
+
+header ipv4_t {
+  bit<4>   version;  // Version (4 for IPv4)
+  bit<4>   hdr_len;  // Header length in 32b words
+  bit<8>   tos;      // Type of Service
+  bit<16>  length;   // Packet length in 32b words
+  bit<16>  id;       // Identification
+  bit<3>   flags;    // Flags
+  bit<13>  offset;   // Fragment offset
+  bit<8>   ttl;      // Time to live
+  bit<8>   protocol; // Next protocol
+  bit<16>  hdr_chk;  // Header checksum
+  IPv4Addr src;      // Source address
+  IPv4Addr dst;      // Destination address
+}
+
+header ipv4_opt_t {
+  varbit<320> options; // IPv4 options - length = (ipv4.hdr_len - 5) * 32
+}
+
+header tcp_t {
+  bit<16> src_port;   // Source port
+  bit<16> dst_port;   // Destination port
+  bit<32> seqNum;     // Sequence number
+  bit<32> ackNum;     // Acknowledgment number
+  bit<4>  dataOffset; // Data offset
+  bit<6>  resv;       // Offset
+  bit<6>  flags;      // Flags
+  bit<16> window;     // Window
+  bit<16> checksum;   // TCP checksum
+  bit<16> urgPtr;     // Urgent pointer
+}
+
+header tcp_opt_t {
+  varbit<320> options; // TCP options - length = (tcp.dataOffset - 5) * 32
+}
+
+header udp_t {
+  bit<16> src_port;  // Source port
+  bit<16> dst_port;  // Destination port
+  bit<16> length;    // UDP length
+  bit<16> checksum;  // UDP checksum
+}
+
+// Replication header
+header rep_h {
+  bit<8>  opcode;
+  bit<8>  id;
+}
+
+header tag_h {
+  bit<32> tag;
+}
+
+header key_h {
+  bit<64> key;
+}
+
+// ********************************************************************** //
+// ************************* S T R U C T U R E S  *********************** //
+// ********************************************************************** //
+
+// header structure
+struct headers {
+  eth_mac_t  eth;
+  vlan_t     new_vlan;
+  vlan_t     vlan;
+  ipv4_t     ipv4;
+  ipv4_opt_t ipv4opt;
+  tcp_t      tcp;
+  tcp_opt_t  tcpopt;
+  udp_t      udp;
+  rep_h      rep;
+  tag_h      tag;
+  key_h      key;
+}
+
+struct tuser_format {
+   bit<16> size;
+   bit<16> src;
+   bit<16> dst;
+}
+
+
+struct metadata_t {
+  tuser_format axis_tuser;
+  bit<32>      ip_src;
+  bit<48>      mac_src;
+  bit<8>       opcode;
+  bit<8>       index;
+  bit<64>      key;
+  bit<1>       is_rep;
+}
+
+// User-defined errors
+error {
+  InvalidIPpacket,
+  InvalidTCPpacket
+}
+
+// ********************************************************************** //
+// *************************** P A R S E R  ***************************** //
+// ********************************************************************** //
+
+parser MyParser(packet_in packet,
+                out headers hdr,
+                inout metadata_t meta,
+                inout standard_metadata_t smeta) {
+
+  state start {
+    transition parse_eth;
+  }
+
+  state parse_eth {
+    packet.extract(hdr.eth);
+    transition select(hdr.eth.type) {
+      VLAN_TYPE : parse_vlan;
+      IPV4_TYPE : parse_ipv4;
+      default   : accept;
+    }
+  }
+
+  state parse_vlan {
+    packet.extract(hdr.vlan);
+    transition select(hdr.vlan.tpid) {
+      IPV4_TYPE : parse_ipv4;
+      default   : accept;
+    }
+  }
+
+  state parse_ipv4 {
+    packet.extract(hdr.ipv4);
+    verify(hdr.ipv4.version == 4 && hdr.ipv4.hdr_len >= 5, error.InvalidIPpacket);
+    packet.extract(hdr.ipv4opt, (((bit<32>)hdr.ipv4.hdr_len - 5) * 32));
+    transition select(hdr.ipv4.protocol) {
+      TCP_PROT  : parse_tcp;
+      UDP_PROT  : parse_udp;
+      default   : accept;
+    }
+  }
+
+  state parse_tcp {
+    packet.extract(hdr.tcp);
+    verify(hdr.tcp.dataOffset >= 5, error.InvalidTCPpacket);
+    packet.extract(hdr.tcpopt,(((bit<32>)hdr.tcp.dataOffset - 5) * 32));
+    transition accept;
+  }
+
+  state parse_udp {
+    packet.extract(hdr.udp);
+    transition select(hdr.udp.dst_port) {
+      REPLICATION_PORT : parse_rep;
+      default          : accept;
+    }
+  }
+
+  state parse_rep {
+    packet.extract(hdr.rep);
+    transition select(hdr.rep.opcode) {
+      READ_RESULT      : accept;
+      READ_NOT_FOUND   : accept;
+      WRITE_ACK_LEADER : accept;
+      default          : parse_key;
+    }
+  }
+
+  state parse_key {
+    packet.extract(hdr.key);
+    transition accept;
+  }
+}
+
+// ********************************************************************** //
+// **************************  P R O C E S S I N G   ******************** //
+// ********************************************************************** //
+
+control MyProcessing(inout headers hdr,
+                     inout metadata_t meta,
+                     inout standard_metadata_t smeta) {
+
+  bit<32> ip_src;
+  bit<48> mac_src;
+  bit<8>  opcode;
+  bit<8>  index;
+  bit<64> key;
+  bit<1>  is_rep;
+
+  apply {
+    ip_src  = (bit<32>) 0;
+    mac_src = (bit<48>) 0;
+    opcode  = (bit<8>) 0;
+    index   = (bit<8>) 0;
+    key     = (bit<64>) 0;
+    is_rep  = (bit<1>) 0;
+
+    if (hdr.key.isValid()) {
+      ip_src     = hdr.ipv4.src;
+      mac_src    = hdr.eth.smac;
+      opcode     = hdr.rep.opcode;
+      index      = hdr.rep.id;
+      key        = hdr.key.key;
+      is_rep     = 1;
+      smeta.drop = 1;
+
+      if (hdr.rep.opcode == WRITE) {
+        hdr.eth.setInvalid();
+        hdr.ipv4.setInvalid();
+        hdr.udp.setInvalid();
+        hdr.rep.setInvalid();
+        hdr.tag.setValid();
+        smeta.drop = 0;
+      }
+    }
+
+    meta.mac_src  = mac_src;
+    meta.ip_src   = ip_src;
+    meta.opcode   = opcode;
+    meta.index    = index;
+    meta.key      = key;
+    meta.is_rep   = is_rep;
+  }
+}
+
+// ********************************************************************** //
+// ***************************  D E P A R S E R  ************************ //
+// ********************************************************************** //
+
+control MyDeparser(packet_out packet,
+                   in headers hdr,
+                   inout metadata_t meta,
+                   inout standard_metadata_t smeta) {
+  apply {
+    packet.emit(hdr.eth);
+    packet.emit(hdr.new_vlan);
+    packet.emit(hdr.vlan);
+    packet.emit(hdr.ipv4);
+    packet.emit(hdr.ipv4opt);
+    packet.emit(hdr.tcp);
+    packet.emit(hdr.tcpopt);
+    packet.emit(hdr.udp);
+    packet.emit(hdr.rep);
+    packet.emit(hdr.tag);
+    packet.emit(hdr.key);
+  }
+}
+
+// ********************************************************************** //
+// *******************************  M A I N  **************************** //
+// ********************************************************************** //
+
+XilinxPipeline(
+  MyParser(),
+  MyProcessing(),
+  MyDeparser()
+) main;
diff --git a/src/hbm_subsystem/replication_engine.sv b/src/hbm_subsystem/replication_engine.sv
new file mode 100644
index 0000000..447e299
--- /dev/null
+++ b/src/hbm_subsystem/replication_engine.sv
@@ -0,0 +1,664 @@
+`timescale 1ns/1ps
+
+import metadata_pkg::*;
+
+module replication_engine #(
+  parameter int          MAX_NODES  = 32,
+  parameter int          DATA_WIDTH = 512,
+  parameter int          KEEP_WIDTH = DATA_WIDTH / 8,
+  parameter int          FIFO_DEPTH = 16,
+  parameter logic [31:0] NODE_IP    = 0,
+  parameter logic [47:0] NODE_MAC   = 0
+) (
+  input  logic axis_clk,
+  input  logic axis_rstn,
+
+  // Replication packet input
+  input  logic                  s_axis_tvalid,
+  input  logic [DATA_WIDTH-1:0] s_axis_tdata,
+  input  logic [KEEP_WIDTH-1:0] s_axis_tkeep,
+  input  logic                  s_axis_tlast,
+  output logic                  s_axis_tready,
+
+  input  st_metadata            metadata_in,
+  input  logic                  metadata_in_valid,
+
+  // Replication packet output
+  output logic                  m_axis_tvalid,
+  output logic [DATA_WIDTH-1:0] m_axis_tdata,
+  output logic [KEEP_WIDTH-1:0] m_axis_tkeep,
+  output logic                  m_axis_tlast,
+  input  logic                  m_axis_tready,
+
+  output st_metadata            metadata_out,
+  output logic                  metadata_out_valid,
+
+  // Memory controller read
+  input  logic                  s_axis_mem_tvalid,
+  input  logic [DATA_WIDTH-1:0] s_axis_mem_tdata,
+  input  logic [KEEP_WIDTH-1:0] s_axis_mem_tkeep,
+  input  logic                  s_axis_mem_tlast,
+  output logic                  s_axis_mem_tready,
+
+  input  st_metadata            metadata_mem_in,
+  input  logic                  metadata_mem_in_valid,
+
+  // Memory controller write
+  output logic                  m_axis_mem_tvalid,
+  output logic [DATA_WIDTH-1:0] m_axis_mem_tdata,
+  output logic [KEEP_WIDTH-1:0] m_axis_mem_tkeep,
+  output logic                  m_axis_mem_tlast,
+  input  logic                  m_axis_mem_tready,
+
+  output st_metadata            metadata_mem_out,
+  output logic                  metadata_mem_out_valid,
+
+  input  logic                  is_leader
+);
+
+localparam FIFO_PTR_WIDTH = $clog2(FIFO_DEPTH);
+localparam NODE_PTR_WIDTH = $clog2(MAX_NODES);
+
+typedef enum logic [1:0] {
+  ACCEPT_NET,
+  WRITE_MEM,
+  WRITE_REP
+} net_state_t;
+
+typedef enum logic {
+  ACCEPT_MEM,
+  READ_MEM
+} mem_state_t;
+
+net_state_t net_state, net_state_next;
+mem_state_t mem_state, mem_state_next;
+
+// Signals for metadata FIFOs
+logic       net_meta_rd_en;
+logic       net_meta_empty;
+st_metadata net_meta_out;
+
+logic       mem_meta_rd_en;
+logic       mem_meta_empty;
+st_metadata mem_meta_out;
+
+// Signals for packet FIFOs
+logic                  net_fifo_rd_en;
+logic                  net_fifo_empty;
+logic                  net_fifo_prog_full;
+logic [DATA_WIDTH-1:0] net_fifo_out_tdata;
+logic [KEEP_WIDTH-1:0] net_fifo_out_tkeep;
+logic                  net_fifo_out_tlast;
+
+logic                  mem_fifo_rd_en;
+logic                  mem_fifo_empty;
+logic                  mem_fifo_prog_full;
+logic [DATA_WIDTH-1:0] mem_fifo_out_tdata;
+logic [KEEP_WIDTH-1:0] mem_fifo_out_tkeep;
+logic                  mem_fifo_out_tlast;
+
+assign s_axis_tready     = !net_fifo_prog_full;
+assign s_axis_mem_tready = !mem_fifo_prog_full;
+
+// Signals for replicating writes to backup nodes
+typedef struct packed {
+  logic [DATA_WIDTH-1:0] tdata;
+  logic [KEEP_WIDTH-1:0] tkeep;
+  logic                  tlast;
+} st_beat;
+
+(* ram_style="block" *) st_beat replica_mem [FIFO_DEPTH*8];
+st_beat replica_mem_read, replica_mem_write;
+logic [FIFO_PTR_WIDTH-1:0] rep_write_ptr, rep_write_ptr_next;
+logic [FIFO_PTR_WIDTH-1:0] rep_read_cnt, rep_read_cnt_next, rep_read_ptr;
+logic [NODE_PTR_WIDTH-1:0] nodes_count, nodes_count_next;
+logic                      rep_wr_en;
+logic                      metadata_sent, metadata_sent_next;
+logic                [1:0] memory_delay, memory_delay_next;
+
+// Signals for keeping track of replicas' write acks
+typedef struct packed {
+  st_metadata                meta;
+  logic [FIFO_PTR_WIDTH-1:0] index;
+  logic               [31:0] count;
+  logic                      is_running;
+} st_ack;
+
+(* ram_style="block" *) st_ack ack_table [FIFO_DEPTH];
+st_ack ack_table_read, ack_table_read_tmp, ack_table_write;
+logic [FIFO_PTR_WIDTH-1:0] ack_read_ptr, ack_write_ptr;
+logic [FIFO_PTR_WIDTH-1:0] ack_id, ack_id_next;
+logic                      ack_wr_en;
+
+// Infers BRAM for replica_mem and ack_table
+always_ff @(posedge axis_clk) begin
+  if (rep_wr_en)
+    replica_mem[rep_write_ptr] <= replica_mem_write;
+  replica_mem_read <= replica_mem[rep_read_ptr];
+
+  if (ack_wr_en)
+    ack_table[ack_write_ptr] <= ack_table_write;
+  ack_table_read_tmp <= ack_table[ack_read_ptr];
+  ack_table_read <= ack_table_read_tmp;
+end
+
+// Keeps track of which side is using the output interface: 10 incoming packets, 01 memory controller
+logic [1:0] out_busy, out_busy_next;
+
+// Adds dirty tag to write in memory
+logic tag_written, tag_written_next;
+
+// Signals for keeping track of nodes in the network
+logic [NODE_PTR_WIDTH-1:0] num_nodes;
+logic [NODE_PTR_WIDTH-1:0] table_index, table_index_next;
+logic               [31:0] table_ip;
+logic               [47:0] table_mac;
+
+// // Checks whether the node is the leader for given key
+// function logic is_leader (input logic [KEY_WIDTH-1:0] key);
+//   logic [NODE_PTR_WIDTH-1:0] leader_id, node_id;
+//   leader_id = key[NODE_PTR_WIDTH-1:0];
+//   node_id   = NODE_IPS[0][NODE_PTR_WIDTH-1:0];
+//   if (leader_id == node_id)
+//     return 1'b1;
+//   return 1'b0;
+// endfunction
+
+always_ff @(posedge axis_clk) begin
+  if (!axis_rstn) begin
+    net_state      <= ACCEPT_NET;
+    mem_state      <= ACCEPT_MEM;
+    ack_id         <= 1;
+    rep_read_cnt   <= '0;
+    rep_write_ptr  <= '0;
+    nodes_count    <= '0;
+    metadata_sent  <= '0;
+    out_busy       <= 1'b0;
+    memory_delay   <= '0;
+    tag_written    <= 1'b0;
+    table_index    <= 0;
+  end 
+  else begin
+    net_state      <= net_state_next;
+    mem_state      <= mem_state_next;
+    ack_id         <= ack_id_next;
+    rep_read_cnt   <= rep_read_cnt_next;
+    rep_write_ptr  <= rep_write_ptr_next;
+    nodes_count    <= nodes_count_next;
+    metadata_sent  <= metadata_sent_next;
+    out_busy       <= out_busy_next;
+    memory_delay   <= memory_delay_next;
+    tag_written    <= tag_written_next;
+    table_index    <= table_index_next;
+  end
+end
+
+always_comb begin
+  net_state_next = net_state;
+  mem_state_next = mem_state;
+  net_meta_rd_en = 1'b0;
+  net_fifo_rd_en = 1'b0;
+  mem_meta_rd_en = 1'b0;
+  mem_fifo_rd_en = 1'b0;
+
+  ack_id_next        = ack_id;
+  out_busy_next      = out_busy;
+  tag_written_next   = tag_written;
+  nodes_count_next   = nodes_count;
+  metadata_sent_next = metadata_sent;
+  memory_delay_next  = memory_delay;
+  rep_read_cnt_next  = rep_read_cnt;
+  rep_write_ptr_next = rep_write_ptr;
+  table_index_next   = table_index;
+  replica_mem_write  = 0;
+  ack_table_write    = 0;
+  rep_read_ptr       = 0;
+  ack_read_ptr       = 0;
+  ack_write_ptr      = 0;
+  rep_wr_en          = 1'b0;
+  ack_wr_en          = 1'b0;
+
+  m_axis_tvalid = 0;
+  m_axis_tdata  = 0;
+  m_axis_tkeep  = 0;
+  m_axis_tlast  = 0;
+
+  metadata_out_valid = 0;
+  metadata_out       = 0;
+
+  m_axis_mem_tvalid = 0;
+  m_axis_mem_tdata  = 0;
+  m_axis_mem_tkeep  = 0;
+  m_axis_mem_tlast  = 0;
+
+  metadata_mem_out_valid = 0;
+  metadata_mem_out       = 0;
+
+  // Process incoming packets
+  case (net_state)
+    ACCEPT_NET: begin
+      if (!net_meta_empty) begin
+        case (net_meta_out.opcode)
+          READ: begin
+            m_axis_mem_tvalid = 1'b1;
+            m_axis_mem_tdata  = '0;
+            m_axis_mem_tkeep  = '0;
+            m_axis_mem_tlast  = 1'b1;
+
+            metadata_mem_out_valid = 1'b1;
+            metadata_mem_out       = net_meta_out;
+            if (m_axis_mem_tready)
+              net_meta_rd_en = 1'b1;
+          end
+          WRITE: begin
+            m_axis_mem_tvalid = !net_fifo_empty;
+            m_axis_mem_tdata  = net_fifo_out_tdata;
+            m_axis_mem_tkeep  = net_fifo_out_tkeep;
+            m_axis_mem_tlast  = net_fifo_out_tlast;
+            net_fifo_rd_en = m_axis_mem_tready;
+            m_axis_mem_tdata[31:0] = DIRTY_TAG;
+            if (m_axis_mem_tvalid) begin
+              tag_written_next = 1'b1;
+            end
+
+            metadata_mem_out_valid = 1'b1;
+            metadata_mem_out       = net_meta_out;
+            if (m_axis_mem_tready) begin
+              if (is_leader) begin
+                net_state_next      = WRITE_REP;
+                rep_read_cnt_next   = 0;
+                rep_write_ptr_next  = 0;
+                nodes_count_next    = 0;
+
+                // Save the first beat for replicas
+                if (!net_fifo_empty) begin
+                  rep_wr_en = 1'b1;
+                  replica_mem_write.tdata = net_fifo_out_tdata;
+                  replica_mem_write.tkeep = net_fifo_out_tkeep;
+                  replica_mem_write.tlast = net_fifo_out_tlast;
+                  replica_mem_write.tdata[31:0] = DIRTY_TAG;
+                  rep_write_ptr_next = 1;
+                  tag_written_next = 1'b1;
+                end
+
+                // Start keeping track of acks for this write
+                ack_table_write.meta       = net_meta_out;
+                ack_table_write.index      = ack_id;
+                ack_table_write.count      = 0;
+                ack_table_write.is_running = 1'b1;
+                ack_write_ptr = ack_id;
+                ack_wr_en     = 1'b1;
+                ack_id_next   = ack_id + 1;
+              end
+              else begin
+                net_state_next = WRITE_MEM;
+                net_meta_rd_en = 1'b1;
+              end
+            end
+          end
+          WRITE_ACK: begin
+            ack_read_ptr  = net_meta_out.index;
+            ack_write_ptr = net_meta_out.index;
+            if (memory_delay != 2)
+              memory_delay_next = memory_delay + 1;
+            else begin
+              if (is_leader && ack_table_read.is_running) begin
+                if (!out_busy[1] && ack_table_read.count + 1 == num_nodes - 1) begin
+                  out_busy_next[0] = 1'b1;
+
+                  metadata_out_valid  = 1'b1;
+                  metadata_out        = ack_table_read.meta;
+                  metadata_out.opcode = WRITE_ACK_LEADER;
+
+                  if (m_axis_tready) begin
+                    ack_table_write.is_running = 1'b0;
+                    ack_wr_en        = 1'b1;
+                    out_busy_next[0] = 1'b0;
+                    net_meta_rd_en   = 1'b1;
+                    net_fifo_rd_en   = 1'b1; 
+                  end
+                end
+                else begin
+                  ack_table_write.count = ack_table_read.count + 1;
+                  ack_wr_en      = 1'b1;
+                  net_meta_rd_en = 1'b1;
+                  net_fifo_rd_en = 1'b1; 
+                end
+              end
+              else begin
+                net_meta_rd_en = 1'b1;
+                net_fifo_rd_en = 1'b1; 
+              end
+            end
+          end
+          default:;
+        endcase
+      end
+    end
+    WRITE_MEM: begin
+      m_axis_mem_tvalid = !net_fifo_empty;
+      m_axis_mem_tdata  = net_fifo_out_tdata;
+      m_axis_mem_tkeep  = net_fifo_out_tkeep;
+      m_axis_mem_tlast  = net_fifo_out_tlast;
+      net_fifo_rd_en = m_axis_mem_tready;
+      if (!tag_written_next) begin
+        m_axis_mem_tdata[31:0] = DIRTY_TAG;
+        if (m_axis_mem_tvalid && m_axis_mem_tready) begin
+          tag_written_next = 1'b1;
+        end
+      end
+      if (m_axis_mem_tvalid && m_axis_mem_tready && m_axis_mem_tlast) begin
+        tag_written_next = 1'b0;
+        net_state_next   = ACCEPT_NET;
+      end
+    end
+    WRITE_REP: begin
+      //FIXME: write pointer should always be at least one higher than read pointer
+      rep_read_ptr = rep_read_cnt;
+
+      // While writing to the first node, also move the write to the memory controller
+      if (nodes_count == 0) begin
+        m_axis_mem_tvalid = !net_fifo_empty;
+        m_axis_mem_tdata  = net_fifo_out_tdata;
+        m_axis_mem_tkeep  = net_fifo_out_tkeep;
+        m_axis_mem_tlast  = net_fifo_out_tlast;
+        net_fifo_rd_en = m_axis_mem_tready;
+        if (!tag_written) begin
+          m_axis_mem_tdata[31:0] = DIRTY_TAG;
+          tag_written_next = 1'b1;
+        end
+
+        if (m_axis_mem_tvalid && m_axis_mem_tready) begin
+          replica_mem_write.tdata = net_fifo_out_tdata;
+          replica_mem_write.tkeep = net_fifo_out_tkeep;
+          replica_mem_write.tlast = net_fifo_out_tlast;
+          rep_write_ptr_next = rep_write_ptr + 1;
+          rep_wr_en = 1'b1;
+        end
+      end
+
+      // Wait for the replica memory to output first value
+      if (memory_delay != 2)
+        memory_delay_next = memory_delay + 1;
+      else begin
+        if (!out_busy[1]) begin
+          out_busy_next[0] = 1'b1;
+          m_axis_tvalid = 1'b1;
+          m_axis_tdata  = replica_mem_read.tdata;
+          m_axis_tkeep  = replica_mem_read.tkeep;
+          m_axis_tlast  = replica_mem_read.tlast;
+
+          if (rep_read_cnt == 0) begin
+            metadata_out_valid = 1'b1;
+            metadata_out       = net_meta_out;
+            metadata_out.index = ack_id - 1;
+            metadata_out.ip    = table_ip;
+            metadata_out.mac   = table_mac;
+          end
+
+          if (m_axis_tready) begin
+            rep_read_ptr      = rep_read_cnt + 1;
+            rep_read_cnt_next = rep_read_cnt + 1;
+            if (m_axis_tlast) begin
+              rep_read_cnt_next  = 0;
+              rep_read_ptr       = 0;
+              metadata_sent_next = 1'b0;
+              nodes_count_next   = nodes_count + 1;
+              // Wait one cycle for IP BRAM answer
+              table_index_next   = table_index + 1;
+              memory_delay_next  = 1;
+              if (nodes_count + 1 == num_nodes - 1) begin
+                net_state_next    = ACCEPT_NET;
+                net_meta_rd_en    = 1'b1;
+                out_busy_next[0]  = 1'b0;
+                memory_delay_next = 0;
+              end
+            end
+          end
+        end
+      end
+    end
+    default:;
+  endcase
+
+  // Process incoming memory controller data
+  if (!out_busy[0] && !out_busy_next[0]) begin
+    case (mem_state)
+      ACCEPT_MEM: begin
+        if (!mem_meta_empty) begin
+          out_busy_next[1] = 1'b1;
+          case (mem_meta_out.opcode)
+            READ: begin
+              m_axis_tvalid = !mem_fifo_empty;
+              m_axis_tdata  = mem_fifo_out_tdata;
+              m_axis_tkeep  = mem_fifo_out_tkeep;
+              m_axis_tlast  = mem_fifo_out_tlast;
+              mem_fifo_rd_en = m_axis_tready;
+
+              metadata_out_valid  = 1'b1;
+              metadata_out        = mem_meta_out;
+              metadata_out.opcode = READ_RESULT;
+
+              if (m_axis_tready) begin
+                mem_state_next = READ_MEM;
+                mem_meta_rd_en = 1'b1;
+              end
+            end
+            WRITE: begin
+              if (!is_leader) begin
+                metadata_out_valid  = 1'b1;
+                metadata_out        = mem_meta_out;
+                metadata_out.opcode = WRITE_ACK;
+
+                if (m_axis_tready) begin
+                  out_busy_next[1] = 1'b0;
+                  mem_meta_rd_en   = 1'b1;
+                  mem_fifo_rd_en   = 1'b1;
+                end
+              end
+              else begin
+                out_busy_next[1] = 1'b0;
+                mem_meta_rd_en   = 1'b1;
+                mem_fifo_rd_en   = 1'b1;
+              end
+            end
+            default:;
+          endcase
+        end
+      end
+      READ_MEM: begin
+        m_axis_tvalid = !mem_fifo_empty;
+        m_axis_tdata  = mem_fifo_out_tdata;
+        m_axis_tkeep  = mem_fifo_out_tkeep;
+        m_axis_tlast  = mem_fifo_out_tlast;
+        mem_fifo_rd_en = m_axis_tready;
+
+        if (m_axis_tvalid && m_axis_tready && m_axis_tlast) begin
+          out_busy_next[1] = 1'b0;
+          mem_state_next = ACCEPT_MEM;
+        end
+      end
+      default:;
+    endcase
+  end
+end
+
+// FIXME: Needs to receive a memory operation before table is populated 
+nodes_table #( 
+  .TABLE_SIZE     (MAX_NODES)
+) nodes_table_inst (
+  .aclk           (axis_clk),
+  .rstn           (axis_rstn),
+
+  .metadata_valid (metadata_in_valid),
+  .metadata       (metadata_in),
+
+  .num_nodes      (num_nodes),
+  .index          (table_index),
+  .ip             (table_ip),
+  .mac            (table_mac)
+);
+
+logic net_fifo_wr_en;
+assign net_fifo_wr_en = s_axis_tvalid && |s_axis_tkeep;
+
+// FIFO to store input replication packets
+xpm_fifo_sync #(
+  .DOUT_RESET_VALUE    ("0"),
+  .ECC_MODE            ("no_ecc"),
+  .FIFO_MEMORY_TYPE    ("auto"),
+  .FIFO_READ_LATENCY   (1),
+  .FIFO_WRITE_DEPTH    (FIFO_DEPTH*8),
+  .PROG_FULL_THRESH    (FIFO_DEPTH*8-5),
+  .READ_DATA_WIDTH     (DATA_WIDTH + KEEP_WIDTH + 1),
+  .READ_MODE           ("fwft"),
+  .WRITE_DATA_WIDTH    (DATA_WIDTH + KEEP_WIDTH + 1)
+) net_fifo (
+  .wr_en               (net_fifo_wr_en),
+  .din                 ({s_axis_tdata, s_axis_tkeep, s_axis_tlast}),
+  .wr_ack              (),
+  .rd_en               (net_fifo_rd_en),
+  .data_valid          (),
+  .dout                ({net_fifo_out_tdata, net_fifo_out_tkeep, net_fifo_out_tlast}),
+  .wr_data_count       (),
+  .rd_data_count       (),
+  .empty               (net_fifo_empty),
+  .full                (),
+  .almost_empty        (),
+  .almost_full         (),
+  .overflow            (),
+  .underflow           (),
+  .prog_empty          (),
+  .prog_full           (net_fifo_prog_full),
+  .sleep               (1'b0),
+  .sbiterr             (),
+  .dbiterr             (),
+  .injectsbiterr       (1'b0),
+  .injectdbiterr       (1'b0),
+  .wr_clk              (axis_clk),
+  .rst                 (~axis_rstn),
+  .rd_rst_busy         (),
+  .wr_rst_busy         ()
+);
+
+// FIFO to store input replication metadata
+xpm_fifo_sync #(
+  .DOUT_RESET_VALUE    ("0"),
+  .ECC_MODE            ("no_ecc"),
+  .FIFO_MEMORY_TYPE    ("auto"),
+  .FIFO_READ_LATENCY   (1),
+  .FIFO_WRITE_DEPTH    (FIFO_DEPTH),
+  .PROG_FULL_THRESH    (FIFO_DEPTH-5),
+  .READ_DATA_WIDTH     (METADATA_WIDTH),
+  .READ_MODE           ("fwft"),
+  .WRITE_DATA_WIDTH    (METADATA_WIDTH)
+) net_metadata_fifo (
+  .wr_en               (metadata_in_valid),
+  .din                 (metadata_in),
+  .wr_ack              (),
+  .rd_en               (net_meta_rd_en),
+  .data_valid          (),
+  .dout                (net_meta_out),
+  .wr_data_count       (),
+  .rd_data_count       (),
+  .empty               (net_meta_empty),
+  .full                (),
+  .almost_empty        (),
+  .almost_full         (),
+  .overflow            (),
+  .underflow           (),
+  .prog_empty          (),
+  .prog_full           (),
+  .sleep               (1'b0),
+  .sbiterr             (),
+  .dbiterr             (),
+  .injectsbiterr       (1'b0),
+  .injectdbiterr       (1'b0),
+  .wr_clk              (axis_clk),
+  .rst                 (~axis_rstn),
+  .rd_rst_busy         (),
+  .wr_rst_busy         ()
+);
+
+logic mem_fifo_wr_en;
+assign mem_fifo_wr_en = s_axis_mem_tvalid && |s_axis_mem_tkeep;
+
+// FIFO to store input memory controller packets
+xpm_fifo_sync #(
+  .DOUT_RESET_VALUE    ("0"),
+  .ECC_MODE            ("no_ecc"),
+  .FIFO_MEMORY_TYPE    ("auto"),
+  .FIFO_READ_LATENCY   (1),
+  .FIFO_WRITE_DEPTH    (FIFO_DEPTH*8),
+  .PROG_FULL_THRESH    (FIFO_DEPTH*8-5),
+  .READ_DATA_WIDTH     (DATA_WIDTH + KEEP_WIDTH + 1),
+  .READ_MODE           ("fwft"),
+  .WRITE_DATA_WIDTH    (DATA_WIDTH + KEEP_WIDTH + 1)
+) mem_fifo (
+  .wr_en               (s_axis_mem_tvalid),
+  .din                 ({s_axis_mem_tdata, s_axis_mem_tkeep, s_axis_mem_tlast}),
+  .wr_ack              (),
+  .rd_en               (mem_fifo_rd_en),
+  .data_valid          (),
+  .dout                ({mem_fifo_out_tdata, mem_fifo_out_tkeep, mem_fifo_out_tlast}),
+  .wr_data_count       (),
+  .rd_data_count       (),
+  .empty               (mem_fifo_empty),
+  .full                (),
+  .almost_empty        (),
+  .almost_full         (),
+  .overflow            (),
+  .underflow           (),
+  .prog_empty          (),
+  .prog_full           (mem_fifo_prog_full),
+  .sleep               (1'b0),
+  .sbiterr             (),
+  .dbiterr             (),
+  .injectsbiterr       (1'b0),
+  .injectdbiterr       (1'b0),
+  .wr_clk              (axis_clk),
+  .rst                 (~axis_rstn),
+  .rd_rst_busy         (),
+  .wr_rst_busy         ()
+);
+
+// FIFO to store input memory controller metadata
+xpm_fifo_sync #(
+  .DOUT_RESET_VALUE    ("0"),
+  .ECC_MODE            ("no_ecc"),
+  .FIFO_MEMORY_TYPE    ("auto"),
+  .FIFO_READ_LATENCY   (1),
+  .FIFO_WRITE_DEPTH    (FIFO_DEPTH),
+  .PROG_FULL_THRESH    (FIFO_DEPTH-5),
+  .READ_DATA_WIDTH     (METADATA_WIDTH),
+  .READ_MODE           ("fwft"),
+  .WRITE_DATA_WIDTH    (METADATA_WIDTH)
+) mem_metadata_fifo (
+  .wr_en               (metadata_mem_in_valid),
+  .din                 (metadata_mem_in),
+  .wr_ack              (),
+  .rd_en               (mem_meta_rd_en),
+  .data_valid          (),
+  .dout                (mem_meta_out),
+  .wr_data_count       (),
+  .rd_data_count       (),
+  .empty               (mem_meta_empty),
+  .full                (),
+  .almost_empty        (),
+  .almost_full         (),
+  .overflow            (),
+  .underflow           (),
+  .prog_empty          (),
+  .prog_full           (),
+  .sleep               (1'b0),
+  .sbiterr             (),
+  .dbiterr             (),
+  .injectsbiterr       (1'b0),
+  .injectdbiterr       (1'b0),
+  .wr_clk              (axis_clk),
+  .rst                 (~axis_rstn),
+  .rd_rst_busy         (),
+  .wr_rst_busy         ()
+);
+
+endmodule
diff --git a/src/hbm_subsystem/replication_subsystem.sv b/src/hbm_subsystem/replication_subsystem.sv
new file mode 100644
index 0000000..d6eeee9
--- /dev/null
+++ b/src/hbm_subsystem/replication_subsystem.sv
@@ -0,0 +1,431 @@
+`timescale 1ns/1ps
+
+import metadata_pkg::*;
+
+module replication_subsystem #(
+  parameter int          DATA_WIDTH  = 512,
+  parameter int          KEEP_WIDTH  = DATA_WIDTH / 8,
+  parameter int          FIFO_DEPTH  = 16,
+  parameter logic [31:0] NODE_IP     = 0,
+  parameter logic [47:0] NODE_MAC    = 0,
+  parameter int          MAX_NODES   = 32,
+  parameter int          BUCKET_SIZE = 1024,
+  parameter int          NUM_HASHES  = 4,
+  parameter int          HASH_WIDTH  = 24,
+  parameter int          TIMER_WIDTH = 25,  // ~134ms
+  parameter int          SEED        = 32'hdeadbeef,
+  parameter logic [TIMER_WIDTH-1:0] TAP_MASK = 25'h1200000,
+  parameter logic [HASH_WIDTH-1:0] HASH_MATRIX [NUM_HASHES][KEY_WIDTH-1:0] = '{default: '0}
+) (
+  input  logic axi_clk,
+  input  logic axi_rstn,
+
+  input  logic                  s_axis_tvalid,
+  input  logic [DATA_WIDTH-1:0] s_axis_tdata,
+  input  logic [KEEP_WIDTH-1:0] s_axis_tkeep,
+  input  logic                  s_axis_tlast,
+  output logic                  s_axis_tready,
+
+  input  st_metadata            metadata_in,
+  input  logic                  metadata_in_valid,
+
+  output logic                  m_axis_tvalid,
+  output logic [DATA_WIDTH-1:0] m_axis_tdata,
+  output logic [KEEP_WIDTH-1:0] m_axis_tkeep,
+  output logic                  m_axis_tlast,
+  input  logic                  m_axis_tready,
+
+  output st_metadata            metadata_out,
+  output logic                  metadata_out_valid,
+
+  input  logic                  s_axis_dm_tvalid,
+  input  logic [DATA_WIDTH-1:0] s_axis_dm_tdata,
+  input  logic [KEEP_WIDTH-1:0] s_axis_dm_tkeep,
+  input  logic                  s_axis_dm_tlast,
+  output logic                  s_axis_dm_tready,
+
+  output logic                  m_axis_dm_tvalid,
+  output logic [DATA_WIDTH-1:0] m_axis_dm_tdata,
+  output logic [KEEP_WIDTH-1:0] m_axis_dm_tkeep,
+  output logic                  m_axis_dm_tlast,
+  input  logic                  m_axis_dm_tready,
+
+  output logic                  m_axis_dm_mm2s_cmd_tvalid,
+  output logic           [79:0] m_axis_dm_mm2s_cmd_tdata,
+  input  logic                  m_axis_dm_mm2s_cmd_tready,
+
+  output logic                  m_axis_dm_s2mm_cmd_tvalid,
+  output logic           [79:0] m_axis_dm_s2mm_cmd_tdata,
+  input  logic                  m_axis_dm_s2mm_cmd_tready,
+
+  output logic           [33:0] m_axi_araddr   [NUM_HASHES],
+  output logic            [1:0] m_axi_arburst  [NUM_HASHES],
+  output logic            [3:0] m_axi_arcache  [NUM_HASHES],
+  output logic            [3:0] m_axi_arid     [NUM_HASHES],
+  output logic            [3:0] m_axi_arlen    [NUM_HASHES],
+  output logic            [1:0] m_axi_arlock   [NUM_HASHES],
+  output logic            [2:0] m_axi_arprot   [NUM_HASHES],
+  input  logic                  m_axi_arready  [NUM_HASHES],
+  output logic            [2:0] m_axi_arsize   [NUM_HASHES],
+  output logic                  m_axi_arvalid  [NUM_HASHES],
+  output logic           [33:0] m_axi_awaddr   [NUM_HASHES],
+  output logic            [1:0] m_axi_awburst  [NUM_HASHES],
+  output logic            [3:0] m_axi_awcache  [NUM_HASHES],
+  output logic            [3:0] m_axi_awid     [NUM_HASHES],
+  output logic            [3:0] m_axi_awlen    [NUM_HASHES],
+  output logic            [1:0] m_axi_awlock   [NUM_HASHES],
+  output logic            [2:0] m_axi_awprot   [NUM_HASHES],
+  input  logic                  m_axi_awready  [NUM_HASHES],
+  output logic            [2:0] m_axi_awsize   [NUM_HASHES],
+  output logic                  m_axi_awvalid  [NUM_HASHES],
+  input  logic            [3:0] m_axi_bid      [NUM_HASHES],
+  output logic                  m_axi_bready   [NUM_HASHES],
+  input  logic            [1:0] m_axi_bresp    [NUM_HASHES],
+  input  logic                  m_axi_bvalid   [NUM_HASHES],
+  input  logic          [255:0] m_axi_rdata    [NUM_HASHES],
+  input  logic            [3:0] m_axi_rid      [NUM_HASHES],
+  input  logic                  m_axi_rlast    [NUM_HASHES],
+  output logic                  m_axi_rready   [NUM_HASHES],
+  input  logic            [1:0] m_axi_rresp    [NUM_HASHES],
+  input  logic                  m_axi_rvalid   [NUM_HASHES],
+  output logic          [255:0] m_axi_wdata    [NUM_HASHES],
+  output logic                  m_axi_wlast    [NUM_HASHES],
+  input  logic                  m_axi_wready   [NUM_HASHES],
+  output logic           [31:0] m_axi_wstrb    [NUM_HASHES],
+  output logic                  m_axi_wvalid   [NUM_HASHES]
+);
+
+logic         axis_engine_to_memory_tvalid;
+logic [511:0] axis_engine_to_memory_tdata;
+logic  [63:0] axis_engine_to_memory_tkeep;
+logic         axis_engine_to_memory_tlast;
+logic         axis_engine_to_memory_tready;
+
+logic         axis_memory_to_engine_tvalid;
+logic [511:0] axis_memory_to_engine_tdata;
+logic  [63:0] axis_memory_to_engine_tkeep;
+logic         axis_memory_to_engine_tlast;
+logic         axis_memory_to_engine_tready;
+
+logic         axis_engine_to_deparser_tvalid;
+logic [511:0] axis_engine_to_deparser_tdata;
+logic  [63:0] axis_engine_to_deparser_tkeep;
+logic         axis_engine_to_deparser_tlast;
+logic         axis_engine_to_deparser_tready;
+
+st_metadata replication_metadata_in;
+logic       replication_metadata_in_valid;
+st_metadata replication_metadata_out;
+logic       replication_metadata_out_valid;
+st_metadata election_metadata_in;
+logic       election_metadata_in_valid;
+st_metadata election_metadata_out;
+logic       election_metadata_out_valid;
+st_metadata memory_metadata_in;
+logic       memory_metadata_in_valid;
+st_metadata memory_metadata_out;
+logic       memory_metadata_out_valid;
+
+logic is_leader;
+
+// Arbiter between replication payload and frame padding
+always_comb begin
+  m_axis_tvalid = axis_engine_to_deparser_tvalid;
+  m_axis_tdata  = axis_engine_to_deparser_tdata;
+  m_axis_tkeep  = axis_engine_to_deparser_tkeep;
+  m_axis_tlast  = axis_engine_to_deparser_tlast;
+  axis_engine_to_deparser_tready = m_axis_tready; 
+  if (metadata_out_valid) begin
+    if (metadata_out.opcode != READ_RESULT && metadata_out.opcode != WRITE) begin
+      m_axis_tvalid = 1'b1;
+      m_axis_tdata  = '0;
+      m_axis_tkeep  = 64'hfff;
+      m_axis_tlast  = 1'b1;
+    end
+  end
+end
+
+// Buffer metadata arbiter inputs in FIFO
+st_metadata election_metadata_out_reg;
+logic       election_metadata_ready;
+logic       election_metadata_empty;
+st_metadata replication_metadata_out_reg;
+logic       replication_metadata_ready;
+logic       replication_metadata_empty;
+
+
+metadata_filter metadata_filter_inst (
+  .s_axis_tvalid  (metadata_in_valid), 
+  .s_axis_tdata   (metadata_in),
+  .s_axis_tdest   (metadata_in.opcode),
+
+  .m_axis_tvalid  ({election_metadata_in_valid, replication_metadata_in_valid}), 
+  .m_axis_tdata   ({election_metadata_in, replication_metadata_in}),
+  .m_axis_tdest   (),
+
+  .aclk           (axi_clk),
+  .aresetn        (axi_rstn)
+);
+
+metadata_arbiter metadata_arbiter_inst (
+  .s_axis_tvalid  ({!election_metadata_empty, !replication_metadata_empty}), 
+  .s_axis_tdata   ({election_metadata_out_reg, replication_metadata_out_reg}),
+  .s_axis_tready  ({election_metadata_ready, replication_metadata_ready}),
+
+  .m_axis_tvalid  (metadata_out_valid),
+  .m_axis_tdata   (metadata_out),
+  .m_axis_tready  (1'b1),
+
+  .s_req_suppress (2'b00),
+  .aclk           (axi_clk),
+  .aresetn        (axi_rstn)
+);
+
+replication_engine #(
+  .MAX_NODES                 (MAX_NODES),
+  .DATA_WIDTH                (DATA_WIDTH),
+  .FIFO_DEPTH                (FIFO_DEPTH),
+  .NODE_IP                   (NODE_IP),
+  .NODE_MAC                  (NODE_MAC)
+) replication_engine_inst    (
+  .axis_clk                  (axi_clk),
+  .axis_rstn                 (axi_rstn),
+
+  .s_axis_tvalid             (s_axis_tvalid && s_axis_tkeep != 64'b0),
+  .s_axis_tdata              (s_axis_tdata),
+  .s_axis_tkeep              (s_axis_tkeep),
+  .s_axis_tlast              (s_axis_tlast),
+  .s_axis_tready             (s_axis_tready),
+
+  .metadata_in               (replication_metadata_in),
+  .metadata_in_valid         (replication_metadata_in_valid),
+
+  .m_axis_tvalid             (axis_engine_to_deparser_tvalid),
+  .m_axis_tdata              (axis_engine_to_deparser_tdata),
+  .m_axis_tkeep              (axis_engine_to_deparser_tkeep),
+  .m_axis_tlast              (axis_engine_to_deparser_tlast),
+  .m_axis_tready             (axis_engine_to_deparser_tready),
+
+  .metadata_out              (replication_metadata_out),
+  .metadata_out_valid        (replication_metadata_out_valid),
+
+  .s_axis_mem_tvalid         (axis_memory_to_engine_tvalid),
+  .s_axis_mem_tdata          (axis_memory_to_engine_tdata),
+  .s_axis_mem_tkeep          (axis_memory_to_engine_tkeep),
+  .s_axis_mem_tlast          (axis_memory_to_engine_tlast),
+  .s_axis_mem_tready         (axis_memory_to_engine_tready),
+
+  .metadata_mem_in           (memory_metadata_out),
+  .metadata_mem_in_valid     (memory_metadata_out_valid),
+
+  .m_axis_mem_tvalid         (axis_engine_to_memory_tvalid),
+  .m_axis_mem_tdata          (axis_engine_to_memory_tdata),
+  .m_axis_mem_tkeep          (axis_engine_to_memory_tkeep),
+  .m_axis_mem_tlast          (axis_engine_to_memory_tlast),
+  .m_axis_mem_tready         (axis_engine_to_memory_tready),
+
+  .metadata_mem_out          (memory_metadata_in),
+  .metadata_mem_out_valid    (memory_metadata_in_valid),
+
+  .is_leader                 (is_leader)
+);
+
+election_engine #(
+  .FIFO_DEPTH                (FIFO_DEPTH),
+  .TIMER_WIDTH               (25),
+  .SEED                      (32'hdeadbeef),
+  .TAP_MASK                  (25'h1200000),
+  .NODE_IP                   (NODE_IP)
+) election_engine_inst (
+  .axi_aclk                 (axi_clk),
+  .axi_rstn                 (axi_rstn),
+
+  .s_axi_awaddr              ('0),
+  .s_axi_awvalid             (1'b0),
+  .s_axi_awready             (),
+  .s_axi_wdata               ('0),
+  .s_axi_wstrb               ('0),
+  .s_axi_wvalid              (1'b0),
+  .s_axi_wready              (),
+  .s_axi_bresp               (),
+  .s_axi_bvalid              (),
+  .s_axi_bready              (1'b1),
+  .s_axi_araddr              ('0),
+  .s_axi_arvalid             (1'b0),
+  .s_axi_arready             (),
+  .s_axi_rdata               (),
+  .s_axi_rresp               (),
+  .s_axi_rvalid              (),
+  .s_axi_rready              (1'b1),
+
+  .metadata_in               (election_metadata_in),
+  .metadata_in_valid         (election_metadata_in_valid),
+
+  .metadata_out              (election_metadata_out),
+  .metadata_out_valid        (election_metadata_out_valid),
+
+  .is_leader                 (is_leader)
+);
+
+cuckoo_hash #(
+  .DATA_WIDTH                (512),
+  .BUCKET_SIZE               (BUCKET_SIZE),
+  .NUM_FUNCTIONS             (NUM_HASHES),
+  .MAX_KICKS                 (4),
+  .HASH_MATRIX               (HASH_MATRIX)
+) cuckoo_hash_inst (
+  .m_axi_araddr              (m_axi_araddr),
+  .m_axi_arburst             (m_axi_arburst),
+  .m_axi_arcache             (m_axi_arcache),
+  .m_axi_arid                (m_axi_arid),
+  .m_axi_arlen               (m_axi_arlen),
+  .m_axi_arlock              (m_axi_arlock),
+  .m_axi_arprot              (m_axi_arprot),
+  .m_axi_arready             (m_axi_arready),
+  .m_axi_arsize              (m_axi_arsize),
+  .m_axi_arvalid             (m_axi_arvalid),
+  .m_axi_awaddr              (m_axi_awaddr),
+  .m_axi_awburst             (m_axi_awburst),
+  .m_axi_awcache             (m_axi_awcache),
+  .m_axi_awid                (m_axi_awid),
+  .m_axi_awlen               (m_axi_awlen),
+  .m_axi_awlock              (m_axi_awlock),
+  .m_axi_awprot              (m_axi_awprot),
+  .m_axi_awready             (m_axi_awready),
+  .m_axi_awsize              (m_axi_awsize),
+  .m_axi_awvalid             (m_axi_awvalid),
+  .m_axi_bid                 (m_axi_bid),
+  .m_axi_bready              (m_axi_bready),
+  .m_axi_bresp               (m_axi_bresp),
+  .m_axi_bvalid              (m_axi_bvalid),
+  .m_axi_rdata               (m_axi_rdata),
+  .m_axi_rid                 (m_axi_rid),
+  .m_axi_rlast               (m_axi_rlast),
+  .m_axi_rready              (m_axi_rready),
+  .m_axi_rresp               (m_axi_rresp),
+  .m_axi_rvalid              (m_axi_rvalid),
+  .m_axi_wdata               (m_axi_wdata),
+  .m_axi_wlast               (m_axi_wlast),
+  .m_axi_wready              (m_axi_wready),
+  .m_axi_wstrb               (m_axi_wstrb),
+  .m_axi_wvalid              (m_axi_wvalid),
+
+  .s_axis_tready             (axis_engine_to_memory_tready),
+  .s_axis_tdata              (axis_engine_to_memory_tdata),
+  .s_axis_tkeep              (axis_engine_to_memory_tkeep),
+  .s_axis_tlast              (axis_engine_to_memory_tlast),
+  .s_axis_tvalid             (axis_engine_to_memory_tvalid),
+
+  .metadata_in               (memory_metadata_in),
+  .metadata_in_valid         (memory_metadata_in_valid),
+
+  .m_axis_tready             (axis_memory_to_engine_tready),
+  .m_axis_tdata              (axis_memory_to_engine_tdata),
+  .m_axis_tkeep              (axis_memory_to_engine_tkeep),
+  .m_axis_tlast              (axis_memory_to_engine_tlast),
+  .m_axis_tvalid             (axis_memory_to_engine_tvalid),
+
+  .metadata_out              (memory_metadata_out),
+  .metadata_out_valid        (memory_metadata_out_valid),
+
+  .s_axis_dm_tvalid          (s_axis_dm_tvalid),
+  .s_axis_dm_tdata           (s_axis_dm_tdata),
+  .s_axis_dm_tkeep           (s_axis_dm_tkeep),
+  .s_axis_dm_tlast           (s_axis_dm_tlast),
+  .s_axis_dm_tready          (s_axis_dm_tready),
+
+  .m_axis_dm_tvalid          (m_axis_dm_tvalid),
+  .m_axis_dm_tdata           (m_axis_dm_tdata),
+  .m_axis_dm_tkeep           (m_axis_dm_tkeep),
+  .m_axis_dm_tlast           (m_axis_dm_tlast),
+  .m_axis_dm_tready          (m_axis_dm_tready),
+
+  .m_axis_dm_mm2s_cmd_tvalid (m_axis_dm_mm2s_cmd_tvalid),
+  .m_axis_dm_mm2s_cmd_tdata  (m_axis_dm_mm2s_cmd_tdata),
+  .m_axis_dm_mm2s_cmd_tready (m_axis_dm_mm2s_cmd_tready),
+
+  .m_axis_dm_s2mm_cmd_tvalid (m_axis_dm_s2mm_cmd_tvalid),
+  .m_axis_dm_s2mm_cmd_tdata  (m_axis_dm_s2mm_cmd_tdata),
+  .m_axis_dm_s2mm_cmd_tready (m_axis_dm_s2mm_cmd_tready),
+
+  .clk                       (axi_clk),
+  .rstn                      (axi_rstn)
+);
+
+xpm_fifo_sync #(
+  .DOUT_RESET_VALUE    ("0"),
+  .ECC_MODE            ("no_ecc"),
+  .FIFO_MEMORY_TYPE    ("auto"),
+  .FIFO_READ_LATENCY   (1),
+  .FIFO_WRITE_DEPTH    (FIFO_DEPTH),
+  .PROG_FULL_THRESH    (FIFO_DEPTH-5),
+  .READ_DATA_WIDTH     (METADATA_WIDTH),
+  .READ_MODE           ("fwft"),
+  .WRITE_DATA_WIDTH    (METADATA_WIDTH)
+) election_metadata (
+  .wr_en               (election_metadata_out_valid),
+  .din                 (election_metadata_out),
+  .wr_ack              (),
+  .rd_en               (election_metadata_ready),
+  .data_valid          (),
+  .dout                (election_metadata_out_reg),
+  .wr_data_count       (),
+  .rd_data_count       (),
+  .empty               (election_metadata_empty),
+  .full                (),
+  .almost_empty        (),
+  .almost_full         (),
+  .overflow            (),
+  .underflow           (),
+  .prog_empty          (),
+  .prog_full           (),
+  .sleep               (1'b0),
+  .sbiterr             (),
+  .dbiterr             (),
+  .injectsbiterr       (1'b0),
+  .injectdbiterr       (1'b0),
+  .wr_clk              (axi_clk),
+  .rst                 (~axi_rstn),
+  .rd_rst_busy         (),
+  .wr_rst_busy         ()
+);
+
+xpm_fifo_sync #(
+  .DOUT_RESET_VALUE    ("0"),
+  .ECC_MODE            ("no_ecc"),
+  .FIFO_MEMORY_TYPE    ("auto"),
+  .FIFO_READ_LATENCY   (1),
+  .FIFO_WRITE_DEPTH    (FIFO_DEPTH),
+  .PROG_FULL_THRESH    (FIFO_DEPTH-5),
+  .READ_DATA_WIDTH     (METADATA_WIDTH),
+  .READ_MODE           ("fwft"),
+  .WRITE_DATA_WIDTH    (METADATA_WIDTH)
+) replication_metadata (
+  .wr_en               (replication_metadata_out_valid),
+  .din                 (replication_metadata_out),
+  .wr_ack              (),
+  .rd_en               (replication_metadata_ready),
+  .data_valid          (),
+  .dout                (replication_metadata_out_reg),
+  .wr_data_count       (),
+  .rd_data_count       (),
+  .empty               (replication_metadata_empty),
+  .full                (),
+  .almost_empty        (),
+  .almost_full         (),
+  .overflow            (),
+  .underflow           (),
+  .prog_empty          (),
+  .prog_full           (),
+  .sleep               (1'b0),
+  .sbiterr             (),
+  .dbiterr             (),
+  .injectsbiterr       (1'b0),
+  .injectdbiterr       (1'b0),
+  .wr_clk              (axi_clk),
+  .rst                 (~axi_rstn),
+  .rd_rst_busy         (),
+  .wr_rst_busy         ()
+);
+
+endmodule
\ No newline at end of file
diff --git a/src/hbm_subsystem/vivado_ip/metadata_arbiter.tcl b/src/hbm_subsystem/vivado_ip/metadata_arbiter.tcl
new file mode 100644
index 0000000..ce3d289
--- /dev/null
+++ b/src/hbm_subsystem/vivado_ip/metadata_arbiter.tcl
@@ -0,0 +1,4 @@
+create_ip -name axis_switch -vendor xilinx.com -library ip -module_name metadata_arbiter -dir ${ip_build_dir}
+set_property -dict { 
+  CONFIG.TDATA_NUM_BYTES {20}
+} [get_ips packet_arbiter]
\ No newline at end of file
diff --git a/src/hbm_subsystem/vivado_ip/metadata_filter.tcl b/src/hbm_subsystem/vivado_ip/metadata_filter.tcl
new file mode 100644
index 0000000..01d223c
--- /dev/null
+++ b/src/hbm_subsystem/vivado_ip/metadata_filter.tcl
@@ -0,0 +1,10 @@
+create_ip -name axis_switch -vendor xilinx.com -library ip -module_name metadata_filter -dir ${ip_build_dir}
+set_property -dict { 
+  CONFIG.HAS_TREADY {0} \
+  CONFIG.M00_AXIS_HIGHTDEST {0x00000005} \
+  CONFIG.M01_AXIS_BASETDEST {0x00000006} \
+  CONFIG.M01_AXIS_HIGHTDEST {0x00000009} \
+  CONFIG.NUM_SI {1} \
+  CONFIG.TDATA_NUM_BYTES {20} \
+  CONFIG.TDEST_WIDTH {8} \
+} [get_ips packet_filter]
\ No newline at end of file
diff --git a/src/hbm_subsystem/vivado_ip/packet_arbiter.tcl b/src/hbm_subsystem/vivado_ip/packet_arbiter.tcl
new file mode 100644
index 0000000..1da9db5
--- /dev/null
+++ b/src/hbm_subsystem/vivado_ip/packet_arbiter.tcl
@@ -0,0 +1,9 @@
+create_ip -name axis_switch -vendor xilinx.com -library ip -module_name packet_arbiter -dir ${ip_build_dir}
+set_property -dict { 
+  CONFIG.ARB_ON_MAX_XFERS {0} \
+  CONFIG.ARB_ON_TLAST {1} \
+  CONFIG.HAS_TKEEP {1} \
+  CONFIG.HAS_TLAST {1} \
+  CONFIG.TDATA_NUM_BYTES {64} \
+  CONFIG.TUSER_WIDTH {48} \
+} [get_ips packet_arbiter]
\ No newline at end of file
diff --git a/src/hbm_subsystem/vivado_ip/packet_deparser.tcl b/src/hbm_subsystem/vivado_ip/packet_deparser.tcl
new file mode 100644
index 0000000..50e66fa
--- /dev/null
+++ b/src/hbm_subsystem/vivado_ip/packet_deparser.tcl
@@ -0,0 +1,18 @@
+set prj_root [file normalize ..]
+set p4_filepath ${prj_root}/src/hbm_subsystem
+
+if {[info exists p4_dir]} {
+  set p4file [glob -directory ${p4_dir} packet_deparser.p4]
+} else {
+  set p4file [glob -directory ${p4_filepath} packet_deparser.p4]
+}
+
+puts "p4file = ${p4file}"
+
+create_ip -name vitis_net_p4 -vendor xilinx.com -library ip -module_name packet_deparser -dir ${ip_build_dir}
+set_property CONFIG.P4_FILE "${p4file}" [get_ips packet_deparser]
+set_property -dict { 
+  CONFIG.AXIS_CLK_FREQ_MHZ {250} \
+  CONFIG.CAM_MEM_CLK_FREQ_MHZ {250} \
+  CONFIG.PKT_RATE {250} \
+} [get_ips packet_deparser]
\ No newline at end of file
diff --git a/src/hbm_subsystem/vivado_ip/packet_filter.tcl b/src/hbm_subsystem/vivado_ip/packet_filter.tcl
new file mode 100644
index 0000000..a7014d8
--- /dev/null
+++ b/src/hbm_subsystem/vivado_ip/packet_filter.tcl
@@ -0,0 +1,8 @@
+create_ip -name axis_switch -vendor xilinx.com -library ip -module_name packet_filter -dir ${ip_build_dir}
+set_property -dict { 
+  CONFIG.HAS_TKEEP {1} \
+  CONFIG.HAS_TLAST {1} \
+  CONFIG.NUM_SI {1} \
+  CONFIG.TDATA_NUM_BYTES {64} \
+  CONFIG.TUSER_WIDTH {48} \
+} [get_ips packet_filter]
\ No newline at end of file
diff --git a/src/hbm_subsystem/vivado_ip/packet_parser.tcl b/src/hbm_subsystem/vivado_ip/packet_parser.tcl
new file mode 100644
index 0000000..a9905e7
--- /dev/null
+++ b/src/hbm_subsystem/vivado_ip/packet_parser.tcl
@@ -0,0 +1,19 @@
+set prj_root [file normalize ..]
+set p4_filepath ${prj_root}/src/hbm_subsystem
+
+if {[info exists p4_dir]} {
+  set p4file [glob -directory ${p4_dir} packet_parser.p4]
+} else {
+  set p4file [glob -directory ${p4_filepath} packet_parser.p4]
+}
+
+puts "p4file = ${p4file}"
+
+create_ip -name vitis_net_p4 -vendor xilinx.com -library ip -module_name packet_parser -dir ${ip_build_dir}
+set_property CONFIG.P4_FILE "${p4file}" [get_ips packet_parser]
+set_property -dict { 
+  CONFIG.AXIS_CLK_FREQ_MHZ {250} \
+  CONFIG.CAM_MEM_CLK_FREQ_MHZ {250} \
+  CONFIG.OUTPUT_METADATA_FOR_DROPPED_PKTS {true} \
+  CONFIG.PKT_RATE {250} \
+} [get_ips packet_parser]
diff --git a/src/hbm_subsystem/vivado_ip/vivado_ip.tcl b/src/hbm_subsystem/vivado_ip/vivado_ip.tcl
new file mode 100644
index 0000000..b1b9d1d
--- /dev/null
+++ b/src/hbm_subsystem/vivado_ip/vivado_ip.tcl
@@ -0,0 +1,8 @@
+set ips {
+  packet_arbiter
+  packet_filter
+  packet_parser
+  packet_deparser
+  metadata_filter
+  metadata_arbiter
+}
\ No newline at end of file
diff --git a/src/open_nic_shell.sv b/src/open_nic_shell.sv
index 572e191..36b2089 100644
--- a/src/open_nic_shell.sv
+++ b/src/open_nic_shell.sv
@@ -25,7 +25,10 @@ module open_nic_shell #(
   parameter int    NUM_PHYS_FUNC   = 1,
   parameter int    NUM_QUEUE       = 512,
   parameter int    NUM_QDMA        = 1,
-  parameter int    NUM_CMAC_PORT   = 1
+  parameter int    NUM_CMAC_PORT   = 1,
+  parameter int    BUCKET_SIZE     = 1024,       
+  parameter [31:0] NODE_IP         = 32'hC0643300,
+  parameter [47:0] NODE_MAC        = 48'h020A35070000
 ) (
 
 // Fix the CATTRIP issue for AU280, AU50, AU55C, and AU55N custom flow
@@ -278,7 +281,7 @@ module open_nic_shell #(
   wire                   [1:0] axil_box1_rresp;
   wire                         axil_box1_rready;
 
-  // QDMA subsystem interfaces to the box running at 250MHz
+  // QDMA subsystem interfaces to the HBM subsystem
   wire     [NUM_PHYS_FUNC*NUM_QDMA-1:0] axis_qdma_h2c_tvalid;
   wire [512*NUM_PHYS_FUNC*NUM_QDMA-1:0] axis_qdma_h2c_tdata;
   wire  [64*NUM_PHYS_FUNC*NUM_QDMA-1:0] axis_qdma_h2c_tkeep;
@@ -297,6 +300,25 @@ module open_nic_shell #(
   wire  [16*NUM_PHYS_FUNC*NUM_QDMA-1:0] axis_qdma_c2h_tuser_dst;
   wire     [NUM_PHYS_FUNC*NUM_QDMA-1:0] axis_qdma_c2h_tready;
 
+  // HBM subsystem interfaces to the box running at 250Mhz
+  wire         axis_hbm_h2c_tvalid;
+  wire [511:0] axis_hbm_h2c_tdata;
+  wire  [63:0] axis_hbm_h2c_tkeep;
+  wire         axis_hbm_h2c_tlast;
+  wire  [15:0] axis_hbm_h2c_tuser_size;
+  wire  [15:0] axis_hbm_h2c_tuser_src;
+  wire  [15:0] axis_hbm_h2c_tuser_dst;
+  wire         axis_hbm_h2c_tready;
+
+  wire         axis_hbm_c2h_tvalid;
+  wire [511:0] axis_hbm_c2h_tdata;
+  wire  [63:0] axis_hbm_c2h_tkeep;
+  wire         axis_hbm_c2h_tlast;
+  wire  [15:0] axis_hbm_c2h_tuser_size;
+  wire  [15:0] axis_hbm_c2h_tuser_src;
+  wire  [15:0] axis_hbm_c2h_tuser_dst;
+  wire         axis_hbm_c2h_tready;
+
   // Packet adapter interfaces to the box running at 250MHz
   wire     [NUM_CMAC_PORT-1:0] axis_adap_tx_250mhz_tvalid;
   wire [512*NUM_CMAC_PORT-1:0] axis_adap_tx_250mhz_tdata;
@@ -766,7 +788,11 @@ module open_nic_shell #(
   end: qdma_if
   endgenerate
 
-  hbm_subsystem hbm_subsystem_inst (
+  hbm_subsystem #(
+    .BUCKET_SIZE          (BUCKET_SIZE),
+    .NODE_IP              (NODE_IP),
+    .NODE_MAC             (NODE_MAC)
+  ) hbm_subsystem_inst (
     .s_axi_araddr         (axi_araddr),
     .s_axi_arburst        (axi_arburst),
     .s_axi_arcache        (axi_arcache),
@@ -807,10 +833,46 @@ module open_nic_shell #(
     .s_axi_wstrb          (axi_wstrb),
     .s_axi_wuser          (axi_wuser),
     .s_axi_wvalid         (axi_wvalid),
+
+    .s_axis_qdma_h2c_tvalid           (axis_qdma_h2c_tvalid),
+    .s_axis_qdma_h2c_tdata            (axis_qdma_h2c_tdata),
+    .s_axis_qdma_h2c_tkeep            (axis_qdma_h2c_tkeep),
+    .s_axis_qdma_h2c_tlast            (axis_qdma_h2c_tlast),
+    .s_axis_qdma_h2c_tuser_size       (axis_qdma_h2c_tuser_size),
+    .s_axis_qdma_h2c_tuser_src        (axis_qdma_h2c_tuser_src),
+    .s_axis_qdma_h2c_tuser_dst        (axis_qdma_h2c_tuser_dst),
+    .s_axis_qdma_h2c_tready           (axis_qdma_h2c_tready),
+
+    .m_axis_qdma_c2h_tvalid           (axis_qdma_c2h_tvalid),
+    .m_axis_qdma_c2h_tdata            (axis_qdma_c2h_tdata),
+    .m_axis_qdma_c2h_tkeep            (axis_qdma_c2h_tkeep),
+    .m_axis_qdma_c2h_tlast            (axis_qdma_c2h_tlast),
+    .m_axis_qdma_c2h_tuser_size       (axis_qdma_c2h_tuser_size),
+    .m_axis_qdma_c2h_tuser_src        (axis_qdma_c2h_tuser_src),
+    .m_axis_qdma_c2h_tuser_dst        (axis_qdma_c2h_tuser_dst),
+    .m_axis_qdma_c2h_tready           (axis_qdma_c2h_tready),
+
+    .m_axis_cmac_h2c_tvalid           (axis_hbm_h2c_tvalid),
+    .m_axis_cmac_h2c_tdata            (axis_hbm_h2c_tdata),
+    .m_axis_cmac_h2c_tkeep            (axis_hbm_h2c_tkeep),
+    .m_axis_cmac_h2c_tlast            (axis_hbm_h2c_tlast),
+    .m_axis_cmac_h2c_tuser_size       (axis_hbm_h2c_tuser_size),
+    .m_axis_cmac_h2c_tuser_src        (axis_hbm_h2c_tuser_src),
+    .m_axis_cmac_h2c_tuser_dst        (axis_hbm_h2c_tuser_dst),
+    .m_axis_cmac_h2c_tready           (axis_hbm_h2c_tready),
+
+    .s_axis_cmac_c2h_tvalid           (axis_hbm_c2h_tvalid),
+    .s_axis_cmac_c2h_tdata            (axis_hbm_c2h_tdata),
+    .s_axis_cmac_c2h_tkeep            (axis_hbm_c2h_tkeep),
+    .s_axis_cmac_c2h_tlast            (axis_hbm_c2h_tlast),
+    .s_axis_cmac_c2h_tuser_size       (axis_hbm_c2h_tuser_size),
+    .s_axis_cmac_c2h_tuser_src        (axis_hbm_c2h_tuser_src),
+    .s_axis_cmac_c2h_tuser_dst        (axis_hbm_c2h_tuser_dst),
+    .s_axis_cmac_c2h_tready           (axis_hbm_c2h_tready),
     
-    .axi_clk              (axis_aclk),
-    .axi_resetn           (sys_cfg_powerup_rstn),
-    .hbm_ref_clk          (ref_clk_100mhz)
+    .axi_clk                          (axis_aclk),
+    .axi_rstn                         (sys_cfg_powerup_rstn),
+    .hbm_ref_clk                      (ref_clk_100mhz)
   );
 
   generate for (genvar i = 0; i < NUM_CMAC_PORT; i++) begin: cmac_port
@@ -975,23 +1037,23 @@ module open_nic_shell #(
     .s_axil_rresp                     (axil_box0_rresp),
     .s_axil_rready                    (axil_box0_rready),
 
-    .s_axis_qdma_h2c_tvalid           (axis_qdma_h2c_tvalid),
-    .s_axis_qdma_h2c_tdata            (axis_qdma_h2c_tdata),
-    .s_axis_qdma_h2c_tkeep            (axis_qdma_h2c_tkeep),
-    .s_axis_qdma_h2c_tlast            (axis_qdma_h2c_tlast),
-    .s_axis_qdma_h2c_tuser_size       (axis_qdma_h2c_tuser_size),
-    .s_axis_qdma_h2c_tuser_src        (axis_qdma_h2c_tuser_src),
-    .s_axis_qdma_h2c_tuser_dst        (axis_qdma_h2c_tuser_dst),
-    .s_axis_qdma_h2c_tready           (axis_qdma_h2c_tready),
-
-    .m_axis_qdma_c2h_tvalid           (axis_qdma_c2h_tvalid),
-    .m_axis_qdma_c2h_tdata            (axis_qdma_c2h_tdata),
-    .m_axis_qdma_c2h_tkeep            (axis_qdma_c2h_tkeep),
-    .m_axis_qdma_c2h_tlast            (axis_qdma_c2h_tlast),
-    .m_axis_qdma_c2h_tuser_size       (axis_qdma_c2h_tuser_size),
-    .m_axis_qdma_c2h_tuser_src        (axis_qdma_c2h_tuser_src),
-    .m_axis_qdma_c2h_tuser_dst        (axis_qdma_c2h_tuser_dst),
-    .m_axis_qdma_c2h_tready           (axis_qdma_c2h_tready),
+    .s_axis_qdma_h2c_tvalid           (axis_hbm_h2c_tvalid),
+    .s_axis_qdma_h2c_tdata            (axis_hbm_h2c_tdata),
+    .s_axis_qdma_h2c_tkeep            (axis_hbm_h2c_tkeep),
+    .s_axis_qdma_h2c_tlast            (axis_hbm_h2c_tlast),
+    .s_axis_qdma_h2c_tuser_size       (axis_hbm_h2c_tuser_size),
+    .s_axis_qdma_h2c_tuser_src        (axis_hbm_h2c_tuser_src),
+    .s_axis_qdma_h2c_tuser_dst        (axis_hbm_h2c_tuser_dst),
+    .s_axis_qdma_h2c_tready           (axis_hbm_h2c_tready),
+
+    .m_axis_qdma_c2h_tvalid           (axis_hbm_c2h_tvalid),
+    .m_axis_qdma_c2h_tdata            (axis_hbm_c2h_tdata),
+    .m_axis_qdma_c2h_tkeep            (axis_hbm_c2h_tkeep),
+    .m_axis_qdma_c2h_tlast            (axis_hbm_c2h_tlast),
+    .m_axis_qdma_c2h_tuser_size       (axis_hbm_c2h_tuser_size),
+    .m_axis_qdma_c2h_tuser_src        (axis_hbm_c2h_tuser_src),
+    .m_axis_qdma_c2h_tuser_dst        (axis_hbm_c2h_tuser_dst),
+    .m_axis_qdma_c2h_tready           (axis_hbm_c2h_tready),
 
     .m_axis_adap_tx_250mhz_tvalid     (axis_adap_tx_250mhz_tvalid),
     .m_axis_adap_tx_250mhz_tdata      (axis_adap_tx_250mhz_tdata),
